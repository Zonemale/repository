<html>
<head>
  <title>Java API</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="412"/>
<h1>Java API</h1>

<div>
<span><div><div><span style="font-weight: bold;">一、Scanner类</span></div><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">功能：Scanner类可以实现键盘输入数据，到程序当中</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">引用类型使用步骤：</span></div></li></ol><div style="margin-left: 40px;">1）<span style="font-weight: bold;">导包：import 包路径.类名称;</span></div><div style="margin-left: 40px;">注意：<span style="color: rgb(255, 0, 0);">如果需要使用的目标类，和当前类位于同一个包下，则可以省略导包语句不写</span></div><div style="margin-left: 40px;">只有java.long包下的内容不需要导包，其他的包都需要import语句</div><div style="margin-left: 40px;">2）创建：类名称 对象名 = new 类名称();</div><div style="margin-left: 40px;">3）使用：对象名.成员方法名();</div><div>      3. 注意：<span style="color: rgb(255, 0, 0);">Scanner类中的next方法是将多种输入的内容作为字符串返回，而nextInt()方法是将字符串 转换为整形返回</span></div><div>      4. <span style="color: rgb(255, 0, 0);">匿名对象：只有右边的对象，没有左边的名字和赋值运算符</span></div><div>            格式：</div><div>            new 类名称();</div><div>            注意：<span style="color: rgb(255, 0, 0);">匿名对象只能使用唯一的一次</span></div><div><span style="font-weight: bold;">二、Random类</span></div><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">Random r = new Random();</span></div></li></ol><div>        int num = r.nextInt();//获取整个int范围内的随机数,有正负两种</div><div>       2. 获取一个随机的int数字（参数代表了范围，左闭又开区间）：int num = r.nextInt(3);</div><div>       3. Random获取的随机数是在使用的时候产生，而不是赋值的时候产生</div><div>       4. <span style="color: rgb(255, 0, 0);">Math.random();可以表示0~1之间的随机数，double类型（左闭右开）</span></div><div><span style="font-weight: bold;">三、ArrayList集合</span></div><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">数组有一个缺点：一旦创建，程序运行期间长度不可以发生改变</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">ArrayList集合的 长度是可以随意变化的</span></div></li><li><div>ArrayList的底层数据结构是数组</div></li><li><div><span style="font-style: normal; font-weight: bold; text-decoration: none;">泛型：也就是装在集合当中的所有元素，都是统一类型的元素</span></div></li><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">注意：</span><span style="color: rgb(255, 0, 0); font-style: normal; font-weight: bold; text-decoration: none;">ArrayList集合中泛型只能是引用类型，不能是基本类型</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;():E指的就是泛型,JDK1.7之后，右侧的尖括号内可以为空</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">对于ArrayList集合来说，直接打印得到的不是地址值，而是内容，如果内容是空，得到的是中括号 </span></div></li><li><div><span style="color: rgb(255, 175, 0);">如果不加后面尖括号中的泛型，那么这个集合可以存放任意类型</span></div></li></ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">ArrayList中常用方法</span></div></li><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">public boolean add(E e):向集合当中添加元素，参数的类型和泛型一致，<span style="font-style: normal; font-weight: normal; text-decoration: none; color: rgb(255, 0, 0);">返回值代表添加是否成功</span></span></div></li><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">备注：对于ArrayList集合来说，add添加动作一定是成功的，所以返回值可用可不用</span></div></li></ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">public E get(int index):从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">public E remove</span><span style="font-style: normal; font-weight: bold; text-decoration: none;">(int index)</span><span style="font-style: normal; font-weight: normal; text-decoration: none;">:从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">public int size();获取集合的尺寸长度，返回值时集合中包含的元素个数；</span></div></li></ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">如果希望向集合ArrayList当中存储基本数据类型，必须使用基本类型对应的包装类</span></div></li><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">基本类型 包装类（引用类型，包装类都位于java.long包中）</span></div></li></ol></ol><div style="margin-left: 80px;">byte     Byte</div><div style="margin-left: 80px;">short     Short</div><div style="margin-left: 80px;">int     Integer</div><div style="margin-left: 80px;">long     Long</div><div style="margin-left: 80px;">float     Float</div><div style="margin-left: 80px;">double     Double</div><div style="margin-left: 80px;">char     Character</div><div style="margin-left: 80px;">boolean Boolean</div><div style="margin-left: 80px;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">从JDK1.5开始，支持自动装箱、自动拆箱</span></div><div style="margin-left: 80px;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">自动装箱：基本类型----------&gt;包装类型</span></div><div style="margin-left: 80px;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">自动拆箱：包装类型-----------&gt;基本类型</span></div><div><span style="font-size: 12pt; font-weight: bold;">四、字符串</span></div><ol><li><div><span style="font-style: normal; font-weight: bold; text-decoration: none;">程序当中多有的双引号字符串都是String类的对象（就算没有new，也是对象）</span><span style="font-style: normal; font-weight: normal; text-decoration: none;">；</span></div></li><ol><li><div>特点：</div></li><ol><li><div><span style="color: rgb(255, 70, 53); font-style: normal; font-weight: bold; text-decoration: none;">直接创建的字符串的内容不可变</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-style: normal; font-weight: normal; text-decoration: none;">正是因为字符串不可变，所以字符串是可以共享使用的</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-style: normal; font-weight: normal; text-decoration: none;">字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组</span></div></li></ol></ol><li><div><span style="font-weight: bold;">创建字符串方法（三种构造方法，一种直接创建）</span></div></li><ol><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">public String();创建一个空白字符串，不含任何内容</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">public String(char[] array);根据字符数组的内容，来创建对应的字符串</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">public String(byte[] array);根据字节数组的内容，来创建对应的字符串</span></div></li><li><div><span style="font-style: normal; font-weight: normal; text-decoration: none;">String str = &quot;hello&quot;;右边直接用双引号</span></div></li><ol><li><div><span style="background-color: rgb(255, 250, 165); font-style: normal; font-weight: normal; text-decoration: none;-evernote-highlight:true;">注意：直接写上双引号，就是字符串对象</span></div></li></ol></ol><li><div><span style="font-weight: bold;">字符串常量池：<span style="font-weight: bold; color: rgb(255, 0, 0);">程序当中直接写上的双引号的字符串，就在字符串常量池中</span></span></div></li><ol><li><div>对于基本类型来说，==是进行数值的比较</div></li><li><div>对于引用类型的比较，==是进行地址值的比较</div></li><li><div>双引号直接写的在常量池中，new出来的没有再常量池中</div></li></ol><li><div><img src="Java API_files/字符串常量.PNG" type="image/png" data-filename="字符串常量.PNG" width="834"/></div></li><li><div><span style="font-weight: bold;">字符串的比较相关方法</span></div></li><ol><li><div>==：是进行地址比较</div></li><li><div>public boolean equals(Object obj);参数可以是任何对象</div></li><ol><li><div>备注：任何对象都能用Object进行接收。</div></li><li><div>equals是object的方法</div></li><li><div>只有内容是一个字符串并且内容相同才会返回一个true，否则返回false</div></li><li><div>equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果相同</div></li><ol><li><div>推荐使用：&quot;abc&quot;.equals(str),不推荐使用str.equals(&quot;abc&quot;);</div></li><li><div>String str = null;</div></li></ol><div>          System.out.println(&quot;abc&quot;.equals(str));//false</div><div>         System.out.println(str.equals(&quot;abc&quot;));//报错，空指针异常</div><div><br/></div></ol></ol></ol><div>                 3. <span style="color: rgb(222, 87, 0);">public boolean equalsIgnoreCase(String str);忽略大小写，进行比较</span></div><div><span style="color: rgb(222, 87, 0);">                 4. </span><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(222, 87, 0); font-family: &quot;Microsoft YaHei&quot;, tahoma, &quot;Hiragino Sans GB&quot;, &quot;\\5b8b体&quot;, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">boolean contains(String s);          判断当前字符串中是否包含传入的字符串</span></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(222, 87, 0); font-family: &quot;Microsoft YaHei&quot;, tahoma, &quot;Hiragino Sans GB&quot;, &quot;\\5b8b体&quot;, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">                5. </span> <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(222, 87, 0); font-family: &quot;Microsoft YaHei&quot;, tahoma, &quot;Hiragino Sans GB&quot;, &quot;\\5b8b体&quot;, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">boolean isEmpty();                   判断字符串是否为空</span></div><div><span style="font-weight: bold;">    6.String当中与获取相关的常用方法</span></div><ol><ol><li><div>public int length(): 获取字符串当中含有的字符个数，拿到字符串长度</div></li><li><div>public String cancat(String str):将当前字符串和参数字符串拼接成为返回值新的字符串</div></li><li><div>public char charAt(int index);获取指定索引位置的单个字符，（索引从0开始）</div></li><li><div>public int indexOf(String str):查找参数字符串在本字符串当中<span style="color: rgb(255, 0, 0);">首次出现</span>的索引位置，<span style="color: rgb(255, 0, 0);">如果没有返回-1值。</span></div></li><li><div>int lastIndexOf(String str);返回字符串最后出现的索引</div></li><li><div>boolean isok = str.endWith(&quot;.java&quot;);判断最后出现的字符串内容</div></li></ol></ol><div><span style="font-weight: bold;">    7.字符串的截取方法</span></div><ol><ol><li><div>public String substring(int index);截取从参数位置一直到字符串末尾，返回新字符串</div></li><li><div><img src="Java API_files/ScreenClip.png" type="image/png" data-filename="ScreenClip.png" width="375"/></div></li></ol><ol><li><div>public String substring(int begin, int end);截取从begin开始，一直到end结束，中间的字符串（包含左边，不包含右边）</div></li></ol></ol><div><span style="font-weight: bold;">8.字符串的转换相关方法</span></div><ol><ol><li><div>public char[] toCharArray();将当前字符串拆分成为字符数组作为返回值</div></li><li><div>public byte[] getBytes();获得当前字符串底层的字节数组</div></li><li><div>public String replace(CharSequence oldString, CharSequence newString);将所有出现的老字符串替换成为新的字符串（CharSequence意思是可以接收字符串类型）</div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(250, 122, 0); font-family: &quot;Microsoft YaHei&quot;, tahoma, &quot;Hiragino Sans GB&quot;, &quot;\\5b8b体&quot;, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">String repalceFirst(String oldStr,String newStr); 用新字符串替换第一个出现老字符串</span></span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Microsoft YaHei&quot;, tahoma, &quot;Hiragino Sans GB&quot;, &quot;\\5b8b体&quot;, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;"> String toUpperCase();                             将字符串转成大写</span></div></li><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Microsoft YaHei&quot;, tahoma, &quot;Hiragino Sans GB&quot;, &quot;\\5b8b体&quot;, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">String toLowerCase();                             将字符串转成小写</span></div></li></ol></ol><div><span style="font-weight: bold;">9.字符串的分割方法</span></div><ol><ol><li><div>public String[] split(String regex):按照字符串的规则，将字符串分为若干部分，返回字符串数组</div></li><li><div>注意事项：</div></li><ol><li><div>split方法的参数其实是一个“正则表达式”，如果要按照英文句点&quot;.&quot;进行分割，就得写成&quot;\\.&quot;</div></li></ol><li><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 14px; color: rgb(250, 122, 0); font-family: &quot;Microsoft YaHei&quot;, tahoma, &quot;Hiragino Sans GB&quot;, &quot;\\5b8b体&quot;, &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;"> String trim();                                    去除字符串两端的空白</span></span></div></li></ol></ol><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(247, 255, 0); font-family: &quot;Microsoft YaHei&quot;; font-weight: bold;">拓展：对象本身就存在toString()方法，如果不重写，那么久输出对象的地址值，可以选择重写。JDK会自动调用</span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 12pt; font-weight: bold;-evernote-highlight:true;">五、static关键字</span></span></div><ol><ol><li><div>一旦使用了static关键字，那么这样的内容<span style="color: rgb(255, 0, 0);">不再属于对象给自己，而是属于类</span>，凡是本类对象，<span style="color: rgb(255, 70, 53); font-weight: bold;">都共享同一份</span></div></li><li><div>一旦使用static修饰成员方法，那么这就成为了静态方法，静态方法不属于对象，而是属于类的</div></li><ol><li><div>对于静态方法来说，可以通过对象名进行调用，也可以通过类名称来调用（推荐使用类名称调用）</div></li><li><div>使用对象名对静态方法进行调用，在编译时也会被javac翻译为类名调用</div></li><li><div><span style="color: rgb(255, 0, 0);">无论是成员变量还是成员方法，如果使用static关键字修饰，就推荐使用类名称进行调用</span></div></li><li><div>静态变量：类名称.静态变量、静态方法：类名称.静态方法（）</div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">对于本类当中的静态方法，可以省略类名称</span></div></li></ol><li><div>注意事项：</div></li><ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">静态不能直接访问非静态</span></div></li><ol><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0); font-weight: bold;-evernote-highlight:true;">原因：因为在内存当中时先有静态内容，后有非静态内容</span></span></div></li></ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">静态方法中不能使用this关键字</span></div></li><li><div><span style="font-weight: bold;">根据类名称访问静态成员变量的时候，全程和对象没有关系</span></div></li></ol><li><div style="white-space: pre-wrap; text-indent: 28px; text-align: left; font-size: 14px;"></div></li></ol></ol><div><img src="Java API_files/ScreenClip [1].png" type="image/png" data-filename="ScreenClip.png" width="1262"/></div><div>          <span style="font-size: 10pt; font-weight: bold;">    5. 静态代码块</span></div><ol><ol><ol><li><div>   格式：</div></li></ol></ol></ol><div>                                   </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class 类名称{</div><div>   static{</div><div>       //静态代码块的内容</div><div>   }</div><div>}</div></div><div>                   </div><div>                           2. 特点：<span style="color: rgb(255, 0, 0); font-weight: bold;">当第一次用到本类时，静态代码块执行唯一的一次，</span><span style="font-weight: bold;">静态内容总是优先于非静态，所以静态代码块比构造方法先执行</span></div><div>                           3. <span style="color: rgb(255, 0, 0); font-weight: bold;">静态代码块的典型用途：用来一次性对静态成员变量进行赋值</span></div><div><span style="font-size: 12pt; font-weight: bold;">六、Arrays类</span></div><ol><li><div>public static String toString(数组）：将参数数组变成字符串（按照默认格式：[元素1，元素2，元素3......]）</div></li><li><div>public static void sort(数组):按照默认升序对数组进行排序，从小到大</div></li><li><div>注意事项：</div></li><ol><li><div>如果是数值，sort默认按照升序从小到大</div></li><li><div>如果是字符串，sort默认按照字母升序</div></li><li><div>如果是自定义的类型，那么这个自定义的类型需要有comparable或comparator接口的支持</div></li></ol></ol><div><span style="font-size: 12pt; font-weight: bold;">七、数学工具类</span></div><ol><li><div>public static double abs(double num);获取绝对值，有多重重载</div></li><li><div>public static double ceil(double num);向上取整</div></li><li><div>public static double floor(double num);向下取整</div></li><li><div>public static <span style="color: rgb(255, 0, 0);">long</span> round(double num);四舍五入</div></li><li><div>Math.PI代表近似的圆周率常量（double）</div></li><li><div>示例：Math.abs(2.53);</div></li></ol><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">八、object类(java.lang.Object)</span></div><ol><li><div><span style="font-size: 11pt; color: rgb(235, 0, 115);">类Object是类层次结构的根（父）类，每个类都使用Object作为超（父）类，所有对象（包括数组）都实现这个类的方法</span></div></li><li><div><span style="font-size: 11pt;">toString方法</span></div></li><ol><li><div><span style="font-size: 11pt;">直接打印对象的名字，其实就是调用对象的toString方法，打印的是对象的地址值</span></div></li><li><div><span style="font-size: 11pt;">看一个类是否重写了toString，直接打印这个类的对象即可，如果没有重写toString方法，那么打印的就是地址值</span></div></li></ol><li><div><span style="font-size: 11pt;">equals方法</span></div></li><ol><li><div><span style="font-size: 11pt;">指示其他某个对象是否和这个对象相等</span></div></li><li><div><span style="font-size: 11pt;">源码</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">public boolean equals(Object obj) {</font></div><div><font style="font-size: 10pt;">    return (this == obj);</font></div><div><font style="font-size: 10pt;">}</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 11pt;">示例；</font></div><div><font style="font-size: 11pt;">public boolean equals(Object obj){</font></div><div><font style="font-size: 11pt;">    if(this == obj){</font></div><div><font style="font-size: 11pt;">        return true;</font></div><div><font style="font-size: 11pt;">    }</font></div><div><font style="font-size: 11pt;">    if(obj == null){</font></div><div><font style="font-size: 11pt;">        return false;</font></div><div><font style="font-size: 11pt;">    }</font></div><div><font style="font-size: 11pt;">    if(obj instanceof Person){</font></div><div><font style="font-size: 11pt;">        Person p = (Person) obj;</font></div><div><font style="font-size: 11pt;">        boolean flag = this.name.equals(p.name) &amp;&amp; this.age == p.age;</font></div><div><font style="font-size: 11pt;">        return flag;</font></div><div><font style="font-size: 11pt;">    }</font></div><div><font style="font-size: 11pt;">    return false;</font></div><div><font style="font-size: 11pt;">}</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">参数：</font></div><div><font style="font-size: 10pt;">    Object obj：可以传递任意的对象，<font color="#FF4635">是一个方法：只能比较引用数据类型，<b>不能比较基本数据类型·</b>对于引用类型来说，没有重写equals方法，则比较的是两个对象的地址。如果重写了该方法，则比较的是对象中的内容是否相等（String方法就是重写了equals方法）</font></font></div><div><font style="font-size: 10pt;">    == 比较运算符，返回的是一个布尔值，true或false，<font color="#FF4635">既可以比较基本数据类型的数据，也可以比较引用数据类型的数据（基本类型比较的是值，引用数据类型比较的是地址值）</font></font></div><div><font style="font-size: 10pt;">    基本数据类型：比较的是值</font></div><div><font style="font-size: 10pt;">    引用数据类型：比较的是两个对象的地址值</font></div><div><font style="font-size: 10pt;">    哪个对象调用的方法，方法中的this就指的是谁</font></div></div><ol><li><div><span style="font-size: 14.6667px;">拓展：Objects工具类。</span><span style="font-size: 14.6667px;">Objects是一个对Object进行操作的工具类</span></div></li><ol><li><div><span style="font-size: 14.6667px;">工具类的特点：</span></div></li><ul><li><div><span style="font-size: 14.6667px;">构造方法私有化（private修饰）</span></div></li><li><div><span style="font-size: 14.6667px;">都是使用static修饰的，可以直接“类名.”的方式调用</span></div></li><li><div><span style="font-size: 14.6667px;">Objects.equals(obj a,obj 2）:已经封装好的equals方法</span></div></li></ul></ol></ol><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">九、Date类（java.util.Date）</span></div><ol><li><div><span style="font-size: 11pt;">类Date表示特定的瞬间，精确到毫秒</span></div></li><li><div><span style="font-size: 11pt;">1000毫秒 = 1秒</span></div></li><li><div><span style="font-size: 11pt;">时间原点：1970年1月1日  00:00:00（英国格林威治时间）</span></div></li><li><div><span style="font-size: 11pt;">System.currentTimeMillis()</span></div></li><ol><li><div><span style="font-size: 11pt;">获取当前系统一共到1970年1月1日经历了多少毫秒,lang类型</span></div></li></ol></ol><div><span style="font-size: 11pt;">注意事项：中国属于东八区，会把时间增加8个小时</span></div><div><span style="font-size: 11pt;">       5.Date()对象的构造方法</span></div><div><span style="font-size: 11pt;">           </span> <span style="font-size: 11pt; color: rgb(255, 0, 0);">Date date = new Date();获取当前时间</span></div><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">            Date date = new Date(0L);获取指定毫秒值所对应的时间</span></div><div><span style="font-size: 11pt;">        6.</span><span style="font-size: 11pt; color: rgb(255, 70, 53);">long getTime();</span><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">把日期转换为毫秒值（相当于currentTimeMilis()）</span></div><div><span style="font-size: 12pt; font-weight: bold;">十、DateFomat类（java.text.DateFomat）</span></div><ol><li><div><span style="font-size: 11pt;">java.textDateFormat是日期、时间格式化子类的</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">抽象类</span></div></li><li><div><span style="font-size: 11pt;">作用：格式化（日期-&gt;文本）、解析（文本-&gt;日期）</span></div></li><li><div><span style="font-size: 11pt;">成员方法：</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">String format(Date date)按照指定的模式，把Date日期，格式为符合模式的字符串</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">Date parse(String source)把符合模式的字符串，解析为Date日期</span></div></li><ol><li><div><span style="font-size: 11pt;">使用步骤：</span></div></li><ul><li><div><span style="font-size: 11pt;">创建SimpleDateFormat对象，构造方法中传递指定的模式</span></div></li><li><div><span style="font-size: 11pt;">调用SimpleDateFormat对象中的parse方法，把符合构造方法中的模式的字符串，解析为Date日期</span></div></li><li><div><span style="font-size: 11pt;">注意：</span></div></li><ul><li><div><span style="font-size: 11pt;">public Date parse(String source) throws ParseException</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(166, 0, 196);">parse方法声明了一个异常叫</span></span><span style="font-size: 11pt; color: rgb(255, 0, 0);">ParseException</span></div></li><li><div><span style="font-size: 11pt;">如果字符串和构造方法的模式不一样，那么程序就会抛出异常</span></div></li><li><div><span style="font-size: 11pt;">调用一个抛出了异常的方法，就必须处理这个异常，要么throw抛出这个异常，要么try catch自己处理这个异常</span></div></li></ul></ul></ol></ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">DateFormat类是一个抽象类，无法直接创建对象使用，可以使用DateFormat类的子类</span></div></li><ol><li><div><span style="font-size: 11pt;">java.text.SimpleDateFormat extends DateFormat</span></div></li><ul><li><div><span style="font-size: 11pt;">构造方法：</span></div></li><li><div><a href="mk:java/text/SimpleDateFormat.html#SimpleDateFormat(java.lang.String)" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">SimpleDateFormat</a><span style="font-size: 11pt;">(</span><a href="mk:java/lang/String.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="java.lang 中的类">String</a><span style="font-size: 11pt;"> pattern) 用给定的模式和默认语言环境的日期格式符号构造 SimpleDateFormat。</span></div></li><li><div><span style="font-size: 11pt;">参数：</span></div></li><ul><li><div><span style="font-size: 11pt;">y    年</span></div></li><li><div><span style="font-size: 11pt;">M    月</span></div></li><li><div><span style="font-size: 11pt;">d    日</span></div></li><li><div><span style="font-size: 11pt;">H    时</span></div></li><li><div><span style="font-size: 11pt;">m    分</span></div></li><li><div><span style="font-size: 11pt;">s    秒</span></div></li></ul><li><div><span style="font-size: 11pt;">写对应的模式，会把模式替换为对应的日期和时间（yyyy-MM-dd  HH:mm:ss）</span></div></li><li><div><span style="font-size: 11pt;">注意：模式中的字母不能改变，连接模式的符号可以改变</span></div></li></ul></ol></ol><div><span style="font-size: 12pt; font-weight: bold;">十一、Calendar类（java.util.Calendar）:日历类</span></div><ol><li><div><span style="font-size: 11pt;">Calendar类是一个</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">抽象类</span><span style="font-size: 11pt;">，里边提供了很多操作日历字段的方法</span></div></li><li><div><span style="font-size: 11pt;">Calendar类无法直接创建对象使用，</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">里边有一个静态方法叫getInstance(),</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">该方法返回了Calendar类的子对象</span></div></li><li><div><span style="font-size: 11pt;">static Calendar getInstance():使用默认时区语言环境获得一个日历</span></div></li><li><div><span style="font-size: 11pt;">Calendar类常用方法</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public int get(int field)</span><span style="font-size: 11pt;">:返回给定日历字段的值</span></div></li><ul><li><div><span style="font-size: 11pt;">int  field</span><span style="font-size: 11pt; color: rgb(227, 0, 0);">:日历类的字段</span><span style="font-size: 11pt;">，可以使用Calendar类的静态成员变量获取</span></div></li></ul><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public void set(int field,int value)</span><span style="font-size: 11pt;">:将给定的日历字段设置为给定值</span></div></li><ul><li><div><span style="font-size: 11pt;">int  field:日历类的字段，可以使用Calendar类的静态成员变量获取</span></div></li><li><div><span style="font-size: 11pt;">int value:给指定字段设置的值</span></div></li></ul><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public abstract void add(int field,int amount)</span><span style="font-size: 11pt;">:根据日历的规则，为给定的日历字段添加或减去指定的时间量</span></div></li><ul><li><div><span style="font-size: 11pt;">int amount:增加/减少的值</span></div></li></ul><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public Date getTime()</span><span style="font-size: 11pt;">:返回一个表示此Calendar的时间值的Date对象</span></div></li><ul><li><div><span style="font-size: 11pt;">把日历对象转换为日期对象</span></div></li></ul></ol></ol><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">十二、System类</span></div><ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public static long currentTimeMillis(</span><span style="font-size: 11pt;">):返回以毫秒为单位的当前时间</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public staic void arraycopy(Object src,int srcPos,Object dest,int destPos,int length)</span><span style="font-size: 11pt;">将数组中的指定的数据拷贝到另一个数组中</span></div></li><ul><li><div><span style="font-size: 11pt;">参数：</span></div></li><ul><li><div><span style="font-size: 11pt;">src - 源数组。</span></div></li><li><div><span style="font-size: 11pt;">srcPos - 源数组中的起始位置。</span></div></li><li><div><span style="font-size: 11pt;">dest - 目标数组。</span></div></li><li><div><span style="font-size: 11pt;">destPos - 目标数据中的起始位置。</span></div></li><li><div><span style="font-size: 11pt;">length - 要复制的数组元素的数量。</span></div></li></ul></ul></ol><div><span style="font-size: 12pt; font-weight: bold;">十三、StringBuilder类（java.lang.StringBuilder类，字符串缓冲区）</span></div><div><span style="font-weight: bold;"><img src="Java API_files/ScreenClip [2].png" type="image/png" data-filename="ScreenClip.png"/></span></div><ol><li><div><span style="font-size: 11pt; font-weight: bold;">构造方法：</span></div></li></ol><ol><ol><li><div><a href="mk:java/lang/StringBuilder.html#StringBuilder()" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">StringBuilder</a><span style="font-size: 11pt;">()构造一个不带任何字符的字符串生成器，其</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">初始容量为 16 个字符</span><span style="font-size: 11pt;">。</span></div></li><li><div><a href="mk:java/lang/StringBuilder.html#StringBuilder(java.lang.String)" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">StringBuilder</a><span style="font-size: 11pt;">(</span><a href="mk:java/lang/String.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="java.lang 中的类">String</a><span style="font-size: 11pt;"> str)构造一个字符串生成器，并初始化为指定的字符串内容。</span></div></li></ol></ol><div><span style="font-size: 11pt; font-weight: bold;">      2. 成员方法：</span></div><ol><ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public  StringBuilder append(...)</span><span style="font-size: 11pt;">:添加任意类型数据的字符串形式，</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">并返回当前对象自身</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">StringBuilder insert(int offset, 任意类型)，往字符串中插入任意类型</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">public String toString():</span><span style="font-size: 11pt;">将当前StringBuilder对象转换为String对象</span></div></li><li><div>public  String  reverse()方法，反转字符串</div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(209, 0, 255);">链式编程：方法返回值是一个对象，可以继续调用方法</span></span></div></li></ol><div><span style="font-size: 12pt; font-weight: bold;">十四、包装类</span></div><ol><li><div><span style="font-size: 11pt; font-weight: bold;">概念</span><span style="font-size: 11pt;">：基本数据类型使用起来非常方便，但是没有对应的方法来操作这些基本类型的数据，可以使用一个类，把基本类型的数据装起来，在类中定义一些方法，这个类叫做包装类，我们可以使用类中的方法来操作这些基本类型的数据</span></div></li><li><div><span style="font-size: 11pt; font-weight: bold;">装箱：把基本类型的数据，包装到包装类中</span></div></li><ol><li><div><span style="font-size: 11pt;">构造方法：</span></div></li></ol></ol><div><a href="mk:java/lang/Integer.html#Integer(int)" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">Integer</a><span style="font-size: 11pt;">(int value)</span></div><div><span style="font-size: 11pt;">          构造一个新分配的 Integer 对象，它表示指定的 int 值。</span></div><div><a href="mk:java/lang/Integer.html#Integer(java.lang.String)" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">Integer</a><span style="font-size: 11pt;">(</span><a href="mk:java/lang/String.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="java.lang 中的类">String</a><span style="font-size: 11pt;"> s)</span></div><div><span style="font-size: 11pt;">          构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。</span></div><div><span style="font-size: 11pt;">                 2. 静态方法</span></div><div><span style="font-size: 11pt;">static </span><a href="mk:java/lang/Integer.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="java.lang 中的类">Integer</a>  <a href="mk:java/lang/Integer.html#valueOf(int)" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">valueOf</a><span style="font-size: 11pt;">(int i)</span></div><div><span style="font-size: 11pt;">          返回一个表示指定的 int 值的 Integer 实例。</span></div><div><span style="font-size: 11pt;">static </span><a href="mk:java/lang/Integer.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="java.lang 中的类">Integer</a>  <a href="mk:java/lang/Integer.html#valueOf(java.lang.String)" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">valueOf</a><span style="font-size: 11pt;">(</span><a href="mk:java/lang/String.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="java.lang 中的类">String</a><span style="font-size: 11pt;"> s)</span></div><div><span style="font-size: 11pt;">          返回保存指定的 String 的值的 Integer 对象。</span></div><div><span style="font-size: 11pt;">            如果是一个不能转换的字符串则报：NumberFormatException（数字格式化异常）</span></div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">    </span><span style="font-size: 11pt; font-weight: bold;">  3.拆箱：在包装类中取出基本类型的数据（包装类-&gt;基本类型的数据）</span></font></div><ol><ol><li><div><span style="font-size: 11pt;">成员方法：</span></div></li></ol></ol><div><span style="font-size: 11pt;">int</span><span style="font-size: 11pt;"> </span><a href="mk:java/lang/Integer.html#intValue()" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">intValue</a><span style="font-size: 11pt;">()</span></div><div><span style="font-size: 11pt;">          以 int 类型返回该 Integer 的值。</span></div><div><span style="font-size: 11pt; font-weight: bold;">     4.自动装箱与自动拆箱</span></div><ol><li><div><span style="font-size: 11pt;">基本类型的数据和包装类之间可以自动的相互转换</span></div></li></ol><div><span style="font-size: 11pt;">    <span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;"> </span></span><span style="font-size: 11pt; background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;">5. 基本类型与字符串之间的转换</span></div><ol><li><div><span style="font-size: 11pt;">基本类型转换String总共有三种方式，其中之一：</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">基本类型直接与&quot;&quot;相连即可，如：423 + &quot;&quot;</span></span></div></li><li><div><span style="font-size: 11pt;">包装类的静态方法toString(参数):static String toString(int i);</span></div></li><li><div><span style="font-size: 11pt;">String类的静态方法valueOf(参数):static String valueOf(int i);</span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">除了Character类之外</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本数据类型</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">使用包装类的静态方法parseXxx(“数值类型的字符串”)</span></span></div></li></ul></ol><div><span style="font-size: 12pt; font-weight: bold;">十五、Collection集合</span></div><ol><li><div><span style="font-size: 11pt;">概念：集合是Java中提供的一种容器，可以用来存储多个数据</span></div></li><li><div><span style="font-size: 11pt;">与数组的区别</span></div></li><ul><li><div><span style="font-size: 11pt;">数组的长度是固定的，集合的长度是可变的</span></div></li><li><div><span style="font-size: 11pt;">数组中存储的是同一类型的元素，可以存储基本数据类型值，集合存储的都是对象，而且对象的类型可以不一致，在开发中一般当对象多的时候，使用到集合进行存储</span></div></li></ul><li><div><span style="font-size: 11pt;">集合框架</span></div></li></ol><div><img src="Java API_files/01_集合框架介绍.bmp" type="image/bmp" data-filename="01_集合框架介绍.bmp" width="1252"/></div><ol><li><div><span style="font-size: 11pt;">Collection常用功能</span></div></li><ul><li><div><span style="font-size: 11pt;">public boolean add(E e)：  把给定的对象添加到当前集合中 。</span></div></li><li><div><span style="font-size: 11pt;">public void clear()` :清空集合中所有的元素。</span></div></li><li><div><span style="font-size: 11pt;">public boolean remove(E e)`: 把给定的对象在当前集合中删除。</span></div></li><li><div><span style="font-size: 11pt;">public boolean contains(E e)`: 判断当前集合中是否包含给定的对象。</span></div></li><li><div><span style="font-size: 11pt;">public boolean isEmpty()`: 判断当前集合是否为空。</span></div></li><li><div><span style="font-size: 11pt;">public int size()`: 返回集合中元素的个数。</span></div></li><li><div><span style="font-size: 11pt;">public Object[] toArray()`: 把集合中的元素，存储到数组中。</span></div></li></ul></ol><div><span style="font-size: 12pt; font-weight: bold;">十六、Interator迭代器（java.util.Iterator）</span></div><ol><li><div><span style="font-size: 11pt;">迭代：</span><span style="font-size: 11pt; font-weight: bold;">即Collection集合元素的通用获取方式</span><span style="font-size: 11pt;">。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</span></div></li><li><div><span style="font-size: 11pt;">常用方法</span></div></li></ol><div><span style="font-size: 11pt;">             boolean  </span><a href="mk:java/util/Iterator.html#hasNext()" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">hasNext</a><span style="font-size: 11pt;">() 如果仍有元素可以迭代，则返回 true。</span></div><div><span style="font-size: 11pt;">             </span><a href="mk:java/util/Iterator.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="Iterator 中的类型参数">E</a><span style="font-size: 11pt;">   </span><a href="mk:java/util/Iterator.html#next()" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">next</a><span style="font-size: 11pt;">() 返回迭代的下一个元素。</span></div><div><span style="font-size: 11pt;">      3. Iterator迭代器，是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象</span></div><div><span style="font-size: 11pt;">            Collection接口中有一个方法，叫iterator()，这个方法返回的就是迭代器的实现类对象</span></div><div><span style="font-size: 11pt;">            Iterator&lt;E&gt; iterator() 返回在此collection的元素上进行迭代的迭代器</span></div><div><span style="font-size: 11pt;">      4.迭代器的使用步骤</span></div><ol><ol><li><div><span style="font-size: 11pt;">使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</span></div></li><ul><li><div><span style="font-size: 11pt;">注意：Iterator&lt;E&gt;接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型</span></div></li></ul><li><div><span style="font-size: 11pt;">使用Iterator接口中的方法 hasNext判断还有没有下一个元素</span></div></li><li><div><span style="font-size: 11pt;">使用Iterator接口中的方法next取出集合中的下一个元素</span></div></li><ul><li><div><span style="font-size: 11pt;">没有元素，在取出元素抛出NoSuchElementException没有元素异常</span></div></li></ul></ol></ol><div><img src="Java API_files/02_迭代器的实现原理(1).bmp" type="image/bmp" data-filename="02_迭代器的实现原理(1).bmp"/></div><div>        5<span style="font-size: 11pt;">.增强for（</span><span style="font-size: 11pt; color: rgb(235, 0, 115); font-weight: bold;">只能遍历单列集合</span><span style="font-size: 11pt;">）</span></div><ol><ol><li><div><span style="font-size: 11pt;">增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</span></div></li><li><div><span style="font-size: 11pt;">格式：</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">for(元素的数据类型  变量:<font color="#FF4635"><b>collection集合or数组</b></font>){</font></div><div><font style="font-size: 10pt;">    //写操作代码</font></div><div><font style="font-size: 10pt;">}</font></div></div><div>                 3.<span style="font-size: 11pt;"> 注意事项：</span></div><ul><ul><ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">底层使用的也是迭代器</span></span></div></li><li><div><span style="font-size: 11pt;">新for循环必须有被遍历的目标。</span></div></li><li><div><span style="font-size: 11pt;">目标只能是Collection或者数组（单列集合）</span></div></li><li><div><span style="font-size: 11pt;">新式for仅仅作为遍历使用</span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">遍历时不能添加或删除</span></span></div></li></ul></ul></ul><div><span style="font-size: 12pt; font-weight: bold;">十七、泛型</span></div><ol><li><div>概念：</div></li></ol><div><img src="Java API_files/03_泛型的概念.bmp" type="image/bmp" data-filename="03_泛型的概念.bmp" width="951"/></div><ol><li><div><span style="font-size: 11pt;">创建集合对象，不使用泛型</span></div></li><ol><li><div><span style="font-size: 11pt;">好处：集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据</span></div></li><li><div><span style="font-size: 11pt;">弊端：不安全，会引发异常</span></div></li></ol><li><div><span style="font-size: 11pt;">创建集合对象，使用泛型</span></div></li><ol><li><div><span style="font-size: 11pt;">好处：</span></div></li><ul><li><div><span style="font-size: 11pt;">避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</span></div></li><li><div><span style="font-size: 11pt;">把运行期异常（代码运行之后会抛出异常），提升到了编译器</span></div></li></ul><li><div><span style="font-size: 11pt;">弊端</span></div></li><ul><li><div><span style="font-size: 11pt;">泛型是什么类型，就只能存储什么类型</span></div></li></ul></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">泛型类的定义与使用</span></span></div></li><ol><li><div><span style="font-size: 11pt;">格式：</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">修饰符 class 类名&lt;代表泛型的变量&gt; {  }</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">示例：</font></div><div><font style="font-size: 10pt;">public class Person<font color="#FF0000">&lt;E&gt;</font> {</font></div><div><font style="font-size: 10pt;">    private <font color="#FF0000">E</font> name;</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">    public <font color="#FF0000">E</font> getName() {</font></div><div><font style="font-size: 10pt;">        return name;</font></div><div><font style="font-size: 10pt;">    }</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">    public void setName(<font color="#FF0000">E</font> name) {</font></div><div><font style="font-size: 10pt;">        this.name = name;</font></div><div><font style="font-size: 10pt;">    }</font></div><div><font style="font-size: 10pt;">}</font></div></div><div>       <span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">4. 含有泛型的方法</span></span></div><ol><ol><li><div><span style="font-size: 11pt;">格式：</span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">泛型定义在方法的修饰符和返回值类型之间</span></span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数（参数使用泛型）){  }</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">示例：</font></div><div><font style="font-size: 10pt;">public <font color="#FF0000">&lt;E&gt;</font> void method1(E name){</font></div><div><font style="font-size: 10pt;">    System.out.println(name);</font></div><div><font style="font-size: 10pt;">}</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">public static <font color="#FF0000">&lt;S&gt;</font> void method2(S str){</font></div><div><font style="font-size: 10pt;">    System.out.println(str);</font></div><div><font style="font-size: 10pt;">}</font></div></div><div>                <span style="font-size: 11pt;">  2. 含有泛型的方法，在调用方法的时候确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型</span></div><ul><li><div><span style="font-size: 14.6667px;">个人心得：</span></div></li><ul><li><div><span style="font-size: 14.6667px;">在方法中使用泛型的时候，凡是能用到变量类型的地方都可以使用泛型，包括返回值类型，参数类型等</span></div></li><li><div><span style="font-size: 14.6667px;">但是泛型在使用该方法的时候就已经被定义好了，所以返回值必须和参数的泛型一致</span></div></li><li><div><span style="font-size: 14.6667px;">问题：</span></div></li><ul><li><div><span style="font-size: 14.6667px;">修饰符和返回值类型之间的泛型字母什么作用</span></div></li><li><div><span style="font-size: 14.6667px;">返回值类型为什么必须和参数类型一致（因为返回值类型无法确定？）</span></div></li></ul></ul></ul><div><span style="font-size: 11pt;">      <span style="font-size: 11pt; font-weight: bold;"> 5. 含有泛型的接口</span></span></div><ol><ol><li><div><span style="font-size: 11pt;">格式：</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">修饰符 interface接口名&lt;代表泛型的变量&gt; {  }</font></div></div><div>                 <span style="font-size: 11pt;">2. 实现方式</span></div><ul><ul><ul><li><div><span style="font-size: 11pt;">方式一：定义接口的实现类，实现接口</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">public interface Inter&lt;I&gt; {</font></div><div><font style="font-size: 10pt;">    public abstract void method(I i);</font></div><div><font style="font-size: 10pt;">}</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">GenericInterFAceImpl实现了Inter接口，并且指定泛型为String，所以重写next方法泛型默认就是String</font></div><div><font style="font-size: 10pt;">public class GenericInterfaceImpl implements Inter&lt;String&gt; {</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">    @Override</font></div><div><font style="font-size: 10pt;">    public void method(String str) {</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">    }</font></div><div><font style="font-size: 10pt;">}</font></div><div><br/></div></div><ul><ul><ul><li><div><span style="font-size: 11pt;">方式二：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 10pt;">public interface Inter&lt;I&gt; {</font></div><div><font style="font-size: 10pt;">    public abstract void method(I i);</font></div><div><font style="font-size: 10pt;">}</font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;"><br/></font></div><div><font style="font-size: 10pt;">public class GenericInterfaceImpl2&lt;I&gt; implements Inter&lt;I&gt; {</font></div><div><font style="font-size: 10pt;">    @Override</font></div><div><font style="font-size: 10pt;">    public void method(I i) {</font></div><div><font style="font-size: 10pt;">        System.out.println(i);</font></div><div><font style="font-size: 10pt;">    }</font></div><div><font style="font-size: 10pt;">}</font></div></div><div>       <span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">6. 泛型通配符 </span></span></div><ol><ol><li><div><span style="font-size: 11pt;">不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。此时只能接受数据,不能往该集合中存储数据。</span></div></li><li><div><span style="font-size: 11pt;">注意：</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">泛型没有继承的概念</span><span style="font-size: 11pt;">。当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 </span></div></li><li><div><span style="font-size: 11pt;">使用方式：</span></div></li><ul><li><div><span style="font-size: 11pt;">不能创建对象使用，只能作为方法的参数使用 </span></div></li></ul><li><div><span style="font-size: 11pt;">通配符高级使用----<span style="font-size: 11pt; color: rgb(255, 0, 0);">受限泛型</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 70, 53);">泛型的上限：</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 70, 53);">格式：类型名称 &lt;? extends 类 &gt; 对象名称</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 70, 53);">意义：只能接收该类型及其子类型</span></span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 70, 53);">泛型的下限</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 70, 53);">格式：类型名称 &lt;? super 类 &gt; 对象名称</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 70, 53);">意义：只能接收该类型及其父类型</span></span></div></li></ul></ol></ol></ol><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">十八、Collections</span></font></div><ol><li><div><span style="font-size: 11pt;"> 常用功能</span></div></li><ul><li><div><span style="font-size: 11pt;">public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素</span></div></li><li><div><span style="font-size: 11pt;">public static void shuffle(List&lt;?&gt; list) 打乱顺序 :打乱集合顺序。</span></div></li><li><div><span style="font-size: 11pt;">public static &lt;T&gt; void sort(List&lt;T&gt; list) :将集合中元素按照默认规则排序</span></div></li><li><div><span style="font-size: 11pt;">public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ) :将集合中元素按照指定规则排序</span></div></li><ul><li><div><span style="font-size: 11pt;">注意事项：</span></div></li><ul><li><div><span style="font-size: 11pt;">sort（List&lt;T&gt; list）使用前提：被排序的集合里边存储的元素，必须实现Compare，重写接口中的CompareTo方法定义排序规则</span></div></li><li><div><span style="font-size: 14.6667px;">如果排序规则中两个值相等，则哪一个先添加就把哪一个放在前面</span></div></li></ul></ul></ul><li><div><span style="font-size: 11pt;">Comparator和Comparable的区别：</span></div></li><ol><li><div><span style="font-size: 11pt;">Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则CompareTo方法</span></div></li><ol><li><div><span style="font-size: 14.6667px;">Comparable自然排序：</span></div></li><ol><li><div><span style="font-size: 11pt;">static void sort(List&lt;T&gt; list);是对JDK提供的类类型数据进行排序</span></div></li><li><div><span style="font-size: 14.6667px;">如果对自定义的类型数据进行排序，该类必需实现接口，重写方法</span></div></li><li><div><span style="font-size: 14.6667px;">步骤</span></div></li><ol><li><div><span style="font-size: 14.6667px;">自定义对象所在的类必须实现Comparable接口</span></div></li><li><div><span style="font-size: 14.6667px;">自定义对象所在的类必须重写（CompareTo）</span></div></li><ol><li><div><span style="font-size: 11pt;">public int compareTo(T o);comepareTo方法内部就编写了排序的规则</span></div></li><li><div><span style="font-size: 14.6667px;">CompareTo中this - o 是升序，o - this 降序</span></div></li><li><div><span style="font-size: 14.6667px;">compareTo返回值</span></div></li><ol><li><div><span style="font-size: 14.6667px;">负数：要参与排序的元素就会放到已排序元素的左边</span></div></li><li><div><span style="font-size: 11pt;">0：位置不变</span></div></li><li><div><span style="font-size: 14.6667px;">正数：位置不变，保持在右边</span></div></li></ol></ol><li><div>o是已经比较完成的元素，this是即将比较的元素</div></li></ol></ol></ol><li><div><span style="font-size: 11pt;">Comparator比较器排序：相当于找一个第三方的裁判进行比较，o1-o2升序，反之降序</span></div></li><ol><li><div><span style="font-size: 14.6667px;">步骤</span></div></li><ol><li><div><span style="font-size: 14.6667px;">创建一个比较器对象（实现类对象，匿名内部类对象）传递到sort方法中</span></div></li><li><div><span style="font-size: 14.6667px;">在事项类或者匿名内部类中重写compare方法：<span style="font-size: 14.6667px; color: rgb(255, 0, 0);">public int compare(Student o1,Student o2);</span></span></div></li><li><div><span style="font-size: 11pt;">o1就相当于自然排序中的this，o2就相当于自然排序中的o</span></div></li><li><div><span style="font-size: 11pt;">o1-o2升序，反之降序</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">如果对JDK提供的类类型数据进行排序，没有传递比较器，则默认排序是自然排序的升序方式，如果自然排序和比较器排序共存，则选择比较器排序</span></div></li></ol></ol><div><span style="font-size: 12pt; font-weight: bold;">十九、Map集合（java.util.Map&lt;k,v&gt;）</span></div><ol><li><div><span style="font-size: 14.6667px;">概念：将键映射到值的对象，一个映射</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">不能包含重复的键</span><span style="font-size: 14.6667px;">；</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">每个键最多只能映射到一个值</span></div></li><li><div><span style="font-size: 14.6667px;">特点：</span></div></li><ul><li><div><span style="font-size: 11pt;">Map&lt;K,V&gt;</span></div></li><li><div><span style="font-size: 11pt;">Map集合是一个</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">双列集合</span><span style="font-size: 11pt;">，</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">一个元素包含两个值（一个key，一个value）</span></div></li><li><div>Map集合中的元素，<span style="color: rgb(255, 0, 0);">key和value的数据类型可以相同，也可以不同</span></div></li><li><div>Map集合中的元素，<span style="color: rgb(255, 0, 0); font-weight: bold;">key是不允许重复的，value是可以重复的</span></div></li><li><div>Map集合中的元素，key和value是一一对应的</div></li></ul><li><div>Map集合常用子类</div></li><ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">HashMap&lt;K,V&gt;集合</span>：存储数据采用哈希表结构，元素的存取<span style="color: rgb(255, 0, 0);">顺序不能保证一致</span>，由于要保证键的唯一、不重复，<span style="color: rgb(255, 0, 0);">需要重写键的hashCode（）方法、equals（）方法</span></div></li><ol><li><div>特点：</div></li><ul><li><div><span style="color: rgb(255, 0, 0);">底层是哈希表，查询的速度特别快</span></div></li><ul><li><div>JDK1.8之前，数组 + 单向链表</div></li><li><div>JDK1.8之后：数组 + 单向链表/红黑树（链表的长度大于8时）</div></li></ul><li><div><span style="color: rgb(255, 0, 0);">是一个无序集合，存储元素和取出元素顺序可能不一致</span></div></li><li><div><span style="color: rgb(255, 0, 0);">无索引，不能操作和索引相关的方法，索引map集合也没有索引相关方法</span></div></li></ul></ol><li><div><span style="color: rgb(255, 70, 53); font-weight: bold;">LinkeddHashMap&lt;K,V&gt;集合</span>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构，通过链表结构可以<span style="color: rgb(255, 0, 0); font-weight: bold;">保证元素的存取顺序一致</span>，通过哈希表结构可以保证的键的唯一不重复，需要重写键的hashCode（）方法，equals（）方法</div></li><ol><li><div>特点：</div></li><ul><li><div><span style="color: rgb(255, 0, 0);">底层是哈希表 + 链表</span></div></li><li><div><span style="color: rgb(255, 0, 0);">集合是一个有序的集合，存储元素和取出元素顺序是一致的</span></div></li></ul></ol></ol><li><div>常用方法：</div></li><ul><li><div><p style="box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; margin: 0.5rem 0px; position: relative; width: inherit;"></p><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V put(K key, V value)</span><span style="box-sizing: border-box;">: 把指定的键与指定的值添加到Map集合中。</span></div></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div><p style="box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; margin: 0.5rem 0px; position: relative; width: inherit;"></p><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V remove(Object key)</span><span style="box-sizing: border-box;">: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></div></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div><p style="box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; margin: 0.5rem 0px; position: relative; width: inherit;"></p><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V get(Object key)</span> <span style="box-sizing: border-box;">根据指定的键，在Map集合中获取对应的值。</span></div></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div><p style="box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; margin: 0.5rem 0px; position: relative; width: inherit;"></p><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">boolean containsKey(Object key)</span> <span style="box-sizing: border-box;">判断集合中是否包含指定的键。</span></div></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div><p style="box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; margin: 0.5rem 0px; position: relative; width: inherit;"></p><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public Set&lt;K&gt; keySet()</span><span style="box-sizing: border-box;">: 获取Map集合中所有的键，存储到Set集合中。</span></div></div></li><li><div><p style="box-sizing: border-box; -webkit-margin-before: 1rem; -webkit-margin-after: 1rem; -webkit-margin-start: 0px; -webkit-margin-end: 0px; margin: 0.5rem 0px; position: relative; width: inherit;"></p><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><span style="box-sizing: border-box;">: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></div></div></li></ul><li><div style="box-sizing: border-box;">遍历Map集合</div></li><ol><li><div style="box-sizing: border-box;">方法一</div></li><ul><li><div style="box-sizing: border-box;">使用Map结合中的<span style="color: rgb(255, 0, 0);">keySet（）</span>方法获取Map中所有的键，由于键是唯一的，所以<span style="color: rgb(255, 0, 0);">返回一个Set集合存储所有的键</span></div></li><li><div style="box-sizing: border-box;"><span style="color: rgb(255, 0, 0); font-weight: bold;">遍历键的Set集合，得到每一个键</span></div></li><li><div style="box-sizing: border-box;"><span style="color: rgb(255, 0, 0);">通过Map集合中的方法get(key),根据键，获取键所对应的值</span></div></li></ul></ol></ol><div style="box-sizing: border-box;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class MapDemo01 {</div><div>    public static void main(String[] args) {</div><div>        //创建Map集合对象</div><div>        HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();</div><div>        //添加元素到集合</div><div>        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);</div><div>        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);</div><div>        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);</div><div><br/></div><div>        //获取所有的键  获取键集</div><div>        Set&lt;String&gt; keys = map.keySet();</div><div>        // 遍历键集 得到 每一个键</div><div>        for (String key : keys) {</div><div>              //key  就是键</div><div>            //获取对应值</div><div>            String value = map.get(key);</div><div>            System.out.println(key+&quot;的CP是：&quot;+value);</div><div>        }  </div><div>    }</div><div>}</div></div><div style="box-sizing: border-box;"><span style="font-size: 11pt;">               2. 方法二：Entry键值对对象</span></div><ol><ol><ol><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px;">Entry&lt;K,V&gt;：<span style="font-size: 14.6667px; color: rgb(255, 0, 0);">在Map接口中有一个内部接口Entry</span></span></div></li><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px;">作用：当Map集合一创建，那么久会在</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">Map集合中创建多个Entry对象</span><span style="font-size: 14.6667px;">，用来</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">记录键与值（键值对对象，键与值得映射关系）</span></div></li><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">集合中有多少键值对，就有多少个Entry对象</span></div></li><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px;">使用步骤：</span></div></li><ol><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px;">使用Map集合中的</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">方法entrySet()</span><span style="font-size: 14.6667px;">,把Map集合中多个Entry对象取出来，存储到一个Set集合中</span></div></li><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px;">遍历Set集合，<span style="font-size: 14.6667px; color: rgb(255, 0, 0);">获取每一个Entry对象</span></span></div></li><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px;">使用Entry对象中的 方法<span style="font-size: 14.6667px; color: rgb(255, 0, 0);">getKey()和getValue()获取键与值</span></span></div></li></ol><li><div style="box-sizing: border-box;"><span style="font-size: 14.6667px;">Entry对象方法：</span></div></li><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public K getKey()</span><span style="box-sizing: border-box;">：获取Entry对象中的键。</span></div></li></ul></ol></ol><ul><ul><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V getValue()</span><span style="box-sizing: border-box;">：获取Entry对象中的值。</span></div></li></ul></ul></ul></ol><ul><ul><ul><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; color: rgb(255, 0, 0); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal;">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal;">: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></div></li></ul></ul></ul></ul><div>        6. HashMap存储自定义类型的键值</div><ol><ol><li><div>HashMap存储自定义类型键值，作为key的元素，<span style="color: rgb(255, 0, 0);">必须重写hashCode方法和equals方法</span>，以保证key唯一</div></li><li><div>LinkedHashMap类（java.util.LinkedHashMap&lt;K,V&gt; extends HashMap）</div></li><ol><li><div>Map接口的哈希表和链表列表实现，具有可预知的迭代顺序</div></li><li><div>底层原理：哈希表 + 链表（记录元素顺序）</div></li></ol></ol></ol><div>        7. HashTable集合</div><ol><ol><li><div>底层是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢</div></li><li><div>HashMap是线程不安全，不同步的，速度快</div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">不能存储null值，null键</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">HashMap可以存储null键null值，null作为键只能出现一次</span></div></li><li><div><span style="color: rgb(166, 0, 196);">JDK1.2之后被取代</span></div></li><li><div>Properties子类是一个唯一和IO流相结合的集合</div></li></ol></ol><div><span style="font-size: 12pt; font-weight: bold;">二十、JDK9对集合添加的优化</span></div><ol><li><div>List接口，Set接口，Map接口：里边增加了 一个静态的方法of，可以给集合一次性添加多个元素</div></li><li><div>注意：</div></li><ol><li><div>当集合中存储的元素的个数已经确定了。不在改变时使用</div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">of方法只使用与List接口，Set接口，Map接口，不适用于接口的实现类</span></div></li><li><div><span style="color: rgb(255, 0, 0);">of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常</span></div></li><li><div><span style="color: rgb(255, 0, 0);">Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常</span></div></li></ol><li><div>Debug追踪：</div></li><ol><li><div>添加断点在方法的第一行</div></li><li><div>调试快捷键</div></li><ul><li><div>f8：逐行执行程序</div></li><li><div>f7：进入到方法中</div></li><li><div>shift + f8：跳出方法</div></li><li><div>f9：跳到下一个断点</div></li><li><div>ctrl + f2：退出debug模式，停止程序</div></li><li><div>console：切换到控制台</div></li></ul></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">一、File类（</span><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">java.io.File</span><span style="font-size: 14pt; font-weight: bold;">）</span></div><ol><li><div><span style="font-size: 12pt; font-weight: bold;">概述：</span></div></li><ul><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">java.io.File</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">创建一个文件/文件夹</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">删除文件/文件夹</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">获取文件/文件夹</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">判断文件/文件夹是否存在</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">对文件夹进行遍历</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">获取文件的大小</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;; font-weight: bold;">File类是一个与系统无关的类，任何的操作系统都可以使用这个类中的方法</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">file:文件</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">directory:文件夹/目录</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">path:路径</span></div></li></ul><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">静态方法：</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">static String</span> <span style="font-size: 11pt; color: rgb(235, 0, 115); font-family: &quot;Open Sans&quot;;">pathSeparator</span><span style="font-size: 11pt; color: rgb(235, 0, 115); font-family: &quot;Open Sans&quot;;">:</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">与系统有关的路径分隔符，为了方便，它被表示为一个字符串</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">static char pathSeparatorChar:与系统路径有关的分隔符</span></div></li><li><div><span style="font-size: 11pt;">static String</span> <span style="font-size: 11pt; color: rgb(166, 0, 196);">separator</span><span style="font-size: 11pt;">:系统有关的默认名称分隔符，为了方便，它被表示为一个字符串。</span></div></li><li><div><span style="font-size: 11pt;">static char separatorChar:与系统有关的默认名称分隔符</span></div></li></ol><li><div><span style="font-size: 11pt; font-weight: bold;">构造方法</span></div></li><ol><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public File(String pathname)</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：通过将给定的</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">路径名字符串</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">转换为抽象路径名来创建新的 File实例。</span></div></li><ul><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">注意：</span></div></li><ul><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">String pathname字符串的路径名称，</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">路径可以是以文件结尾，也可以是以文件夹结尾</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">路径可以是相对路径，也可以是绝对路径，</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">  路径可以是存在，也可以是不存在，创建File对象，只是把字符串路径封装为File对象，不考虑路径的真假情况</span></div></li></ul></ul><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public File(String parent, String child)</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：从</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">父路径名字符串和子路径名字符串</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">创建新的 File实例。</span></div></li><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public File(File parent, String child)</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：从</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">父抽象路径名和子路径名字符串</span><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">创建新的 File实例。</span></div></li></ol><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">常用方法</span></div></li><ol><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public String getAbsolutePath()</span> <span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: pre-wrap; widows: 2; word-spacing: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：返回此File的</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">绝对路径</span><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; -webkit-text-stroke-width: 0px; white-space: pre-wrap; widows: 2; word-spacing: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">名字符串。</span></div></li><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public String getPath()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：将此File转换为路径名字符串。</span></div></li><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public String getName()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：返回由此File表示的文件或目录的名称</span></div></li><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public long length()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：返回由此File表示的文件的长度（文件的大小，）。</span></div></li><ul><li><div><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">以</span><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">字节为单位</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">文件夹是没有大小给您的，不能获取文件的大小</span></div></li><li><div>如果此路径名<span style="color: rgb(255, 0, 0);">表示一个目录</span>，则返回值是不确定的。</div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">如果构造方法中给出的路径不存在，那么length方法返回0</span></div></li></ul></ol><li><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">判断功能方法</span></div></li><ol><li><div><span style="box-sizing: border-box; font-size: 0.9em; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public boolean exists()</span> <span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：此File表示的文件或目录是否实际存在。</span></div></li><li><div><span style="box-sizing: border-box; font-size: 0.9em; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public boolean isDirectory()</span> <span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：此File表示的是否为目录。</span></div></li><li><div><span style="box-sizing: border-box; font-size: 0.9em; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public boolean isFile()</span> <span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：此File表示的是否为文件。</span></div></li></ol><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">创建和删除功能方法</span></div></li><ol><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public boolean createNewFile()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</span></div></li><ul><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">注意：该方法声明抛出了IOException异常。</span></div></li></ul><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public boolean delete()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：删除由此File表示的文件或目录（直接从硬盘删除）。</span></div></li><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public boolean mkdir()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：创建由此File表示的目录（创建单级文件夹）。</span></div></li><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public boolean mkdirs()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：创建由此File表示的目录，包括任何必需但</span><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">不存在的父目录（可以是单级也可以是多级）</span></div></li><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">注意：</span></div></li><ul><li><div><span style="font-size: 16px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;;">文件夹不存在，创建文件夹，返回true</span></div></li><li><div><span style="font-size: 16px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;;">构造方法中给出 的路径不存在返回false</span></div></li><li><div><span style="font-size: 16px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;;">文件夹存在，不会创建，返回false</span></div></li></ul></ol><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">目录的遍历</span></div></li><ol><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public String[] list()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：返回一个String数组，表示该File目录中的所有子文件或目录</span></div></li><li><div><span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; font-size: 11pt; color: rgb(51, 51, 51); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">public File[] listFiles()</span> <span style="box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：返回一个File数组，表示该File目录中的所有的子文件或目录。</span></div></li><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">注意：</span></div></li><ul><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">遍历的是构造方法中给出的目录</span></div></li><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">如果路径不存在，就会跑出空指针异常</span></div></li><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">如果构造方法中给出的路径不是一个目录，也会跑出空指针异常</span></div></li><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">隐藏的文件也能获取到</span></div></li></ul></ol><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">在File类中有两个和ListFiles重载的方法，方法参数传递就是过滤器</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">File[] listFiles(FileFilter  filter)</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">java.io.FileFilter接口：用于抽象路径名（File对象）的过滤器</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">作用：用来过滤文件的方法</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">boolean accept(File  pathname)测试指定抽象路径名是否应该包含在某个路径名列表中</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">参数：</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">File  pathname使用ListFiles方法遍历目录，得到每一个文件对象</span></div></li></ol><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">File[] listFiles(FilenameFilter filter)</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">java.io.FilenameFilter接口：实现此接口的类实例可用于过滤器文件名</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">作用：用于过滤文件名称</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">抽象方法：boolean accept(File dir, String name)测试指定文件是否应该包含在某一文件列表中</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">参数：</span></div></li><ol><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">File dir:被遍历的目录</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">String name:使用ListFiles方法遍历目录，获取每一个文件/文件夹的名称</span></div></li></ol></ol></ol><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">绝对路径</span></div></li><ul><li><div><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">绝对路径</span><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：从盘符开始的路径，这是一个完整的路径。</span></div></li></ul><li><div><span style="font-size: 16px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;; font-weight: bold;">相对路径</span></div></li><ul><li><div><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">相对路径</span><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">：</span><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">相对于项目</span><span style="font-size: 11pt; box-sizing: border-box; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">目录的路径，这是一个便捷的路径，开发中经常使用。</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">注意：</span></div></li><ul><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">路径是</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;;">不区分大小写</span><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">的</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">路径中的的文件名称分隔符windows使用反斜杠，反斜杠是转义字符，两个反斜杠代表一个反斜杠</span></div></li></ul></ul></ol><div><span style="font-size: 14pt; font-weight: bold;">二、递归</span></div><ol><li><div><span style="font-size: 11pt;">概念：</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">指在当前方法内调用自己的这种现象</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">分类：</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">直接递归：</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">直接递归称为方法自身调用自己。</span></div></li><li><div><span style="font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">间接递归：</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 11pt; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。</span></div></li></ol><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">注意事项：</span></div></li><ol><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">递归一定要有条件限制，保证递归能够停止下来，否则会发生栈内存溢出</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">在递归中虽然有限定条件，但是递归次数不能太多，否则也会发生栈内存溢出</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">构造方法禁止递归</span></div></li></ol><li><div><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">递归的使用前提：</span><span style="font-size: 14.6667px; color: rgb(51, 51, 51); font-family: &quot;Open Sans&quot;;">调用方法的时候，方法的主体不变，每次调用方法的参数不同，可以使用递归</span></div></li><li><div>内存溢出原理：<img src="Java API_files/01_递归导致栈内存溢出的原理.bmp" type="image/bmp" data-filename="01_递归导致栈内存溢出的原理.bmp"/></div></li><li><div>递归求和原理：<img src="Java API_files/day08_01_递归累和.jpg" type="image/jpeg" data-filename="day08_01_递归累和.jpg"/></div></li><li><div>递归遍历目录原理：<img src="Java API_files/03_递归遍历多级目录.bmp" type="image/bmp" data-filename="03_递归遍历多级目录.bmp"/></div></li><li><div>过滤器原理<img src="http://loadhtml/4acf87f40cae213d08f8f5bb93d3eba0"></img></div></li></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div><div><br/></div></span>
</div></body></html> 