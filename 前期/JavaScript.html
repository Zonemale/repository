<html>
<head>
  <title>JavaScript</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1892"/>
<h1>JavaScript</h1>

<div>
<span><div><span style="font-size: 11pt;">一、</span></div><div><span style="font-size: 11pt;">1.快捷键Ctrl+Alt+L(格式化代码)-----webstorm中</span></div><div><span style="font-size: 11pt;">2.Number.MAX_VALUE;数字最大值</span></div><div><span style="font-size: 11pt;">3.Number.MIN-VALUE;数字最小值</span></div><div><span style="font-size: 11pt;">4.</span></div><div><span style="font-size: 11pt;">    1)不要用小数去验证小数，</span></div><div><span style="font-size: 11pt;">    2)不要用NaN验证是不是NaN,验证这个结果是不是NaN,应该使用isNaN()</span></div><div><span style="font-size: 11pt;">5.Infinity:无穷大</span></div><div><span style="font-size: 11pt;">6.-Infinity:无穷小</span></div><div><span style="font-size: 11pt;">7.八进制：以0开头。十六进制：以0x开头</span></div><div><span style="font-size: 11pt;">8.求字符串的长度str.length;</span></div><div><span style="font-size: 11pt;">9.转整数</span></div><div><span style="font-size: 11pt;">    1）parseInt();转整数，舍去小数点后的内容</span></div><div><span style="font-size: 11pt;">    2）parseFloat();转小数，</span></div><div><span style="font-size: 11pt;">    3）Number();转数字</span></div><div><span style="font-size: 11pt;">    总结：想要转整数用parseInt(),想要转小数用parseFloat()。想要转数字用Number()----(Number()较为严格)</span></div><div><span style="font-size: 11pt;">10.其他类型转字符串类型</span></div><div><span style="font-size: 11pt;">    1）.toString()</span></div><div><span style="font-size: 11pt;">    2)String()</span></div><div><span style="font-size: 11pt;">    注意：如果变量有意义调用.toString()使用转换</span></div><div><span style="font-size: 11pt;">        如果变量没有意义使用String()转换</span></div><div><span style="font-size: 11pt;">11.其他类型转布尔类型</span></div><div><span style="font-size: 11pt;">    1）Boolean(值);</span></div><div><span style="font-size: 11pt;">二、</span><br/></div><div><span style="font-size: 11pt;">1.switch中default也可以省略</span></div><div><span style="font-size: 11pt;">2.switch-case中比较的是严格模式（三等号）</span></div><div><span style="font-size: 11pt;">3.break也是可以省略的，但是只能有一个输入语句</span></div><div><span style="font-size: 11pt;">三、</span></div><div><span style="font-size: 11pt;">1.break关键字：如果在循环中使用，遇到break，则立刻跳出当前所在的循环</span></div><div><span style="font-size: 11pt;">2.continue关键字：在循环中如果遇到continue关键字，直接开始下一次循环。</span></div><div><span style="font-size: 11pt;">四、数组</span></div><div><span style="font-size: 11pt;">1.定义：一组数据，有序的数据</span></div><div><span style="font-size: 11pt;">2.作用：一次性可以存储多个数据</span></div><div><span style="font-size: 11pt;">3.声明方式：</span></div><div><span style="font-size: 11pt;">    1）通过构造函数创建数组</span></div><div><span style="font-size: 11pt;">      语法：var 数组名 = new Array(数组长度);</span></div><div><span style="font-size: 11pt;">      如果数组中没有数据，但是有长度，数组中的每个值就是undefined</span></div><div><span style="font-size: 11pt;">    2)通过字面量的方式创建数组</span></div><div><span style="font-size: 11pt;">      语法：var 数组名 = [];//空数组  </span></div><div><span style="font-size: 11pt;">    注意：数组输出时的逗号是浏览器自己添加的</span></div><div><span style="font-size: 11pt;">五、函数</span></div><div><span style="font-size: 11pt;">1.形参的赋值是将实参的值复制一份赋给给形参，是两个存储空间</span></div><div><span style="font-size: 11pt;">2.arguments对象伪数组</span></div><div><span style="font-size: 11pt;">3.函数的其他定义方式</span></div><div><span style="font-size: 11pt;">    1）命名函数：函数如果有名字，就是命名函数</span></div><div><span style="font-size: 11pt;">    2）匿名函数：函数如果没有名字，就是匿名函数</span></div><div><span style="font-size: 11pt;">    3)函数表达式赋值结束后，后面要加分号</span></div><div><span style="font-size: 11pt;">    4）函数的自调用，没有名字，调用---声明的同时，直接调用</span></div><div><span style="font-size: 11pt;">    5）函数是有数据类型的，数据类型是function类型的</span></div><div><span style="font-size: 11pt;">    6）只要看到一个函数作为参数使用了，那就是回调函数</span></div><div><span style="font-size: 11pt;">    7)函数是可以作为返回值使用的</span></div><div><span style="font-size: 11pt;">4.作用域</span></div><div><span style="font-size: 11pt;">    1）隐式全局变量：声明的变量没有var，就叫隐式全局变量</span></div><div><span style="font-size: 11pt;">    2）全局变量是不能被删除的，隐式全局变量是可以被删除的</span></div><div><span style="font-size: 11pt;">    3）预解析：变量声明提前，函数声明总体提前</span></div><div><span style="font-size: 11pt;">六、对象</span></div><div><span style="font-size: 11pt;">1.编程思想：</span></div><div><span style="font-size: 11pt;">2.面向对象特性：封装，继承，多态</span></div><div><span style="font-size: 11pt;">3.js不是面向对象的语言，但是可以模拟面向对象的思想。js是一门基于对象的语言</span></div><div><span style="font-size: 11pt;">4.创建对象</span></div><div><span style="font-size: 11pt;">    1）调用系统的构造函数创建对象</span></div><div><span style="font-size: 11pt;">        var 变量名 = new Object();---------&gt;(实例化一个对象)</span></div><div><span style="font-size: 11pt;">        添加属性：obj.name=&quot;姓名&quot;;</span></div><div><span style="font-size: 11pt;">        添加方法：obj.eat=function(){};</span></div><div><span style="font-size: 11pt;">    2）自定义构造函数创建对象</span></div><div><span style="font-size: 11pt;">        普通函数和构造函数的区别就是函数名首字母是否大写</span></div><div><span style="font-size: 11pt;">        var obj = new Person(参数1，参数2);</span></div><div><span style="font-size: 11pt;">        步骤：1.在内存中开辟（申请一个空闲的空间）空间，存储创建的新的对象</span></div><div><span style="font-size: 11pt;">              2.把this设置为当前的对象</span></div><div><span style="font-size: 11pt;">              3.设置对象的属性和方法的值</span></div><div><span style="font-size: 11pt;">              4.把this这个对象返回</span></div><div><span style="font-size: 11pt;">    3）字面量的方式创建对象</span></div><div><span style="font-size: 11pt;">        var obj = {};</span></div><div><span style="font-size: 11pt;">        缺陷：一次性的对象</span></div><div><span style="font-size: 11pt;">    4）点语法：对象.名字=值；对象.名字=函数；</span></div><div><span style="font-size: 11pt;">        设置属性的另一种方法：obj[&quot;name&quot;]=&quot;属性值&quot;;-----&gt;引号内的内容可以是变量</span></div><div><span style="font-size: 11pt;">5.工厂模式创建对象</span></div><div><span style="font-size: 11pt;">    1）如何获取变量（对象）是不是属于什么类型的</span></div><div><span style="font-size: 11pt;">    语法：</span></div><div><span style="font-size: 11pt;">    变量 instanceof 类型的名字--------------&gt;布尔类型</span></div><div><span style="font-size: 11pt;">    2)一次性创建多个对象，把创建对象的代码封装在一个函数中</span></div><div><span style="font-size: 11pt;">6.JSON格式</span></div><div><span style="font-size: 11pt;">    1)构造函数创建对象是一组无序的键值对</span></div><div><span style="font-size: 11pt;">    2)JSON格式的数据一般都是成对的，是键值对，</span></div><div><span style="font-size: 11pt;">    3）JSON也是一个对象，数据都是成对的，一般JSON格式的数据无论是键还是值都是用双引号括起来</span></div><div><span style="font-size: 11pt;">    示例：</span></div><div><span style="font-size: 11pt;">        var json={</span></div><div><span style="font-size: 11pt;">            &quot;name&quot;:&quot;小明&quot;,</span></div><div><span style="font-size: 11pt;">            &quot;age&quot;:&quot;10&quot;,</span></div><div><span style="font-size: 11pt;">            &quot;sex&quot;:&quot;男&quot;</span></div><div><span style="font-size: 11pt;">        };</span></div><div><span style="font-size: 11pt;">    4)JSON对象数据的遍历(for-in循环)</span></div><div><span style="font-size: 11pt;">    示例：</span></div><div><span style="font-size: 11pt;">        for(var key in json){</span></div><div><span style="font-size: 11pt;">            console.log(key);//json对象中的属性的名字</span></div><div><span style="font-size: 11pt;">            console.log(json[key]);//</span></div><div><span style="font-size: 11pt;">        }</span></div><div><span style="font-size: 11pt;">7.js中的三种内置对象</span></div><div><span style="font-size: 11pt;">    1）内置对象</span></div><div><span style="font-size: 11pt;">        Math</span></div><div><span style="font-size: 11pt;">            Math属性：</span></div><div><span style="font-size: 11pt;">                Math.E</span></div><div><span style="font-size: 11pt;">                Math.PI</span></div><div><span style="font-size: 11pt;">            Math方法：</span></div><div><span style="font-size: 11pt;">                Math.ceil()向上取整</span></div><div><span style="font-size: 11pt;">                Math.floor()向下取整</span></div><div><span style="font-size: 11pt;">                Math.fround()取小数</span></div><div><span style="font-size: 11pt;">                Math.max()取一组数字的最大值</span></div><div><span style="font-size: 11pt;">                Math.min()</span></div><div><span style="font-size: 11pt;">                Math.pow(23,2)计算23的2次方</span></div><div><span style="font-size: 11pt;">                Math.sqrt()开平方</span></div><div><span style="font-size: 11pt;">                Math.random()返回一个随机数</span></div><div><span style="font-size: 11pt;">        Date</span></div><div><span style="font-size: 11pt;">            Date:(1970.1.1)</span></div><div><span style="font-size: 11pt;">            var date = new Date();</span></div><div><span style="font-size: 11pt;">            var dt = new Date(&quot;2018-2-20&quot;);</span></div><div><span style="font-size: 11pt;">            console.log(date);</span></div><div><span style="font-size: 11pt;">            console.log(date.getYear());</span></div><div><span style="font-size: 11pt;">            console.log(date.getFullYear());</span></div><div><span style="font-size: 11pt;">            console.log(date.getYear(2018));</span></div><div><span style="font-size: 11pt;">            console.log(date.getMonth());</span></div><div><span style="font-size: 11pt;">            console.log(date.getDate());</span></div><div><span style="font-size: 11pt;">            console.log(date.getHours());</span></div><div><span style="font-size: 11pt;">            console.log(date.getMinutes());</span></div><div><span style="font-size: 11pt;">            console.log(date.getSeconds());</span></div><div><span style="font-size: 11pt;">            console.log(date.getDay());</span></div><div><span style="font-size: 11pt;">            console.log(date.toString());</span></div><div><span style="font-size: 11pt;">            console.log(date.toDateString());</span></div><div><span style="font-size: 11pt;">            console.log(date.toLocaleDateString());</span></div><div><span style="font-size: 11pt;">            console.log(date.toTimeString());</span></div><div><span style="font-size: 11pt;">            console.log(date.toLocaleTimeString());</span></div><div><span style="font-size: 11pt;">            console.log(date.valueOf());</span></div><div><span style="font-size: 11pt;">        String</span></div><div><span style="font-size: 11pt;">            可以看成是一个字符数组</span></div><div><span style="font-size: 11pt;">            转义字符</span></div><div><span style="font-size: 11pt;">            字符串特性：不可变性，字符串的值是不能改变的</span></div><div><span style="font-size: 11pt;">            *字符串的重新赋值是以对象的方式来看待，值之所以改变是因为字符串的引用改变了。</span></div><div><span style="font-size: 11pt;">            String属性</span></div><div><span style="font-size: 11pt;">            string.length</span></div><div><span style="font-size: 11pt;">            String方法</span></div><div><span style="font-size: 11pt;">            string.charAt();</span></div><div><span style="font-size: 11pt;">            string.fromCharCode()</span></div><div><span style="font-size: 11pt;">            str1.concat(str2,str3,str4,str5);</span></div><div><span style="font-size: 11pt;">            str.indexOf(&quot;要找的字符串&quot;);</span></div><div><span style="font-size: 11pt;">            str.lastIndexOf();</span></div><div><span style="font-size: 11pt;">            str.replace(&quot;a&quot;,&quot;b&quot;);</span></div><div><span style="font-size: 11pt;">            str.slice(5,10);//从索引5的位置开始提取，到索引为10的前一个结束，没有10，并返回提取后的字符串</span></div><div><span style="font-size: 11pt;">            str.split(&quot;|&quot;);将字符串以&quot;|&quot;分割并返回一个数组</span></div><div><span style="font-size: 11pt;">            str.substr(开始位置，长度);截取字符串中的某一段</span></div><div><span style="font-size: 11pt;">            str.substring(开始位置，结束位置);</span></div><div><span style="font-size: 11pt;">            str.toLowerCase();</span></div><div><span style="font-size: 11pt;">            str.toUpperCase();</span></div><div><span style="font-size: 11pt;">        Array</span></div><div><span style="font-size: 11pt;">            Array.isArray()</span></div><div><span style="font-size: 11pt;">            arr.concat();</span></div><div><span style="font-size: 11pt;">            arr.every(函数)-----&gt;返回值是布尔类型，函数作为参数使用，函数中有三个参数，第一个是元素的值，第二个是索引值，第三个是原来的数组</span></div><div><span style="font-size: 11pt;">            Array.filter()方法创建一个新数组，其包含通过所提供函数实现的测试的所有元素</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">            push():把值从数据追加在数组尾部</span></div><div><span style="font-size: 11pt;">            pop():删除数组中尾部的元素</span></div><div><span style="font-size: 11pt;">            unshift():从数组头部追加元素</span></div><div><span style="font-size: 11pt;">            shift():删除第一个元素</span></div><div><span style="font-size: 11pt;">            注：返回一个数组</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">            .forEach(函数)遍历数组</span></div><div><span style="font-size: 11pt;">            .join(&quot;字符串&quot;);</span></div><div><span style="font-size: 11pt;">            .map(函数)</span></div><div><span style="font-size: 11pt;">            .reverse()反转数组</span></div><div><span style="font-size: 11pt;">            .sort()数组排序</span></div><div><span style="font-size: 11pt;">                arr.sort(function (a,b)){</span></div><div><span style="font-size: 11pt;">                    if(a&gt;b){</span></div><div><span style="font-size: 11pt;">                        return 1;</span></div><div><span style="font-size: 11pt;">                    }else if(a=b){</span></div><div><span style="font-size: 11pt;">                        return 0;</span></div><div><span style="font-size: 11pt;">                    }else{</span></div><div><span style="font-size: 11pt;">                        return -1;</span></div><div><span style="font-size: 11pt;">                    }</span></div><div><span style="font-size: 11pt;">                }</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">            基本包装类型：本身是基本类型，但是在执行代码过程中，如果这种类型的变量调用了属性或者是方法，那么这种类型就不再是基本类型，而是基本包装类型，这个变量也不是普通变量了，而是基本包装类型对象</span></div><div><span style="font-size: 11pt;">            var box = 'Mr. Lee';//定义一个字符串</span></div><div><span style="font-size: 11pt;">            var box2 = box.substring(2);//截掉字符串前两位</span></div><div><span style="font-size: 11pt;">            alert(box2);//输出新字符串</span></div><div><span style="font-size: 11pt;">            变量 box 是一个字符串类型，而 box.substring(2)又说明它是一个对象(PS：只有对象才会调用方法)，最后把处理结果赋值给 box2。'Mr. Lee'是一个字符串类型的值，按道理它不应该是对象，不应该会有自己的方法</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">            规律：如果是一个对象&amp;&amp;true，结果是true</span></div><div><span style="font-size: 11pt;">                  如果是一个true&amp;&amp;对象，结果是对象</span></div><div><span style="font-size: 11pt;">        Object</span></div><div><span style="font-size: 11pt;">    2）自定义对象-----自己定义的构造函数创建的对象</span></div><div><span style="font-size: 11pt;">    3）浏览器对象-----BOM</span></div><div><span style="font-size: 11pt;">    注：实例对象：通过构造函数创建出来，实例化的对象</span></div><div><span style="font-size: 11pt;">        静态对象：不需要创建，直接就是一个对象，方法（静态方法）直接通过这个对象名字调用</span></div><div><span style="font-size: 11pt;">        实例方法必须通过实例对象调用</span></div><div><span style="font-size: 11pt;">        静态方法必须通过大写的对象调用</span></div><div><span style="font-size: 11pt;">七、类型</span></div><div><span style="font-size: 11pt;">1.原始数据类型：number,string,boolean,undefined,null,object</span></div><div><span style="font-size: 11pt;">    1).基本类型（简单类型），值类型：number,string,boolean</span></div><div><span style="font-size: 11pt;">    2).复杂类型（引用类型）：object</span></div><div><span style="font-size: 11pt;">    3).空类型：undefined,null</span></div><div><span style="font-size: 11pt;">注意：值类型一般在栈中存储，引用类型对象在堆上存储，地址在栈上存储。</span></div><div><span style="font-size: 11pt;">    值类型之间传递的是值，引用类型之间传递的是地址</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">----------------------------------------------------------------------------------------------------------------------</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">一、对象。</span></div><div><span style="font-size: 11pt;">    1.创建对象的三种方式：</span></div><div><span style="font-size: 11pt;">        1）字面量的方式</span></div><div><span style="font-size: 11pt;">        2）调用系统的构造函数</span></div><div><span style="font-size: 11pt;">        3）自定义构造函数方式</span></div><div><span style="font-size: 11pt;">    2.工厂模式和自定义构造函数创建对象的不同</span></div><div><span style="font-size: 11pt;">        1）工厂模式</span></div><div><span style="font-size: 11pt;">            函数名是小写</span></div><div><span style="font-size: 11pt;">            有new</span></div><div><span style="font-size: 11pt;">            有返回值</span></div><div><span style="font-size: 11pt;">            new之后的对象是当前的对象</span></div><div><span style="font-size: 11pt;">            直接调用函数创建对象</span></div><div><span style="font-size: 11pt;">        2）自定义构造函数</span></div><div><span style="font-size: 11pt;">            函数名是大写</span></div><div><span style="font-size: 11pt;">            没有new</span></div><div><span style="font-size: 11pt;">            没有返回值</span></div><div><span style="font-size: 11pt;">            this是当前的对象</span></div><div><span style="font-size: 11pt;">            通过new方式来创建对象</span></div><div><span style="font-size: 11pt;">    3.总结：</span></div><div><span style="font-size: 11pt;">        实例对象和构造函数之间的关系</span></div><div><span style="font-size: 11pt;">        1）实例对象是通过构造函数来创建的---创建的过程叫实例化</span></div><div><span style="font-size: 11pt;">        2）如何判断对象是不是这个数据类型</span></div><div><span style="font-size: 11pt;">            通过构造器的方式实例对象，构造器==构造函数名字</span></div><div><span style="font-size: 11pt;">            对象instanceof构造函数名字</span></div><div><span style="font-size: 11pt;">            尽可能的使用第二种方式来识别。</span></div><div><span style="font-size: 11pt;">        示例：判断这个对象是不是这种数据类型的方式</span></div><div><span style="font-size: 11pt;">        1.    per.constructor==Person</span></div><div><span style="font-size: 11pt;">            per.__proto__.constructor==Person;</span></div><div><span style="font-size: 11pt;">            per.__proto__.constructor==Person.prototype.constructor</span></div><div><span style="font-size: 11pt;">        2.    per instanceof Person</span></div><div><span style="font-size: 11pt;">二、原型------&gt;__proto__或prototype</span></div><div><span style="font-size: 11pt;">    1.通过原型来添加方法，解决数据共享，节省内存空间</span></div><div><span style="font-size: 11pt;">    2.实例对象中有个属性，__proto__,也是对象，叫原型，不是标准属性，浏览器使用</span></div><div><span style="font-size: 11pt;">    3.构造函数中有一个属性，prototype,也是对象，叫原型，是标准属性，程序员使用</span></div><div><span style="font-size: 11pt;">作用：共享数据，节省内存空间。</span></div><div><span style="font-size: 11pt;">  **4.构造函数，实例对象，原型之间的关系</span></div><div><span style="font-size: 11pt;">        1）构造函数可以实例化对象</span></div><div><span style="font-size: 11pt;">        2）构造函数中有一个属性叫prototype,是构造函数的原型对象</span></div><div><span style="font-size: 11pt;">        3）构造函数的原型对象(prototype)中有一个constructor构造器，这个构造器指向的就是自己所在的原型对象所在的构造函数</span></div><div><span style="font-size: 11pt;">        4）实例对象的原型对象(__proto__)指向的是该构造函数的原型对象</span></div><div><span style="font-size: 11pt;">        5）构造函数的原型对象(prototype)中的方式是可以被实例对象直接访问的</span></div><div><span style="font-size: 11pt;">    5.定义原型的语法</span></div><div><span style="font-size: 11pt;">        1）</span></div><div><span style="font-size: 11pt;">        Student.prototype.height=&quot;180&quot;;</span></div><div><span style="font-size: 11pt;">        Student.prototype.weight=&quot;150&quot;;</span></div><div><span style="font-size: 11pt;">        Student.prototype.eat=function(){</span></div><div><span style="font-size: 11pt;">            console.log(&quot;Eat more fruit.&quot;);</span></div><div><span style="font-size: 11pt;">        };</span></div><div><span style="font-size: 11pt;">        Student.prototype.study=function(){</span></div><div><span style="font-size: 11pt;">            console.log(&quot;Study hard and you will make progress every day.&quot;);</span></div><div><span style="font-size: 11pt;">        };</span></div><div><span style="font-size: 11pt;">        2）需要手动修改构造器的指向(constructor:Student)</span></div><div><span style="font-size: 11pt;">        Student.prototype = {</span></div><div><span style="font-size: 11pt;">            constructor:Student,</span></div><div><span style="font-size: 11pt;">            height:&quot;180&quot;,</span></div><div><span style="font-size: 11pt;">            weight:&quot;200&quot;,</span></div><div><span style="font-size: 11pt;">            eat:function (){</span></div><div><span style="font-size: 11pt;">                console.log(&quot;Eat more fruit.&quot;);</span></div><div><span style="font-size: 11pt;">            },</span></div><div><span style="font-size: 11pt;">            study:function(){</span></div><div><span style="font-size: 11pt;">                console.log(&quot;Study hard and you will make progress every day.&quot;);</span></div><div><span style="font-size: 11pt;">            }</span></div><div><span style="font-size: 11pt;">        };</span></div><div><span style="font-size: 11pt;">    6.原型中的方法是可以相互访问的，用this.方法名调用</span></div><div><span style="font-size: 11pt;">    7.原型链：实例对象会先从实例中找属性或方法，如果没有再从原型中找属性或方法</span></div><div><span style="font-size: 11pt;">    实例对象使用的属性或方法，先在实例中查找，找到了则直接使用，找不到则去实例对象的__proto__指向的原型对象prototype中找，找不到则报错</span></div><div><span style="font-size: 11pt;">    8.给内置对象的原型添加方法，相当于修改源码</span></div><div><span style="font-size: 11pt;">        内置对象名.prototype.方法名=function(){};</span></div><div><span style="font-size: 11pt;">    9.将局部变量变成全局变量</span></div><div><span style="font-size: 11pt;">    (function(win){</span></div><div><span style="font-size: 11pt;">            var num=10;</span></div><div><span style="font-size: 11pt;">            //js是动态类型的语言，对象本身没有属性，点了就有属性了</span></div><div><span style="font-size: 11pt;">            win.number=num;</span></div><div><span style="font-size: 11pt;">        })(window);</span></div><div><span style="font-size: 11pt;">        /*</span></div><div><span style="font-size: 11pt;">        * window是实参，win是形参，将浏览器的顶级对象作为参数传给立即执行函数，然后把局部变量赋给window对象的一个属性，就把局部变量变成了全局变量</span></div><div><span style="font-size: 11pt;">                * */</span></div><div><span style="font-size: 11pt;">        console.log(number);</span></div><div><span style="font-size: 11pt;">    10.原型链:是一种关系，实例对象和原型对象之间的关系，关系是通过原型(__proto__)来联系的</span></div><div><span style="font-size: 11pt;">        1)构造函数中的this就是实例对象，原型对象中方法中的this就是实例对象</span></div><div><span style="font-size: 11pt;">        2）原型指向可以改变</span></div><div><span style="font-size: 11pt;">        3）实例对象的原型__proto__指向的是该对象所在的构造函数的原型对象</span></div><div><span style="font-size: 11pt;">        4）构造函数的原型对象(prototype)指向如果改变了，实例对象的原型(__proto__)指向也会发生改变</span></div><div><span style="font-size: 11pt;">        示例：</span></div><div><span style="font-size: 11pt;">        function Student(){}</span></div><div><span style="font-size: 11pt;">        Student.prototype.sayHi = function(){</span></div><div><span style="font-size: 11pt;">         console.log(&quot;hei&quot;);</span></div><div><span style="font-size: 11pt;">        };</span></div><div><span style="font-size: 11pt;">        Student.prototype = new Person();</span></div><div><span style="font-size: 11pt;">        var stu = new Student();</span></div><div><span style="font-size: 11pt;">        5）实例对象和原型对象之间的关系是通过__proto__原型来联系起来的，这个关系就是原型链</span></div><div><span style="font-size: 11pt;">        6）prototype这个对象中__proto__指向的应该是Object</span></div><div><span style="font-size: 11pt;">    11.原型指向改变添加原型方法</span></div><div><span style="font-size: 11pt;">        1）在改变原型指向后添加原型方法</span></div><div><span style="font-size: 11pt;">        2)如果原型指向改变了，那么就应该在原型改变指向之后添加原型方法</span></div><div><span style="font-size: 11pt;">    12.实例对象和原型对象属性重名问题</span></div><div><span style="font-size: 11pt;">        1）实例对象会先从实例对象的属性中找，如果没有，则到原型对象中找</span></div><div><span style="font-size: 11pt;">        2）原型对象改变属性值的方法就是直接给原型对象的属性直接赋值</span></div><div><span style="font-size: 11pt;">        3）所有对象的原型链最终指向的都是Object.prototype,Object的原型对象中的__proto__是null</span></div><div><span style="font-size: 11pt;">三、继承</span></div><div><span style="font-size: 11pt;">    1.原型实现继承：继承是一种关系，类与类之间的关系，js中没有类，但是可以通过构造函数模拟类，然后通过原型来实现继承。</span></div><div><span style="font-size: 11pt;">            1)缺陷：因为改变原型指向的同时实现继承，直接初始化了属性，继承过来的属性值都是一样的，</span></div><div><span style="font-size: 11pt;">            2）解决方案：继承的时候，不用改变原型的指向，直接调用父级的构造函数的方式来为属性赋值就可以了----借用构造函数；把要继承的父级的构造函数拿过来，试用一下就可以了</span></div><div><span style="font-size: 11pt;">    2.借用构造函数继承：构造函数名字.call(当前对象---this,属性1,属性2,...);</span></div><div><span style="font-size: 11pt;">            缺陷：但是不能继承方法</span></div><div><span style="font-size: 11pt;">    3.组合继承：原型继承+借用构造函数继承</span></div><div><span style="font-size: 11pt;">    4.拷贝继承：把一个对象的属性和方法直接复制到另一对象中(for in循环)</span></div><div><span style="font-size: 11pt;">注意；以后尽可能用函数表达式而不用函数声明的方式</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">四.多态：一个对象有不同的行为，或者是统一个行为针对不同的对象产生不同的结果，要有多态就要先有继承，js中可以模拟多态，但是不会使用多态</span></div><div><span style="font-size: 11pt;">五.</span></div><div><span style="font-size: 11pt;">1.函数中this的严格模式</span></div><div><span style="font-size: 11pt;">        1)普通函数中的this是：window</span></div><div><span style="font-size: 11pt;">        2)对象.方法中的this是：实例对象</span></div><div><span style="font-size: 11pt;">        3）定时器方法中的this是：window</span></div><div><span style="font-size: 11pt;">        4）构造函数中的this是；实例对象</span></div><div><span style="font-size: 11pt;">        5）原型对象方法中的this是：实例对象</span></div><div><span style="font-size: 11pt;">        严格模式：&quot;use strict&quot;;</span></div><div><span style="font-size: 11pt;">2.</span></div><div><span style="font-size: 11pt;">    1)函数也是对象，对象不一定是函数，</span></div><div><span style="font-size: 11pt;">    2)对象中有__proto__,函数中应该有prototype,如果一个东西里面两个都有，说明是函数也是对象</span></div><div><span style="font-size: 11pt;">    3）所有的函数实际上都是Function的构造函数创建出来的实例对象</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">六.call,apply,bind</span></div><div><span style="font-size: 11pt;">使用方法：</span></div><div><span style="font-size: 11pt;">函数名字.apply(对象,[参数1,参数2...]);</span></div><div><span style="font-size: 11pt;">方法名字.apply(对象,[参数1,参数2,...]);</span></div><div><span style="font-size: 11pt;">函数名字.call(对象,参数1,参数2...);</span></div><div><span style="font-size: 11pt;">方法名字.call(对象,参数1,参数2,...);</span></div><div><span style="font-size: 11pt;">函数名字.bind(对象,参数1,参数,...);------返回值是复制之后的这个函数</span></div><div><span style="font-size: 11pt;">方法名字.bind(对象,参数1,参数2,...);-------返回值是复制之后的这个方法</span></div><div><span style="font-size: 11pt;">    1.apply和call方法中如果没有传入参数，或者是传入的是null，那么调用该方法的函数对象中的this就是默认的window</span></div><div><span style="font-size: 11pt;">    2.apply和call都可以让函数或者方法来调用，传入参数和函数自调用的写法不一样，但是效果是一样的。</span></div><div><span style="font-size: 11pt;">        示例：</span></div><div><span style="font-size: 11pt;">        f1.apply(null,[10,20]);</span></div><div><span style="font-size: 11pt;">        f1.call(null,10,20);</span></div><div><span style="font-size: 11pt;">    3.apply可以改变this的指向</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    4.apply和call方法实际上并不在函数这个实例对象中，而是在Function的prototype中.</span></div><div><span style="font-size: 11pt;">    5.bind方法是复制的意思，参数可以在复制的时候传进去，也可以在复制之后调用的时候传进去</span></div><div><span style="font-size: 11pt;">    6.区别：</span></div><div><span style="font-size: 11pt;">        apply的第二个参数是数组</span></div><div><span style="font-size: 11pt;">        call的第一个对象参数后是多个参数</span></div><div><span style="font-size: 11pt;">        apply和call是调用的时候改变this指向，bind方法，是复制一份的时候，改变了this的指向</span></div><div><span style="font-size: 11pt;">    7.函数中的几个成员</span></div><div><span style="font-size: 11pt;">        1）函数中有一个name属性----&gt;函数的名字</span></div><div><span style="font-size: 11pt;">        2）函数中有一个arguments属性----&gt;实参的个数</span></div><div><span style="font-size: 11pt;">        3）函数中有一个length属性------&gt;函数定义的形参个数</span></div><div><span style="font-size: 11pt;">        4）函数中有一个caller属性-------&gt;调用者(f1函数是在f2中调用的，则调用者就是f2）</span></div><div><span style="font-size: 11pt;">七.函数作为参数使用</span></div><div><span style="font-size: 11pt;">    1.函数作为参数的时候，如果是命名函数，那么直接传入命名函数的名字，没有括号</span></div><div><span style="font-size: 11pt;">    2.作用域链：从里向外，层层的搜索，搜索到了就可以直接使用了</span></div><div><span style="font-size: 11pt;">    3.预解析；就是在浏览器解析代码之前把变量和函数声明提前到该作用域的最上边。</span></div><div><span style="font-size: 11pt;">    4.闭包：</span></div><div><span style="font-size: 11pt;">        1）概念：函数A中，有一个函数B，函数B中可以访问函数A中定义的变量或者是数据，此时形成了闭包。</span></div><div><span style="font-size: 11pt;">        2）模式；函数模式的闭包，对象模式的闭包</span></div><div><span style="font-size: 11pt;">        3）作用：缓存数据，延长作用域</span></div><div><span style="font-size: 11pt;">        4）优点和缺点：缓存数据，内存泄漏</span></div><div><span style="font-size: 11pt;">        5）闭包的应用</span></div><div><span style="font-size: 11pt;">    对象模式的闭包；函数中有一个对象，并且对象中的值和函数中的值可以互相调用</span></div><div><span style="font-size: 11pt;">    5.沙箱：环境，黑盒，在一个虚拟环境中模拟真实世界，做实验</span></div><div><span style="font-size: 11pt;">八.递归函数：在函数中调用函数自己，此时就是递归，递归一定要有结束条件</span></div><div><span style="font-size: 11pt;">九.</span></div><div><span style="font-size: 11pt;">    1.浅拷贝：拷贝就是复制，就相当于把一个对象中的所有内容，复制一份给另一个对象，直接复制，或者说，就是把一个对象的地址给了另一个对象，它们指向相同，两个对象之间有共同的属性或者方法，都可以使用</span></div><div><span style="font-size: 11pt;">    注意：浅拷贝过程中如果是复制对象类型的数据，则复制的是地址，其中一个对象的值改变，另一个也会改变</span></div><div><span style="font-size: 11pt;">    2.深拷贝：把一个对象中所有的属性或者方法一个一个的找到，并在另一对象中开辟相应的空间，一个一个的存储到另一对象中</span></div><div><b><font style="color: rgb(227, 0, 0); font-size: 12pt;">十.正则表达式；</font></b><span style="font-size: 11pt;">也叫规则表达式，按照一定的规则组成的一个表达式，这个表达式的作用主要是匹配字符串的</span></div><div><span style="font-size: 11pt;">    1.正则表达式的组成；是由元字符或者限定字符组成的一个式子。</span></div><div><span style="font-size: 11pt;">    2.元字符：</span></div><div><span style="font-size: 11pt;">        .   表示出了\n以外的任意一个字符</span></div><div><span style="font-size: 11pt;">        []  表示范围</span></div><div><span style="font-size: 11pt;">        [1-7]   表示1到7之间的任意一个字符</span></div><div><span style="font-size: 11pt;">        [a-z]   表示所有小写字母中的任意一个</span></div><div><span style="font-size: 11pt;">        [A-Z]   表示所有大写字母中的任意一个</span></div><div><span style="font-size: 11pt;">        [a-zA-Z]    表示所有字母的任意一个</span></div><div><span style="font-size: 11pt;">        [0-9a-zA-Z] 表示所有数字或者字母中的一个</span></div><div><span style="font-size: 11pt;">        []  另一个含义，把正则表达式中元字符的意义干掉</span></div><div><span style="font-size: 11pt;">        |   或者</span></div><div><span style="font-size: 11pt;">        ()  分组，提升优先级</span></div><div><span style="font-size: 11pt;">        限定符</span></div><div><span style="font-size: 11pt;">        *   表示前面的表达式出现了0次到多次</span></div><div><span style="font-size: 11pt;">        +   表示前面的表达式出现了1次到多次</span></div><div><span style="font-size: 11pt;">        ?   表示前面的表达式出现0次到1次，另一个含义；阻止贪婪模式</span></div><div><span style="font-size: 11pt;">        {}  表示前面的表达式出现了0次到多次</span></div><div><span style="font-size: 11pt;">        {1,}表示前面的表达式出现了1次到多次</span></div><div><span style="font-size: 11pt;">        {0,1}表示前面的表达式出现了0次到1次</span></div><div><span style="font-size: 11pt;">        ^   表示的是开始，或者是取非（取反），^[0-9]以数字开头，[^0-9]取反，非数字。^如果在中括号外面则表示开始，如果在里面则表示取反</span></div><div><span style="font-size: 11pt;">        $   表示以什么结束，^[0-9][a-z]$以任意一个数字开始，任意一个字母结束</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    g   全局模式</span></div><div><span style="font-size: 11pt;">    i   不区分大小写</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">        \d  数字中的任意一个</span></div><div><span style="font-size: 11pt;">        \D  非数字中的一个</span></div><div><span style="font-size: 11pt;">        \s  空白符中的一个</span></div><div><span style="font-size: 11pt;">        \S  非空白符</span></div><div><span style="font-size: 11pt;">        \w  非特殊符号</span></div><div><span style="font-size: 11pt;">        \W  特殊符号</span></div><div><span style="font-size: 11pt;">        \b  单词的边界</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    3.写正则表达式，根据字符串来写正则表达式进行匹配</span></div><div><span style="font-size: 11pt;">        经验；1）找规律，2）不要追求完美</span></div><div><span style="font-size: 11pt;">        示例；身份证([0-9][1-9]{14})([0-9]{2}[0-9xX])?</span></div><div><span style="font-size: 11pt;">            电话号：([0][1][0])[-]([0-9]){8}</span></div><div><span style="font-size: 11pt;">                   [0][0-9]{3}[-][0-9]{8}</span></div><div><span style="font-size: 11pt;">            手机号码；{[1][358][0-9][0-9]{8})|([1][4][37][0-9]{8})|([1][7][01367][0-9]{8})</span></div><div><span style="font-size: 11pt;">            邮箱；[0-9a-zA-Z_.-]+[@][0-9a-zA-Z_.-]+([.][a-zA-Z]+){1,2)</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    4.创建正则表达式对象方法</span></div><div><span style="font-size: 11pt;">        1）通过构造函数创建对象</span></div><div><span style="font-size: 11pt;">        2）字面量的方式创建对象</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><span style="font-size: 11pt;">    5.正则表达式的其他用法</span></div><div><span style="font-size: 11pt;">    1）g表示的是全局模式</span></div><div><span style="font-size: 11pt;">    2）字符串.match(正则表达式)==正则表达式.exec(字符串),将符合正则表达式的内容作为数组返回</span></div><div><span style="font-size: 11pt;">    3）正则表达式.$n.可以获取第n组</span></div><div><span style="font-size: 11pt;">    4）字符串.replace(正则表达式,替换内容)，将字符串中匹配正则表达式的内容替换</span></div><div><span style="font-size: 11pt;">    6.数组和伪数组</span></div><div><span style="font-size: 11pt;">    1）真数组的长度是可变的，可以使用数组中的方法</span></div><div><span style="font-size: 11pt;">    2）伪数组的长度是不可变得，伪数组不可以使用数组中的方法</span></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;"><br/></font></div><div><br/></div></span>
</div></body></html> 