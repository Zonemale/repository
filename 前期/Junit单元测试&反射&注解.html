<html>
<head>
  <title>Junit单元测试&amp;反射&amp;注解</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1703"/>
<h1>Junit单元测试&amp;反射&amp;注解</h1>

<div>
<span><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">一、Junit单元测试</span></font></div><ol><li><div><span style="font-size: 11pt;">测试分类</span></div></li><ol><li><div><span style="font-size: 14.6667px;">黑盒测试：</span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">不需要写代码</span>，给输入值，看程序是否能够输出期望的值</span></div></li><li><div><span style="font-size: 14.6667px;">白盒测试：</span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">需要写代码的</span>。关注程序具体的<span style="font-size: 11pt; color: rgb(255, 0, 0);">执行流程（Junit属于白盒测试）</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;">Junit使用：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">步骤：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">定义一个测试类</span></div></li><ul><li><div><span style="font-size: 11pt;">测试类名：被测试的类名Test        CalculatorTest</span></div></li><li><div><span style="font-size: 11pt;">包名：xxx.xxx.xx.test        cn.itcast.test</span></div></li></ul><li><div><span style="font-size: 14.6667px;">定义测试方法：可以独立运行</span></div></li><ul><li><div><span style="font-size: 11pt;">方法名：test测试的方法名        testAdd()  </span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">返回值：void</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">参数列表：空参</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;">给方法加@Test</span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">导入Junit依赖环境</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;">判定结果</span></div></li><ul><li><div><span style="font-size: 11pt;">红色：失败</span></div></li><li><div><span style="font-size: 11pt;">绿色：成功</span></div></li><li><div><span style="font-size: 11pt;">一般我们会使用断言操作来处理结果</span></div></li><ul><li><div><span style="font-size: 11pt;">Assert.assertEquals(期望的结果,运算的结果);</span></div></li></ul></ul><li><div><span style="font-size: 14.6667px;">补充：</span></div></li><ul><li><div><span style="font-size: 11pt;"> @Before:</span></div></li><ul><li><div><span style="font-size: 11pt;">修饰的方法会在测试方法之前被自动执行</span></div></li></ul><li><div><span style="font-size: 11pt;">@After:</span></div></li><ul><li><div><span style="font-size: 11pt;">修饰的方法会在测试方法执行之后自动被执行</span></div></li></ul></ul></ol></ol><div><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px; font-weight: bold;">二、反射：框架设计的灵魂</span></span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><img src="Junit单元测试&反射&注解_files/ScreenClip.png" type="image/png" data-filename="ScreenClip.png"/></span></span></div><ol><li><div><span style="font-size: 11pt;">框架：</span><span style="font-size: 11pt;">半成品软件。可以在框架的基础上进行软件开发，简化编码</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(227, 0, 0);">反射：</span><span style="font-size: 11pt; color: rgb(227, 0, 0);">将类的各个组成部分封装为其他对象，这就是反射机制</span></div></li><ul><li><div><span style="font-size: 14.6667px;">好处：</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">可以在程序运行过程中，操作这些对象。</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">可以解耦，提高程序的可扩展性。</span></span></div></li></ul></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">获取class对象的方式</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">Class.forName(&quot;全类名&quot;)</span>：将字节码文件加载进内存，返回Class对象</span></div></li><ul><li><div><span style="font-size: 11pt;"> 多用于配置文件，将类名定义在配置文件中。读取文件，加载类</span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">类名.class：通过类名的属性class获取</span></span></div></li><ul><li><div><span style="font-size: 11pt;">多用于参数的传递</span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">对象.getClass()：getClass()方法在Object类中定义着。</span></span></div></li><ul><li><div><span style="font-size: 11pt;">多用于对象的获取字节码的方式</span></div></li></ul><li><div><span style="font-size: 14.6667px;">结论：</span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(79, 0, 154); font-weight: bold;">同一个字节码文件(*.class)在一次程序运行过程中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个。</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;">class对象功能：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">获取功能：</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(65, 173, 28);">获取成员变量</span></span></div></li><ul><li><div><span style="font-size: 11pt;">Field[] getFields() ：获取所有</span><span style="font-size: 11pt; color: rgb(227, 0, 0);">public修饰</span><span style="font-size: 11pt;">的成员变量</span></div></li><li><div><span style="font-size: 11pt;">Field getField(String name)   获取</span><span style="font-size: 11pt; color: rgb(227, 0, 0);">指定名称的 public修饰</span><span style="font-size: 11pt;">的成员变量</span></div></li><li><div><span style="font-size: 11pt;">Field[] getDeclaredFields()  <span style="font-size: 11pt; color: rgb(158, 0, 243);">获取所有的成员变量，不考虑修饰符</span></span></div></li><li><div><span style="font-size: 11pt;">Field getDeclaredField(String name)  </span></div></li></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(65, 173, 28);">获取构造方法</span></span></div></li><ul><li><div><span style="font-size: 11pt;">Constructor&lt;?&gt;[] getConstructors()  </span></div></li><li><div><span style="font-size: 11pt;">Constructor&lt;T&gt; getConstructor(类&lt;?&gt;... parameterTypes)  </span></div></li><li><div><span style="font-size: 11pt;">Constructor&lt;T&gt; getDeclaredConstructor(类&lt;?&gt;... parameterTypes)  </span></div></li><li><div><span style="font-size: 11pt;">Constructor&lt;?&gt;[] getDeclaredConstructors()</span></div></li></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(65, 173, 28);">获取成员方法</span></span></div></li><ul><li><div><span style="font-size: 11pt;">Method[] getMethods()  </span></div></li><li><div><span style="font-size: 11pt;">Method getMethod(String name, 类&lt;?&gt;... parameterTypes)  </span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">Method[] getDeclaredMethods()  </span></span></div></li><li><div><span style="font-size: 11pt;">Method getDeclaredMethod(String name, 类&lt;?&gt;... parameterTypes)</span></div></li></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(65, 173, 28);">获取全类名</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">String getName()</span></span></div></li></ul></ul></ol><li><div><span style="font-size: 14.6667px;">Filed：成员变量</span></div></li><ol><li><div><span style="font-size: 14.6667px;">操作</span></div></li><ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(227, 0, 0);">设置值</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">void set(Object obj, Object value)</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(227, 0, 0);">获取值</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">get(Object obj)</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(209, 0, 255);">忽略访问权限修饰符的安全检查</span></span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(209, 0, 255);">setAccessible(true):</span><span style="font-size: 11pt; color: rgb(209, 0, 255); font-weight: bold;">暴力反射</span></span></div></li></ul></ol></ol><li><div><span style="font-size: 14.6667px;">Constructor：构造方法</span></div></li><ol><li><div><span style="font-size: 14.6667px;">借助Class类中的getConstractor方法</span></div></li><li><div><span style="font-size: 14.6667px;">创建对象：</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">T newInstance(Object... initargs)</span></span></div></li><li><div><span style="font-size: 11pt;">如果使用空参数构造方法创建对象，操作可以简化：Class对象的newInstance方法</span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;">Method：方法对象</span></div></li><ol><li><div><span style="font-size: 14.6667px;">执行方法</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">Object invoke(Object obj, Object... args)  </span></span></div></li></ul><li><div><span style="font-size: 14.6667px;">获取方法名称                                           </span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(134, 0, 164);">String getName:获取方法名</span></span></div></li></ul></ol></ol><div><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px; font-weight: bold;">三、注解</span></span></div><ol><li><div><span style="font-size: 11pt;">概念：说明程序的，给计算机看的</span></div></li><ul><li><div><span style="font-size: 14.6667px;">注释：</span><span style="font-size: 11pt;">用文字描述程序的。给程序员看的</span></div></li></ul><li><div><span style="font-size: 14.6667px;">定义：</span><span style="font-size: 11pt;">注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，<span style="font-size: 11pt; font-weight: bold;">用来对这些元素进行说明，注释。</span></span></div></li><li><div><span style="font-size: 14.6667px;">概念描述：</span></div></li><ul><li><div><span style="font-size: 11pt;">JDK1.5之后的新特性</span></div></li><li><div><span style="font-size: 11pt;">说明程序的</span></div></li><li><div><span style="font-size: 11pt;">使用注解：@注解名称</span></div></li></ul><li><div><span style="font-size: 14.6667px;">作用分类：</span></div></li><ul><li><div><span style="font-size: 11pt;"><font style="color: rgb(166, 0, 196);">编写文档</font>：通过代码里标识的注解生成文档【生成文档doc文档】</span></div></li><li><div><span style="font-size: 11pt;"><font style="color: rgb(166, 0, 196);">代码分析</font>：通过代码里标识的注解对代码进行分析【使用反射】</span></div></li><li><div><span style="font-size: 11pt;"><font style="color: rgb(166, 0, 196);">编译检查</font>：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</span></div></li></ul><li><div><span style="font-size: 11pt;">JDK中预定义的一些注解</span></div></li><ol><li><div><span style="font-size: 11pt;">@Override：检测被该注解标注的方法是否是继承自父类(接口)的</span></div></li><li><div><span style="font-size: 11pt;">@Deprecated：该注解标注的内容，表示已过时</span></div></li><li><div><span style="font-size: 11pt;">@SuppressWarnings：压制警告</span></div></li><ul><li><div><span style="font-size: 11pt;">一般传递参数all  @SuppressWarnings(&quot;all&quot;)</span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;">自定义注解</span></div></li><ul><li><div><span style="font-size: 14.6667px;">格式</span></div></li></ul></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>元注解</div><div>        public @interface 注解名称{</div><div>            属性列表;</div><div>        }</div></div><ul><ul><li><div><span style="font-size: 11pt;">本质：</span><span style="font-size: 11pt;">注解本质上就是一个</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">接口</span><span style="font-size: 11pt;">，该接口默认继承Annotation接口</span></div></li><ul><li><div><span style="font-size: 11pt;">public interface MyAnno extends java.lang.annotation.Annotation {}</span></div></li></ul><li><div><span style="font-size: 14.6667px;">属性：<span style="font-size: 14.6667px; color: rgb(255, 0, 0);">接口中的抽象方法</span></span></div></li><ul><li><div><span style="font-size: 14.6667px;">要求：</span></div></li><ol><li><div><span style="font-size: 11pt;">属性的返回值类型有下列取值</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">基本数据类型</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">String</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">枚举</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">注解</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">以上类型的数组</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;">定义了属性，在使用时需要给属性赋值</span></div></li><ol><li><div><span style="font-size: 11pt;">如果定义属性时，使用default关键字给属性默认初始化值，则使用注解时，可以不进行属性的赋值。</span></div></li><li><div><span style="font-size: 11pt;">如果只有一个属性需要赋值，并且属性的名称是value，则value可以省略，直接定义值即可。</span></div></li><li><div><span style="font-size: 11pt;"> 数组赋值时，值使用{}包裹。如果数组中只有一个值，则{}可以省略</span></div></li></ol></ol></ul><li><div><span style="font-size: 14.6667px;">元注解：<span style="font-size: 14.6667px; color: rgb(255, 0, 0);">用于描述注解的注解</span></span></div></li><ul><li><div><span style="font-size: 11pt;">@Target：描述注解能够作用的位置</span></div></li><ul><li><div><span style="font-size: 11pt;"> ElementType取值：</span></div></li><ul><li><div><span style="font-size: 11pt;">TYPE：可以作用于类上</span></div></li><li><div><span style="font-size: 11pt;">METHOD：可以作用于方法上</span></div></li><li><div><span style="font-size: 11pt;"> FIELD：可以作用于成员变量上</span></div></li></ul></ul><li><div><span style="font-size: 11pt;">@Retention：描述注解被保留的阶段</span></div></li><ul><li><div><span style="font-size: 11pt;">@Retention(RetentionPolicy.RUNTIME)：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</span></div></li></ul><li><div><span style="font-size: 11pt;">@Documented：描述注解是否被抽取到api文档中</span></div></li><li><div><span style="font-size: 11pt;">@Inherited：描述注解是否被子类继承</span></div></li></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">在程序使用（解析）注解：获取注解中定义的属性值</span></span></div></li><ul><li><div><span style="font-size: 11pt;">获取注解定义的位置的对象  （Class，Method,Field）</span></div></li><li><div><span style="font-size: 11pt;">获取指定的注解</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>* getAnnotation(Class)</div><div>        //其实就是在内存中生成了一个该注解接口的子类实现对象</div><div><br/></div><div>                public class ProImpl implements Pro{</div><div>                    public String className(){</div><div>                        return &quot;cn.itcast.annotation.Demo1&quot;;</div><div>                    }</div><div>                    public String methodName(){</div><div>                        return &quot;show&quot;;</div><div>                    }</div><div>                }</div></div><ul><ul><ul><li><div><span style="font-size: 14.6667px;">调用注解中的抽象方法获取配置的属性值</span></div></li></ul></ul></ul><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 