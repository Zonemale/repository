<html>
<head>
  <title>Stream流&amp;方法引用</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1701"/>
<h1>Stream流&amp;方法引用</h1>

<div>
<span><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">一、Stream流</span></font></div><ol><li><div><span style="font-size: 12pt;">循环遍历的弊端</span></div></li><ol><li><div><span style="font-size: 11pt;">for循环的语法就是“怎么做”</span></div></li><li><div><span style="font-size: 11pt;">for循环的循环体才是“做什么”</span></div></li><li><div><span style="font-size: 11pt;">循 环是做事情的方式，而不是目的。另一方面，使用线性循环就意味着只能遍历一次。如果希望再次遍历，只能再使 用另一个循环从头开始。</span></div></li></ol><li><div><span style="font-size: 14.6667px;">Stream的更优写法</span></div></li><ol><li><div><span style="font-size: 11pt;">使用Stream流的方式,遍历集合,对集合中的数据进行过滤</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(188, 0, 88);">Stream流是JDK1.8之后出现的</span></span></div></li><li><div><span style="font-size: 11pt;">关注的是做什么,而不是怎么做</span></div></li></ol><li><div><span style="font-size: 14.6667px;">流式思想概述：（Stream（流）是一个<font style="color: rgb(227, 0, 0);"><b>来自数据源的元素队列</b></font>）</span></div></li><ol><li><div><span style="font-size: 14.6667px;">元素是特定类型的对象，形成一个队列，</span><span style="font-size: 14.6667px; color: rgb(227, 0, 0); font-weight: bold;">Java中的Stream并不会存储元素</span><span style="font-size: 14.6667px;">，而是按需计算</span></div></li><li><div><span style="font-size: 14.6667px;">数据源：流的来源，可以是集合，数组等</span></div></li><li><div><span style="font-size: 14.6667px;">Stream操作基础特征</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">Pipelining:中间操</span></span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">作都会返回流对象本身</span>。 这样多个操作可以串联成一个管道， 如同流式风格（ﬂuent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(227, 0, 0);">内部迭代</span>：</span><span style="font-size: 11pt;">以前对集合遍历都是通过Iterator或者增强for的方式, 显式的在集合外部进行迭代， 这叫做外部迭 代。 <font style="color: rgb(255, 0, 0);">Stream提供了<b>内部迭代</b>的方式，流可以直接调用遍历方法。</font></span></div></li></ol></ol><ol><li><div><span style="font-size: 14.6667px;">使用流步骤：</span></div></li><ol><li><div><span style="font-size: 11pt;">获取一个数据源（source）</span></div></li><li><div><span style="font-size: 11pt;">数据转换</span></div></li><li><div><span style="font-size: 11pt;">执行操作获取想要的结果</span></div></li></ol><li><div><span style="font-size: 14.6667px;">注意：</span><span style="font-size: 11pt;">，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以 像链条一样排列，变成一个管道。</span></div></li></ol><li><div><span style="font-size: 14.6667px;">获取流</span></div></li><ol><li><div><span style="font-size: 11pt;">java.util.stream.Stream&lt;T&gt;是Java 8新加入的最常用的流接口。（这并不是一个函数式接口。）</span><span style="font-size: 11pt;">获取一个流非常简单，有以下几种常用的方式：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">所有的Collection集合都可以通过stream默认方法获取流；</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">default Stream&lt;E&gt; stream()</span></span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">Stream接口的静态方法of可以获取数组对应的流。</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">static &lt;T&gt; Stream&lt;T&gt; of(T... values)</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">参数是一个可变参数,那么我们就可以传递一个数组</span></span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">根据Collection获取流</span></span></div></li><ol><li><div><span style="font-size: 11pt;">首先， java.util.Collection 接口中加入了default方法 stream 用来获取流，所以其所有实现类均可获取流</span></div></li><li><div><span style="font-size: 11pt;"> 示例：Stream&lt;String&gt; stream1 = list.stream();</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">根据Map获取流</span></span></div></li><ol><li><div><span style="font-size: 11pt;">java.util.Map 接口不是 Collection 的子接口，且其K-V数据结构不符合流元素的<b><font style="color: rgb(255, 0, 0);">单一特征</font></b>，所以获取对应的流 需要分key、value或entry等情况：</span></div></li><li><div><span style="font-size: 14.6667px;">示例</span></div></li><ul><li><div><span style="font-size: 11pt;">Stream&lt;String&gt; keyStream = map.keySet().stream();</span></div></li><li><div><span style="font-size: 11pt;">Stream&lt;String&gt; valueStream = map.values().stream();</span></div></li><li><div><span style="font-size: 11pt;">Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream()</span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">根据数组获取流</span></span></div></li><ol><li><div><span style="font-size: 11pt;">如果使用的不是集合或映射而是数组，由于数组对象</span></div></li><li><div><span style="font-size: 11pt;">不可能添加默认方法，所以 Stream 接口中提供了静态方法 of</span></div></li><li><div><span style="font-size: 14.6667px;">示例：</span><span style="font-size: 11pt;"> Stream&lt;String&gt; stream = Stream.of(array);</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">收集Stream结果</span></div></li><ol><li><div><span style="font-size: 14.6667px;">Stream提供toArray方法，将流对象转换为集合或者数组，</span></div></li><ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(227, 0, 0);">将Stream流对象转换为数组</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">Object[] toArray();</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">&lt;A&gt; A[] toArray(InFunction&lt;A[]&gt; generator);</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(227, 0, 0);">将Stream流对象转换为集合</span></span></div></li><ul><li><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">List</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">&lt;</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">String</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">&gt;</span> <span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">collect</span> <span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">=</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">stream</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">.</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">collect</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">(</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">Collectors</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">.</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas; font-style: italic;">toList</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">())</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">;</span></div></li><li><div><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">Set</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">&lt;</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">String</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">&gt;</span> <span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">collect</span> <span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">=</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">stream</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">.</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">collect</span><span style="background-color: rgb(255, 255, 255); font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">(</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">Collectors</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">.</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas; font-style: italic;">toSet</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">())</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: Consolas;">;</span></div></li></ul></ul></ol><li><div><span style="font-size: 14.6667px;">常用方法</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"><font style="color: rgb(255, 0, 0);">延迟方法</font></span>：返回值类型仍然是 Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方 法均为延迟方法。）</span></div></li><li><div><span style="font-size: 11pt; font-weight: bold;"><font style="color: rgb(255, 0, 0);">终结方法</font></span><span style="font-size: 11pt;">：返回值类型不再是 Stream 接口自身类型的方法，因此不再支持类似 StringBuilder 那样的链式调 用。本小节中，</span><span style="font-size: 11pt; font-weight: bold;">终结方法包括 count 和 forEach 方法</span><span style="font-size: 11pt;">。</span></div></li><li><div><span style="font-size: 14.6667px;"><font style="color: rgb(255, 0, 0);">逐一处理：forEach</font></span></div></li><ul><li><div><span style="font-size: 11pt;">void forEach(Consumer&lt;? super T&gt; action);</span></div></li><li><div><span style="font-size: 11pt;">该方法接收一个 Consumer 接口函数，会将每一个流元素交给该函数进行处理</span></div></li></ul><li><div><span style="font-size: 14.6667px;"><font style="color: rgb(255, 0, 0);">过滤：filter</font></span></div></li><ol><li><div><span style="font-size: 11pt;">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span></div></li><li><div><span style="font-size: 11pt;">该接口接收一个 Predicate 函数式接口参数（可以是一个Lambda或方法引用）作为筛选条件</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><font style="color: rgb(255, 0, 0);">映射：map</font></span></div></li><ol><li><div><span style="font-size: 11pt;">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper);</span></div></li><li><div><span style="font-size: 11pt;">该接口需要一个 Function 函数式接口参数，可以将当前流中的T类型数据转换为另一种R类型的流。</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><font style="color: rgb(255, 0, 0);">统计个数：count</font></span></div></li><ol><li><div><span style="font-size: 11pt;">long count();</span></div></li><li><div><span style="font-size: 11pt;">该方法返回一个long值代表元素个数（不再像旧集合那样是int值）。</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><font style="color: rgb(255, 0, 0);">取用前几个：limit</font></span></div></li><ol><li><div><span style="font-size: 11pt;">Stream&lt;T&gt; limit(long maxSize);</span></div></li><li><div><span style="font-size: 11pt;">参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。（不包括maxSize）</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><font style="color: rgb(255, 0, 0);">跳过前几个：skip</font></span></div></li><ol><li><div><span style="font-size: 11pt;">Stream&lt;T&gt; skip(long n);</span></div></li><li><div><span style="font-size: 11pt;">如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流（包括第n个）</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><font style="color: rgb(255, 0, 0);">组合：concat</font></span></div></li><ol><li><div><span style="font-size: 11pt;">static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a,Stream&lt;? extends T&gt; b)</span></div></li><li><div><span style="font-size: 11pt;">如果有两个流，希望合并成为一个流，那么可以使用 Stream 接口的静态方法 concat</span></div></li></ol></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">二、方法引用</span></div><ol><li><div><span style="font-size: 14.6667px;">概念：</span><span style="font-size: 11pt;">双冒号 :: 为引用运算符，而它所在的表达式被称为方法引用。如果Lambda要表达的函数方案已经存在于某个方 法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者</span></div></li><li><div><span style="font-size: 14.6667px;">语义分析：</span></div></li><ol><li><div><span style="font-size: 11pt;">Lambda表达式写法： s -&gt; System.out.println(s);</span></div></li><ol><li><div><span style="font-size: 11pt;">拿到参数之后经Lambda之手，继而传递给 System.out.println 方法去处理。</span></div></li></ol><li><div><span style="font-size: 11pt;">方法引用写法： System.out::println</span></div></li><ol><li><div><span style="font-size: 11pt;">直接让 System.out 中的 println 方法来取代Lambda。两种写法的执行效果完全一 样，而第二种方法引用的写法复用了已有方案，更加简洁。</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">推导与省略：</span></div></li><ol><li><div><span style="font-size: 11pt;">如果使用Lambda，那么根据“</span><span style="font-size: 11pt; color: rgb(227, 0, 0); font-weight: bold;">可推导就是可省略</span><span style="font-size: 11pt;">”的原则，无需指定参数类型，也无需指定的重载形式——它们都 将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。</span></div></li></ol><li><div><span style="font-size: 14.6667px;">通过对象名引用成员方法：</span><span style="font-size: 11pt;"> printString(obj::printUpperCase);</span></div></li><li><div><span style="font-size: 14.6667px;">通过类名称引用静态方法：</span> <span style="font-size: 11pt;">method(‐10, Math::abs);</span></div></li><ul><li><div><span style="font-size: 11pt;">Lambda表达式： n -&gt; Math.abs(n)</span></div></li><li><div><span style="font-size: 11pt;">方法引用： Math::abs</span></div></li></ul><li><div><span style="font-size: 14.6667px;">通过super引用成员方法</span></div></li><ol><li><div><span style="font-size: 11pt;"> </span><span style="font-size: 11pt;">如果存在继承关系，当Lambda中需要出现super调用时，也可以使用方法引用进行替代</span></div></li><ul><li><div><span style="font-size: 11pt;"> method(super::sayHello);</span></div></li><li><div><span style="font-size: 11pt;">Lambda表达式： () -&gt; super.sayHello()</span></div></li><li><div><span style="font-size: 11pt;">方法引用： super::sayHello</span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;">通过this引用成员方法</span></div></li><ol><li><div><span style="font-size: 11pt;">this代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用“this::成员方法”的格式来使用方 法引用</span></div></li><ul><li><div><span style="font-size: 11pt;">marry(() ‐&gt; this.buyHouse());</span></div></li><li><div><span style="font-size: 11pt;">Lambda表达式： () -&gt; this.buyHouse()</span></div></li><li><div><span style="font-size: 11pt;">方法引用： this::buyHouse</span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;">类的构造器引用</span></div></li><ol><li><div><span style="font-size: 11pt;">由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用 类名称::new 的格式表示</span></div></li><ul><li><div><span style="font-size: 11pt;">Lambda表达式： name -&gt; new Person(name)</span></div></li><li><div><span style="font-size: 11pt;">方法引用： Person::new</span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;">数组的构造器引用</span></div></li><ol><li><div><span style="font-size: 11pt;">数组也是 Object 的子类对象，所以同样具有构造器，只是语法稍有不同。如果对应到Lambda的使用场景中时，</span></div></li><ul><li><div><span style="font-size: 11pt;">int[] array = initArray(10, int[]::new)</span></div></li><li><div><span style="font-size: 11pt;">Lambda表达式： length -&gt; new int[length]</span></div></li><li><div><span style="font-size: 11pt;">方法引用： int[]::ne</span></div></li></ul></ol></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 