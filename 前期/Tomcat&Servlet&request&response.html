<html>
<head>
  <title>Tomcat&amp;Servlet&amp;request&amp;response</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1898"/>
<h1>Tomcat&amp;Servlet&amp;request&amp;response</h1>

<div>
<span><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">一、web服务器软件</span></font></div><ol><li><div><span style="font-size: 14.6667px;">概念：</span></div></li><ol><li><div><span style="font-size: 11pt;">服务器：安装了服务软件的计算机</span></div></li><li><div><span style="font-size: 11pt;">服务器软件：接收用户的请求，处理请求，做出响应</span></div></li><li><div><span style="font-size: 11pt;">web服务器软件：接收用户的请求，处理请求，做出响应。</span></div></li><ol><li><div><span style="font-size: 11pt;">在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目</span></div></li><li><div><span style="font-size: 11pt;"> web容器</span></div></li></ol><li><div>常见的java相关的web服务器软件：</div></li><ol><li><div>webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</div></li><li><div>webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</div></li><li><div>JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。</div></li><li><div>Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。</div></li></ol><li><div>JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了<span style="color: rgb(255, 0, 0);">13项大的规范</span></div></li></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">二、Tomact目录结构（Tomact服务器的底层原理是socket套接字实现的）</span></div><div><img src="Tomcat&Servlet&request&response_files/tomcat目录结构.png" type="image/png" data-filename="tomcat目录结构.png" width="878"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Tomcat：web服务器软件</div><div>    1. 下载：http://tomcat.apache.org/</div><div>    2. 安装：解压压缩包即可。</div><div>        * 注意：安装目录建议不要有中文和空格</div><div>    3. 卸载：删除目录就行了</div><div>    4. 启动：</div><div>        * bin/startup.bat ,双击运行该文件即可</div><div>        * 访问：浏览器输入：http://localhost:8080 回车访问自己</div><div>                          http://别人的ip:8080 访问别人</div><div>        * 可能遇到的问题：</div><div>            1. 黑窗口一闪而过：</div><div>                * 原因： 没有正确配置JAVA_HOME环境变量</div><div>                * 解决方案：正确配置JAVA_HOME环境变量</div><div><br/></div><div>            2. 启动报错：</div><div>                1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程</div><div>                    * netstat -ano</div><div>                2. 温柔：修改自身的端口号</div><div>                    * conf/server.xml</div><div>                    * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;</div><div>                       connectionTimeout=&quot;20000&quot;</div><div>                       redirectPort=&quot;8445&quot; /&gt;</div><div>                    * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。</div><div>                        * 好处：在访问时，就不用输入端口号</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>关闭：</div><div>        1. 正常关闭：</div><div>            * bin/shutdown.bat</div><div>            * ctrl+c</div><div>        2. 强制关闭：</div><div>            * 点击启动窗口的×</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>配置:</div><div>        * 部署项目的方式：</div><div>            1. 直接将项目放到webapps目录下即可。</div><div>                * /hello：项目的访问路径--&gt;虚拟目录</div><div>                * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。</div><div>                    * war包会自动解压缩</div><div><br/></div><div>            2. 配置conf/server.xml文件</div><div>                在&lt;Host&gt;标签体中配置</div><div>                &lt;Context docBase=&quot;D:\hello&quot; path=&quot;/hehe&quot; /&gt;</div><div>                * docBase:项目存放的路径</div><div>                * path：虚拟目录</div><div><br/></div><div>            <font color="#FF0000" style="font-size: 10pt;"><b>3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写</b></font></div><div><font style="font-size: 10pt; color: rgb(255, 0, 0);"><b>                &lt;Context docBase=&quot;D:\hello&quot; /&gt;</b></font></div><div><font color="#FF0000" style="font-size: 10pt;"><b>                * 虚拟目录：xml文件的名称</b></font></div><div>        </div><div>        * <b><font color="#FF0000" style="font-size: 10pt;">静态项目和动态项目：</font></b></div><div><b><font color="#FF0000" style="font-size: 10pt;">            * 目录结构</font></b></div><div><b><font color="#FF0000" style="font-size: 10pt;">                * java动态项目的目录结构：</font></b></div><div><b><font color="#FF0000" style="font-size: 10pt;">                    -- 项目的根目录</font></b></div><div><b><font color="#FF0000" style="font-size: 10pt;">                        -- WEB-INF目录：</font></b></div><div><b><font style="font-size: 10pt; color: rgb(255, 0, 0);">                            -- web.xml：web项目的核心配置文件</font></b></div><div><b><font style="font-size: 10pt; color: rgb(255, 0, 0);">                            -- classes目录：放置字节码文件的目录</font></b></div><div><b><font style="font-size: 10pt; color: rgb(255, 0, 0);">                            -- lib目录：放置依赖的jar包</font></b></div><div><b><font color="#FF0000" style="font-size: 10pt;">                    -- 静态资源</font></b></div><div><font style="font-family: Monaco; color: rgb(255, 0, 0);"><b>项目中src目录下的文件最终会被编译，放到WEB-INF 文件中的classes文件夹中</b></font></div><div><br/></div><div>将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。</div></div><div><span style="font-size: 14pt; font-weight: bold;">三、Servlet(server applet)</span></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><img src="Tomcat&Servlet&request&response_files/Servlet.bmp" type="image/bmp" data-filename="Servlet.bmp" width="988"/></span></span></div><div><br/></div><ol><li><div><span style="font-size: 11pt;">概念：<span style="font-size: 11pt; color: rgb(198, 197, 0); font-weight: bold;">运行在服务器端的小程序</span></span></div></li><ol><li><div><span style="font-size: 11pt;">Servlet就是一个接口，<span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">定义了Java类被浏览器访问到(tomcat识别)的规则。</span></span></div></li><li><div><span style="font-size: 11pt;">将来我们自定义一个类，实现Servlet接口，复写方法。</span></div></li><li><div><span style="font-size: 14.6667px;">可以重写init和destroy方法</span></div></li></ol><li><div><span style="font-size: 11pt;">快速入门：</span></div></li><ol><li><div><span style="font-size: 11pt;">创建JavaEE项目</span></div></li><li><div><span style="font-size: 11pt;">定义一个类，实现Servlet接口</span></div></li><ol><li><div><span style="font-size: 11pt;">public class ServletDemo1 implements Servlet</span></div></li></ol><li><div><span style="font-size: 11pt;">实现接口中的抽象方法</span></div></li><li><div><span style="font-size: 11pt;">配置Servlet</span></div></li><ol><li><div><span style="font-size: 11pt;">在web.xml中配置：</span></div></li></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 11pt;">&lt;!-- 配置servlet --&gt;</font></div><div><font style="font-size: 11pt;">&lt;!--servlet实现类--&gt;</font></div><div><font style="font-size: 11pt;">&lt;servlet&gt;</font></div><div><font style="font-size: 11pt;">    &lt;!--指定此servlet的名字，作用是将mapping和servlet联系起来--&gt;</font></div><div><font style="font-size: 11pt;">    &lt;servlet-name&gt;class1&lt;/servlet-name&gt;</font></div><div><font style="font-size: 11pt;">    &lt;!--指定servlet的类--&gt;</font></div><div><font style="font-size: 11pt;">    &lt;servlet-class&gt;web.practice.ServletImpl&lt;/servlet-class&gt;</font></div><div><font style="font-size: 11pt;">    &lt;!--指定当前Web应用启动时装载Servlet的次序--&gt;</font></div><div><font style="font-size: 11pt;">    &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt;</font></div><div><font style="font-size: 11pt;">&lt;/servlet&gt;</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">&lt;!--定义servlet映射，里面的&lt;servlet-name&gt;必须与前面的名字一致--&gt;</font></div><div><font style="font-size: 11pt;">&lt;servlet-mapping&gt;</font></div><div><font style="font-size: 11pt;">    &lt;servlet-name&gt;class1&lt;/servlet-name&gt;</font></div><div><font style="font-size: 11pt;">    &lt;!--指定servlet<font color="#FF0000"><b>映射的路径</b></font>。--&gt;</font></div><div><font style="font-size: 11pt;">    &lt;url-pattern&gt;/servletImpl&lt;/url-pattern&gt;</font></div><div><font style="font-size: 11pt;">&lt;/servlet-mapping&gt;</font></div></div><ol><li><div><span style="font-size: 11pt;">servlet执行原理</span></div></li><ol><li><div><span style="font-size: 11pt;">执行原理：</span></div></li><ol><li><div><span style="font-size: 11pt;">当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径</span></div></li><li><div><span style="font-size: 11pt;">查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容。</span></div></li><li><div><span style="font-size: 11pt;">如果有，则在找到对应的&lt;servlet-class&gt;全类名</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">tomcat会将字节码文件加载进内存，并且创建其对象</span></span></div></li><li><div><span style="font-size: 11pt;">调用其方法</span></div></li></ol><li><div><span style="font-size: 11pt;"><img src="Tomcat&Servlet&request&response_files/Servlet执行原理.bmp" type="image/bmp" data-filename="Servlet执行原理.bmp" width="903"/></span></div></li></ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">Servlet中的生命周期方法：</span></div></li><ol><li><div><span style="font-size: 11pt;">被创建：执行init方法，<span style="font-size: 11pt; color: rgb(188, 0, 88); font-weight: bold;">只执行一次:init(ServletConfig config)</span></span></div></li><ol><li><div><span style="font-size: 11pt;">Servlet什么时候被创建？</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(65, 173, 28); font-weight: bold;">默认情况下，第一次被访问时，Servlet被创建</span></span></div></li><li><div><span style="font-size: 11pt;">可以配置执行Servlet的创建时机。</span></div></li><ol><li><div><span style="font-size: 11pt;">在&lt;servlet&gt;标签下配置</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">第一次被访问时，创建</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">&lt;load-on-startup&gt;的值为负数</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">容器将在用户首次访问时加载这个servlet类</span></span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">在服务器启动时，创建</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">&lt;load-on-startup&gt;的值为0或正整数</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">容器会按数值从小到大依次加载</span></span></div></li></ul></ol></ol></ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">Servlet的init方法</span><span style="font-size: 11pt;">，</span><span style="font-size: 11pt; color: rgb(209, 0, 255); font-weight: bold;">只执行一次</span><span style="font-size: 11pt;">，说明一个Servlet在内存中只存在一个对象，</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">Servlet是单例的但是Servlet不是单例设计模式</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(235, 0, 115);">多个用户同时访问时，可能存在线程安全问题。</span></div></li><li><div><span style="font-size: 11pt; color: rgb(235, 0, 115);">解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值</span></div></li><li><div><span style="font-size: 11pt; color: rgb(235, 0, 115);">注意：单例：单个实例（对象），servlet不是单例设计模式（一个类只能创建一个对象）</span></div></li></ol></ol><li><div><span style="font-size: 11pt;">提供服务：执行service方法，执行多次:<span style="font-size: 11pt; color: rgb(118, 0, 216);">service(ServletRequest req,ServletResponse resp)</span></span></div></li><ol><li><div><span style="font-size: 11pt;">每次访问Servlet时，Service方法都会被调用一次。</span></div></li></ol><li><div><span style="font-size: 11pt;">被销毁：执行destroy方法，只执行一次</span></div></li><ol><li><div><span style="font-size: 11pt;">Servlet被销毁时执行。<span style="font-size: 11pt; color: rgb(88, 152, 255);">服务器关闭时，Servlet被销毁</span></span></div></li><li><div><span style="font-size: 11pt;">只有服务器正常关闭时，才会执行destroy方法。</span></div></li><li><div><span style="font-size: 11pt;">destroy方法在Servlet被销毁之前执行，一般用于释放资源</span></div></li></ol></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(26, 173, 224);">Servlet3.0</span>:注解配置</span></div></li><ol><li><div><span style="font-size: 11pt;">好处：</span></div></li><ol><li><div><span style="font-size: 11pt;">支持注解配置，可以不需要web.xml了</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">servlet3.0可以进行注解配置也可以通过web.xml进行配置</span></span></div></li></ol><li><div><span style="font-size: 11pt;">步骤</span></div></li><ol><li><div><span style="font-size: 11pt;">创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml</span></div></li><li><div><span style="font-size: 11pt;">定义一个类，实现Servlet接口</span></div></li><li><div><span style="font-size: 11pt;">复写方法</span></div></li><li><div><span style="font-size: 11pt;">在类上使用@WebServlet注解，进行配置</span></div></li><ul><li><div><span style="font-size: 11pt;">@WebServlet(&quot;</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">资源路径</span><span style="font-size: 11pt;">&quot;)</span></div></li><li><div><span style="font-size: 11pt;">@Target({ElementType.TYPE})</span></div></li><li><div><span style="font-size: 11pt;">@Retention(RetentionPolicy.RUNTIME)</span></div></li><li><div><span style="font-size: 11pt;">@Documented</span></div></li></ul></ol></ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Servlet体系结构</span></span></div></li><ol><li><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">Servlet(接口)---&gt;GenericServlet(抽象类)---&gt;</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">HttpServlet(抽象类)</span><span style="font-size: 12pt;"><img src="Tomcat&Servlet&request&response_files/servlet的执行流程.png" type="image/png" data-filename="servlet的执行流程.png" width="927"/></span></div></li><ul><li><div><span style="font-size: 12pt;">GenericServlet：将Servlet接口中其他的方法做了默认</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">空实现</span><span style="font-size: 12pt;">，只将service()方法作为抽象</span></div></li><ul><li><div><span style="font-size: 12pt;">将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可</span></div></li></ul><li><div><span style="font-size: 12pt;">HttpServlet：对http协议的一种封装，简化操作</span></div></li><ol><li><div><span style="font-size: 12pt;">定义类继承HttpServlet</span></div></li><li><div><span style="font-size: 12pt;">复写doGet/doPost方法</span></div></li></ol></ul></ol><li><div><span style="font-size: 12pt;">Servlet相关配置</span></div></li><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">url-partten:Servlet访问路径</span></span></div></li><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(227, 0, 0);">一个Servlet可以定义多个访问路径 ： @WebServlet({&quot;/d4&quot;,&quot;/dd4&quot;,&quot;/ddd4&quot;})</span></span></div></li><li><div><span style="font-size: 12pt;">路径定义规则：</span></div></li><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">/xxx：路径匹配</span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">/xxx/xxx:多层路径，目录结构（完全路径匹配）</span></span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">/user/*(目录匹配)</span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">/*:任意目录结构（全匹配）</span></span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">*.do：扩展名匹配（后缀名匹配）</span></span></span></div></li></ol></ol></ol><li><div><span style="font-weight: bold;">servlet3.0新增了一些注解，在类上添加@webServlet，</span><span style="color: rgb(255, 0, 0); font-weight: bold;">注解里面的name代表的是servlet的name</span><span style="font-weight: bold;">，</span><span style="color: rgb(134, 0, 164); font-weight: bold;">urlPatterns代表的是请求路径</span><span style="font-weight: bold;">，可以配多个，servlet3.0也是需要在类上实现servlet的接口</span></div></li></ol><div><span style="font-size: 14pt; font-weight: bold;">四、IDEA与Tomcat的相关配置</span></div><ol><li><div>IDEA会为每一个tomcat部署的项目单独建立一份配置文件</div></li><ol><li><div>C:\Users\ASUS\.IntelliJIdea2017.3\system\tomcat\_ThirdStep</div></li></ol><li><div>工作空间项目    和     tomcat部署的web项目</div></li><ol><li><div> tomcat真正访问的是“tomcat部署的web项目”，&quot;tomcat部署的web项目&quot;对应着&quot;工作空间项目&quot; 的web目录下的所有资源</div></li><ol><li><div>WEB-INF目录下的资源不能被浏览器直接访问。</div></li></ol></ol><li><div>断点调试：使用&quot;小虫子&quot;启动 dubug 启动</div></li></ol><div><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px; font-weight: bold;">五、http请求消息</span></span></div><ol><li><div><span style="font-size: 11pt;">概念：</span><span style="font-size: 11pt;">Hyper Text Transfer Protocol <span style="font-size: 11pt; color: rgb(255, 0, 0); font-style: italic; font-weight: bold;">超文本传输协议</span></span></div></li><ol><li><div><span style="font-size: 11pt;">传输协议：定义了，客户端和服务器端通信时，发送数据的格式</span></div></li><li><div><span style="font-size: 11pt;">特点：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">基于TCP/IP的高级协议</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">默认端口号:80</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">基于请求/响应模型的:一次请求对应一次响应</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">无状态的</span>：每次请求之间相互独立，不能交互数据</span></span></div></li></ol></ol><li><div><span style="font-size: 11pt;">请求消息数据格式</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">请求行</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">请求方式 请求url 请求协议/版本</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">GET /login.html    HTTP/1.1</span></span></div></li><ol><li><div><span style="font-size: 11pt;">请求方式：</span></div></li><ol><li><div><span style="font-size: 11pt;">HTTP协议</span><span style="font-size: 11pt; color: rgb(255, 70, 53); font-weight: bold;">有7种请求方式</span><span style="font-size: 11pt;">，常用的有2种</span></div></li><ol><li><div><span style="font-size: 11pt;">GET：</span></div></li><ol><li><div><span style="font-size: 11pt;">请求参数在</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">请求行中</span><span style="font-size: 11pt;">，在url后。</span></div></li><li><div><span style="font-size: 11pt;">请求的url长度有限制的</span></div></li><li><div><span style="font-size: 11pt;">不太安全</span></div></li></ol><li><div><span style="font-size: 11pt;">POST：</span></div></li><ol><li><div><span style="font-size: 11pt;">请求参数在<span style="font-size: 11pt; color: rgb(255, 0, 0);">请求体中</span></span></div></li><li><div><span style="font-size: 11pt;">请求的url长度没有限制的</span></div></li><li><div><span style="font-size: 11pt;">相对安全</span></div></li></ol></ol></ol></ol></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">请求头：客户端浏览器告诉服务器一些信息</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">请求头名称: 请求头值</span></span></div></li><li><div><span style="font-size: 11pt;">常见的请求头：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">User-Agent：</span>浏览器告诉服务器，我访问你使用的浏览器版本信息</span></div></li><ol><li><div><span style="font-size: 11pt;">可以在服务器端获取该头的信息，解决浏览器的兼容性问题</span></div></li></ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">Referer：</span><a href="http://localhost/login.html" style="font-size: 11pt; color: rgb(255, 0, 0);">http://localhost/login.html</a></div></li><ol><li><div><span style="font-size: 11pt;"> 告诉服务器，我(当前请求)从哪里来？</span></div></li><ol><li><div><span style="font-size: 11pt;">作用：</span></div></li><ol><li><div><span style="font-size: 11pt;">防盗链：</span></div></li><li><div><span style="font-size: 11pt;">统计工作：</span></div></li></ol></ol></ol></ol></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">请求空行</span></span></div></li><ul><li><div><span style="font-size: 11pt;">空行，</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">就是用于分割POST请求的请求头，和请求体的</span><span style="font-size: 11pt;">。</span></div></li></ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">请求体(正文)：</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">封装POST请求消息的请求参数的（请求体就是用户以post方式提交的数据）</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;">字符串格式</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>        POST /login.html    HTTP/1.1</div><div>        Host: localhost</div><div>        User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</div><div>        Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</div><div>        Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</div><div>        Accept-Encoding: gzip, deflate</div><div>        Referer: http://localhost/login.html</div><div>        Connection: keep-alive</div><div>        Upgrade-Insecure-Requests: 1</div><div>        </div><div>        username=zhangsan</div></div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;"><img src="Tomcat&Servlet&request&response_files/请求数据抓包.png" type="image/png" data-filename="请求数据抓包.png"/></span></span></div><div><span style="font-size: 14pt; font-weight: bold;">六、Request</span></div><ol><li><div><span style="font-size: 11pt;">request对象和response对象的原理</span></div></li><ol><li><div><span style="font-size: 11pt;">request和response对象是由</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">服务器创建的</span><span style="font-size: 11pt;">。我们来使用它们</span></div></li><li><div><span style="font-size: 11pt;">request对象是来</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">获取请求消息</span><span style="font-size: 11pt;">，response对象是来</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">设置响应消息</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">请求发生，request对象创建，响应产生request对象销毁。</span></span></div></li></ol><li><div><span style="font-size: 11pt;">request对象继承体系结构：    </span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">ServletRequest(接口)---&gt;HttpServletRequest(接口)---&gt;</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">org.apache.catalina.connector.</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">RequestFacade</span> <span style="font-size: 11pt; color: rgb(255, 0, 0);">类(tomcat)</span></div></li></ol><li><div><span style="font-size: 11pt;">request功能</span></div></li><ol><li><div><span style="font-size: 11pt;">获取请求行数据</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">GET /day14/demo1?name=zhangsan HTTP/1.1</span></span></div></li><li><div><span style="font-size: 14.6667px;">方法</span></div></li><ol><li><div><span style="font-size: 14.6667px;">获取请求方式：GET</span></div></li><ol><li><div><span style="font-size: 11pt;">String getMethod() </span></div></li></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">(*)获取虚拟目录：/day14</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">String getContextPath()</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;">获取Servlet路径：/demo1</span></div></li><ol><li><div><span style="font-size: 11pt;">String getServletPath()</span></div></li></ol><li><div><span style="font-size: 14.6667px;">获取get方式请求参数：name=zhangsan</span></div></li><ol><li><div><span style="font-size: 11pt;">String getQueryString()</span></div></li></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(188, 0, 88); font-weight: bold;">(*)获取请求URI：/day14/demo1</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(188, 0, 88); font-weight: bold;">String getRequestURI();</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(188, 0, 88); font-weight: bold;">StringBuffer getRequestURL()</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(188, 0, 88); font-weight: bold;">URL:</span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(134, 0, 164); font-weight: bold;">统一资源定位符</span></span></span></div></li><ol><li><div><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold; line-height: 1.45;">统一资源定位符</span><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold; line-height: 1.45;">URL</span><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold; line-height: 1.45;">（</span><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold; line-height: 1.45;">Uniform</span> <span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold; line-height: 1.45;">Resource</span> <span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold; line-height: 1.45;">Locator</span><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; line-height: 1.45;"><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; line-height: 1.45; font-weight: bold;">）是用来表示从因特网上得到的资源位置和访问这些资源的方法</span>。</span><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; line-height: 1.45;">URL</span><span style="font-size: 14px; color: rgb(51, 51, 51); font-family: &quot;Source Code Pro&quot;, monospace; line-height: 1.45;">给资源的位置提供一种抽象的识别方法，并用这种方法给资源定位。只要能够对资源定位，系统就可以对资源进行各种操作，如存取、更新、替换和查找属性。</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(188, 0, 88); font-weight: bold;">URI：</span><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(134, 0, 164); font-weight: bold;">统一资源标识符，代表范围大于URL的范围</span></span></span></div></li><ol><li><div><span style="font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold;">统一资源标识符</span><span style="font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold;">URI</span><span style="font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold;">（</span><span style="font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold;">Uniform</span> <span style="font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold;">Resource</span> <span style="font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold;">Identifier</span><span style="font-family: &quot;Source Code Pro&quot;, monospace; font-weight: bold;">)是一个用于标识某一互联网资源名称的字符串,该种标识允许用户对网络中（一般指万维网）的资源通过特定的协议进行交互操作。</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">获取协议及版本</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">String getProtocol()</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;">获取客户机的IP地址</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">String getRemoteAddr()</span></span></div></li></ol></ol></ol><li><div><span style="font-size: 14.6667px;">获取</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">请求头数据</span><span style="font-size: 14.6667px;">：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">方法：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">(*)String getHeader(String name):通过请求头的名称获取请求头的值</span></span></div></li><li><div><span style="font-size: 11pt;">Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">获取请求体数据</span></div></li><ol><li><div><span style="font-size: 14.6667px;">请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</span></div></li><li><div><span style="font-size: 14.6667px;">步骤：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">获取流对象</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(222, 87, 0);">BufferedReader getReader():获取字符输入流，只能操作字符数据</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(222, 87, 0);">ServletInputStream getInputStream():获取字节输入流，可以操作所有类型数据</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;">再从流对象中拿数据</span></div></li></ol></ol></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">其他功能：</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">获取请求参数通用方式：</span>不论get还是post请求方式都可以使用下列方法来获取请求参数</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">String getParameter(String name):根据参数名称获取参数值    username=zs&amp;password=123</span></span></div></li><li><div><span style="font-size: 11pt;">String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&amp;hobby=game</span></div></li><li><div><span style="font-size: 11pt;">Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(134, 0, 164); font-weight: bold;">注意：中文乱码问题：（编码和解码的字符集不一致）</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(134, 0, 164);">get方式：tomcat 8 已经将get方式乱码问题解决了</span></span></div></li><li><div><span style="font-size: 11pt; color: rgb(134, 0, 164);">post方式：会乱码，</span><span style="font-size: 11pt; color: rgb(134, 0, 164);">解决：在获取参数前，设置request的编码<span style="font-size: 11pt; color: rgb(134, 0, 164); font-weight: bold;">request.setCharacterEncoding(&quot;utf-8&quot;);</span></span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">请求转发：<span style="font-size: 14.6667px; font-weight: bold; color: rgb(45, 79, 201);">一种在服务器内部的资源跳转方式</span></span></span></div></li><ol><li><div><span style="font-size: 14.6667px;">步骤：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">通过request对象获取请求</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">转发器对象</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">：RequestDispatcher getRequestDispatcher(String path)</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response)</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;">特点：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(118, 0, 216); font-weight: bold;">浏览器地址栏路径不发生变化</span></span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(118, 0, 216); font-weight: bold;">只能转发到当前服务器内部资源中。</span></span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(118, 0, 216); font-weight: bold;">转发是一次请求</span></span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(118, 0, 216); font-weight: bold;">请求转发代码执行后，该代码之后的代码还会继续执行</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(118, 0, 216); font-weight: bold;">注意：资源的路径不需要添加虚拟目录</span></span></div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">共享数据：</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0); font-weight: bold;">域对象：一个有作用范围的对象，可以在范围内共享数据</span></span></div></li><li><div><span style="font-size: 11pt;">request域：代表</span><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(77, 206, 29); font-weight: bold;">一次请求的范围</span></span><span style="font-size: 11pt;">，一般用于请求转发的多个资源中共享数据</span></div></li><li><div><span style="font-size: 11pt;">方法：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">void setAttribute(String name,Object obj):存储数据</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">Object getAttitude(String name):通过键获取值</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">void removeAttribute(String name):通过键移除键值对</span></span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(54, 101, 238);">获取ServletContext：</span></span></div></li><ol><li><div><span style="font-size: 14.6667px;">ServletContext  getServletContest()</span></div></li></ol><li><div><span style="font-size: 11pt;">BeanUtils.populate(Object,map):将map集合中的数据封装到对象中</span></div></li><ol><li><div><span style="font-size: 11pt;">JavaBean：标准的Java类</span></div></li><ol><li><div><span style="font-size: 14.6667px;">要求：</span></div></li><ol><li><div><span style="font-size: 11pt;">类必须被public修饰</span></div></li><li><div><span style="font-size: 11pt;">必须提供空参的 构造器</span></div></li><li><div><span style="font-size: 11pt;">成员变量必须使用private修饰</span></div></li><li><div><span style="font-size: 11pt;">提供公共的setter和getter方法</span></div></li></ol><li><div><span style="font-size: 11pt;"> 功能：封装数据</span></div></li></ol><li><div><span style="font-size: 14.6667px;">概念：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">成员变量：</span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">属性：setter和getter方法截取后的产物</span></span></div></li><ol><li><div><span style="font-size: 14.6667px;">例：getUsername()--&gt;Username--&gt;username</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">方法：</span></div></li><ol><li><div><span style="font-size: 11pt;">setProperty()：设置属性</span></div></li><li><div><span style="font-size: 11pt;">getProperty()：获取对象属性</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">populate(Object obj,Map map):将map集合的键值对应信息，封装到JavaBean对象中</span></span></div></li></ol></ol></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">七、http响应消息</span></div><ol><li><div><span style="font-size: 11pt;">请求消息：客户端发送给服务器端的数据</span></div></li><li><div><span style="font-size: 11pt;">响应消息：服务器端发送给客户端的数据</span></div></li><ol><li><div><span style="font-size: 11pt;">数据格式：</span></div></li><ol><li><div><span style="font-size: 11pt;">响应行</span></div></li><ol><li><div><span style="font-size: 11pt;">组成：<span style="font-size: 11pt; color: rgb(255, 0, 0);">协议/版本 响应状态码 状态码描述（HTTP/1.1 200 OK）</span></span></div></li><li><div><span style="font-size: 11pt;">响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态</span></div></li><ol><li><div><span style="font-size: 11pt;">状态码都是3位数字</span></div></li><li><div><span style="font-size: 11pt;">分类：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">2xx：成功。代表：200</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">3xx：重定向。代表：302(重定向)，304(访问缓存)</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">4xx：客户端错误</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">代表：</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">404（请求路径没有对应的资源）</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">405：请求方式没有对应的doXxx方法</span></span></div></li></ol></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(45, 79, 201);">5xx：服务器端错误。代表：500(服务器内部出现异常)</span></span></div></li></ol></ol></ol><li><div><span style="font-size: 11pt;">响应头：</span></div></li><ol><li><div><span style="font-size: 11pt;">格式：头名称： 值</span></div></li><li><div><span style="font-size: 11pt;">常见的响应头：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(77, 206, 29);">Content-Type：服务器告诉客户端本次响应体</span><span style="font-size: 11pt; color: rgb(77, 206, 29); font-weight: bold;">数据格式以及编码格式（数据类型和字符集）</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(77, 206, 29);">Content-disposition</span><span style="font-size: 11pt; color: rgb(77, 206, 29);">：服务器告诉客户端以什么格式打开响应体数据</span></span></div></li><ol><li><div><span style="font-size: 11pt;">值：</span></div></li><ol><li><div><span style="font-size: 11pt;">in-line:默认值,在当前页面内打开</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(147, 150, 0);">attachment;filename=xxx：以附件形式打开响应体。文件下载</span></span></div></li></ol></ol></ol></ol><li><div><span style="font-size: 11pt;">响应空行</span></div></li><li><div><span style="font-size: 11pt;">响应体：传输的数据</span></div></li></ol><li><div><span style="font-size: 11pt;">响应字符串格式</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>        HTTP/1.1 200 OK</div><div>        Content-Type: text/html;charset=UTF-8</div><div>        Content-Length: 101</div><div>        Date: Wed, 06 Jun 2018 07:08:42 GMT</div><div><br/></div><div>        &lt;html&gt;</div><div>          &lt;head&gt;</div><div>            &lt;title&gt;$Title$&lt;/title&gt;</div><div>          &lt;/head&gt;</div><div>          &lt;body&gt;</div><div>          hello , response</div><div>          &lt;/body&gt;</div><div>        &lt;/html&gt;</div></div><div><span style="font-size: 14pt; font-weight: bold;">八、Response对象</span></div><div><img src="Tomcat&Servlet&request&response_files/request&response对象原理.bmp" type="image/bmp" data-filename="request&response对象原理.bmp" width="1145"/></div><ul><li><div>功能：设置响应消息</div></li><ol><li><div>设置响应行</div></li><ol><li><div>格式：HTTP/1.1 200 ok</div></li><li><div>设置状态码：setStatus(int sc)</div></li></ol><li><div>设置响应头：setHeader(String name, String value)</div></li><li><div>设置响应体：</div></li><ol><li><div>使用步骤</div></li><ol><li><div><span style="color: rgb(147, 150, 0);">获取输出流</span></div></li><ol><li><div><span style="color: rgb(147, 150, 0);">字符输出流：PrintWriter getWriter()</span></div></li><li><div><span style="color: rgb(147, 150, 0);">字节输出流：ServletOutputStream getOutputStream()（继承自outputstream）</span></div></li></ol><li><div><span style="color: rgb(147, 150, 0);">使用输出流，将数据输出到客户端浏览器</span></div></li></ol></ol></ol><li><div><span style="font-size: 11pt; font-weight: bold;">重定向的方式：（资源跳转的方式）</span></div></li><ul><li><div>通过分别设置响应状态码和响应头的方式设置</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//设置状态码</div><div>response.setStatus(302);</div><div>//设置跳转路径</div><div>response.setHeader(&quot;location&quot;,&quot;/day15/responseDemo2&quot;);</div></div><ul><ul><li><div>通过sendRedirect()方式实现</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#FF0000" style="font-size: 11pt;">response.sendRedirect(&quot;/day15/responseDemo2&quot;);</font></div></div><ul><ul><li><div>重定向的特点（redirect）</div></li><ul><li><div><span style="color: rgb(255, 0, 0);">地址栏发生变化</span></div></li><li><div>重定向<span style="color: rgb(227, 0, 0);">可以访问其他站点（服务器）的资源</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">重定向是</span><span style="color: rgb(134, 0, 164); font-weight: bold;">两次请求</span><span style="color: rgb(255, 0, 0); font-weight: bold;">，不能使用request对象来共享数据</span></div></li></ul><li><div>转发的特点：（forward）</div></li><ul><li><div>转发地址栏不变</div></li><li><div>转发只能访问当前服务器下的资源</div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">转发是</span><span style="color: rgb(134, 0, 164); font-weight: bold;">一次请求，</span><span style="color: rgb(255, 0, 0); font-weight: bold;">可以使用request对象来共享数据</span></div></li></ul><li><div>路径写法：</div></li><ul><li><div>路径分类：</div></li><ol><li><div>相对路径：通过相对路径不可以确定唯一资源</div></li><ol><li><div>如：./index.html</div></li><li><div>不以/开头，以.开头路径</div></li><li><div>规则：确定的访问的当前资源和目标资源之间的相对位置关系</div></li><ol><li><div>./：当前目录</div></li><li><div>../：后退一级目录</div></li></ol></ol><li><div><span style="color: rgb(255, 0, 0);">绝对路径：通过绝对路径可以确定唯一资源</span></div></li><ul><li><div>如：http://localhost/day15/responseDemo2 ————/day15/responseDemo2</div></li><li><div>以/开头</div></li><li><div><span style="color: rgb(188, 0, 88);">规则：判断定义的路径是给谁用的，判断请求将来从哪里发出</span></div></li><ul><li><div><span style="color: rgb(188, 0, 88);">给客户端浏览器使用：需要加虚拟目录(项目访问路径)</span></div></li><ul><li><div><span style="color: rgb(188, 0, 88);">建议虚拟目录动态获取：request.getContextPath();</span></div></li></ul><li><div><span style="color: rgb(188, 0, 88);">给服务器使用：不需要加虚拟目录</span></div></li><ul><li><div><span style="color: rgb(188, 0, 88);">转发路径</span></div></li></ul></ul></ul></ol></ul></ul><li><div>案例总结：</div></li><ul><li><div>response对象在做出一次响应之后会自动被销毁，response获取的流也会被自动销毁</div></li><li><div>解决response输出中文乱码问题及原理（编码和解码不一致，获取流之前设置）</div></li><ul><li><div><span style="background-color: rgb(255, 255, 255);"><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">response.setHeader(</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">&quot;content-type&quot;</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">,</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">&quot;text/html;charset=utf-8&quot;</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">)</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">;</span></span></div></li><li><div><span style="background-color: rgb(255, 255, 255);"><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">response.setContentType(</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">&quot;text/html;charset=utf-8&quot;</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">)</span><span style="font-size: 12pt; background-color: rgb(255, 255, 255); font-family: &quot;Droid Sans Mono&quot;;">;</span></span></div></li></ul><li><div><span style="font-size: 16px; font-family: &quot;Droid Sans Mono&quot;;">字节输出流</span></div></li><ul><li><div>ServletOutputStream outputStream = response.getOutputStream();</div></li><li><div style="font-size: 12pt;"><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">outputStream.write(&quot;</span><span style="font-size: 12pt; font-family: 宋体;">你好</span><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">&quot;.getBytes(&quot;</span><span style="font-size: 12pt; color: rgb(227, 0, 0); font-family: &quot;Droid Sans Mono&quot;;">utf-8</span><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">&quot;));</span></div></li></ul></ul></ul><div><span style="font-size: 14pt; font-weight: bold;">九、ServletContext</span></div><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(188, 0, 88); font-weight: bold;">概念：代表整个web应用，可以和程序的容器（服务器）来通信                                      </span></span></div></li><li><div><span style="font-size: 11pt;">获取：</span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">通过request对象获取</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">request.getServletContext();</span></span></div></li></ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">通过HttpServlet获取</span></span></div></li><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(227, 0, 0);">this.getServletContext();</span></span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">功能：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">获取MIME类型</span></div></li><ol><li><div><span style="font-size: 11pt;">MIME类型：在互联网通信过程中定义的一种文件数据类型</span></div></li><li><div><span style="font-size: 14.6667px;">获取：String getMimeType(String file)</span></div></li></ol><li><div><span style="font-size: 14.6667px;">域对象：共享数据</span></div></li><ol><li><div><span style="font-size: 11pt;">ServletContext对象范围：所有用户所有请求的数据，作用域范围大于request域对象</span></div></li><li><div><span style="font-size: 14.6667px;">共享数据方法：</span></div></li><ol><li><div><span style="font-size: 11pt;">void setAttribute(String name,Object obj)</span></div></li><li><div><span style="font-size: 11pt;">Object getAttribute(String name);</span></div></li><li><div><span style="font-size: 11pt;">void removeAttribute(String name0;</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">获取文件的真实（服务器）路径</span></div></li><ol><li><div><span style="font-size: 14.6667px;">方法：<span style="font-size: 14.6667px; color: rgb(188, 0, 88); font-weight: bold;">String getRealPath(String s);</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">classLoader()只能获取src下真实目录文件，不能获取web项目目录的文件</span></span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">ServletContext和request域对象的区别</span></div></li><ol><li><div><span style="font-size: 11pt;">ServletContext域对象：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">是一个全局的存储信息的空间</span></div></li><li><div><span style="font-size: 14.6667px;">服务器开始就存在，服务器关闭才释放</span></div></li><li><div><span style="font-size: 14.6667px;">所有用户公用一个</span></div></li></ol><li><div><span style="font-size: 14.6667px;">request域对象</span></div></li><ol><li><div><span style="font-size: 14.6667px;">一个用户可以拥有多个</span></div></li><li><div><span style="font-size: 14.6667px;">作用范围是一次请求的范围</span></div></li></ol></ol></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 