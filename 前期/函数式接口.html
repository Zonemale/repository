<html>
<head>
  <title>函数式接口</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1694"/>
<h1>函数式接口</h1>

<div>
<span><div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">一、函数式接口</span></font></div><ul><li><div><span style="font-size: 11pt;">概念：<font style="color: rgb(255, 0, 0);"><b>有且仅有一个抽象方法的接口</b></font>，</span><span style="font-size: 11pt;">函数式接口，即适用于函数式编程场景的接口。而Java中的函数式编程体现就是Lambda，所以函数式接口就是可 以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，<span style="font-size: 11pt; color: rgb(255, 0, 0);">Java中的Lambda才能顺利地进行推导。</span></span></div></li><ul><li><div><span style="font-size: 14.6667px;">语法糖：<font style="color: rgb(118, 0, 216);">是指使用更加方便，但是原理不变的代码语法</font>。</span></div></li></ul><li><div><span style="font-size: 14.6667px;">格式：（只要确保接口中有且仅有一个抽象方法即可）</span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>修饰符 interface 接口名称{</div><div>    public abstract 返回值类型 方法名称（可选参数信息）;</div><div>    //其它非抽象方法内容</div><div>}</div></div><ul><li><div><span style="font-size: 11pt;">@FunctionalInterface注解</span></div></li><ol><li><div><span style="font-size: 14.6667px;">与@Override注解的作用类似，Java8中专门为函数式接口引入了一个新的注解：@FunctionalInterface。<font style="color: rgb(255, 0, 0);"><i>该注解可用于一个接口的定义上</i></font></span></div></li></ol></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@FunctionalInterface</div><div>public interface MyFunctionalInterface { </div><div>    void myMethod();      </div><div>}</div></div><ul><li><div><span style="font-size: 11pt;">注：一旦使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。即使不使用该注解，只要满足函数式接口的定义，这仍然是一个函数式接口。</span></div></li></ul><div><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px; font-weight: bold;">二、函数式编程</span></span></div><ol><li><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">Lambda的<font style="color: rgb(227, 0, 0);">延迟执行</font></span></font></div></li><ol><li><div><span style="font-size: 14.6667px;">有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而Lambda表达式是延迟执行的，这正好<font style="color: rgb(255, 0, 0);">可以作为解决方案，提升性能</font></span></div></li><li><div><span style="font-size: 14.6667px;">性能浪费日志案例</span></div></li><ul><li><div><span style="font-size: 11pt;">注:日志可以帮助我们快速的定位问题，记录程序运行过程中的情况，以便项目的监控和优化</span></div></li></ul></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Example2 {</div><div>    public static void method(int a,String msg){</div><div>        if(a == 1){</div><div>            System.out.println(msg);</div><div>        }</div><div>    }</div><div>    public static void main(String[] args) {</div><div>        String str1 = &quot;Hello&quot;;</div><div>        String str2 = &quot;what&quot;;</div><div>        String str3 = &quot;world&quot;;</div><div><br/></div><div>        method(1,str1 + str2 + str3);</div><div>    }</div><div>}</div><div>这段代码存在问题：无论级别是否满足要求，作为 log 方法的第二个参数，三个字符串一定会首先被拼接并传入方 法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在性能浪费</div></div><ol><ol><li><div><font style="font-size: 11px;"><span style="font-size: 11pt;">Lambda更优写法：</span></font></div></li><ol><li><div><span style="font-size: 14.6667px;">简化规则：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">针对参数：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">无参数：不能简化，必须保留小括号</span></div></li><li><div>有参数：</div></li><ol><li><div>有1个参数，可以省略数据类型和小括号</div></li><li><div>有1个以上参数，只能省略数据类型，不能省略小括号</div></li></ol></ol><li><div>针对方法体</div></li><ol><li><div>如果不止一行代码，绝对不能简化</div></li><li><div>如果只有一行代码，可以省略，省略大括号，分号和return语句，并且要省必须一起省，只能省一部分</div></li></ol></ol></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@FunctionalInterface</div><div>public interface MyInterface {</div><div>    void method();</div><div>}</div><div><br/></div><div>public class Demo {</div><div>    public static void main(String[] args) {</div><div>        String s1 = &quot;what&quot;;</div><div>        String s2 = &quot;is&quot;;</div><div>        String s3 = &quot;fuck&quot;;</div><div><br/></div><div>        mainMethod(1,() -&gt; System.out.println(s1 + s2 + s3));</div><div><br/></div><div>    }</div><div><br/></div><div>    public static void mainMethod(int flag, MyInterface face){</div><div>        if(flag == 1){</div><div>            face.method();</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div>注：实际上使用内部类也可以达到同样的效果，只是将代码操作延迟到了另一个对象当中通过调用方法来完成，而是否调用其所在方法是在条件判断之后才执行的</div></div><ol><ol><li><div><span style="font-size: 11pt;">使用Lambda作为参数和返回值</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>使用Lambda表达式作为方法参数，其实就是使用函数式 接口作为方法参数。</div><div>public class Example4 {</div><div>    public static void main(String[] args) {</div><div>        method(() -&gt; System.out.println(&quot;waht&quot;));</div><div>    }</div><div><br/></div><div>    public static void method(Runnable run){</div><div>        new Thread().start();</div><div>    }</div><div>}</div><div><br/></div><div>方法的返回值类型是一个函数式接口</div><div>public class Example6 {</div><div>    public static void main(String[] args) {</div><div>        String[] array = {&quot;abc&quot;,&quot;abcde&quot;,&quot;ecdbafs&quot;};</div><div>        System.out.println(Arrays.toString(array));</div><div>        Arrays.sort(array,newComparator());</div><div>        System.out.println(Arrays.toString(array));</div><div>    }</div><div><br/></div><div>    public static Comparator&lt;String&gt; newComparator(){</div><div>        return (a,b) -&gt; b.length() - a.length();</div><div>    }</div><div>}</div></div><div><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px; font-weight: bold;">三、常用函数式接口</span></span></div><ul><li><div><span style="font-weight: bold;">Supplier接口</span></div></li><ul><li><div>java.util.function.Supplier&lt;T&gt; 接口仅包含一个无参的方法：</div></li><li><div><b>T get()</b> 。<span style="font-size: 11pt; font-weight: bold; color: rgb(255, 0, 0);">用来获取一个泛型参数指定类型的对象数据</span><span style="font-size: 11pt;">，</span>由于这是一个函数式接口，这也就意味着对应的Lambda表达式需要“对外提供”一个符合泛型类型的对象 数据。</div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Example7 {</div><div>    public static void main(String[] args) {</div><div>        String s = getString(() -&gt; {</div><div>            return &quot;Supplier&lt;T&gt;接口是用来获取泛型参数获取指定类型的参数&quot;;</div><div>        });</div><div><br/></div><div>        System.out.println(s);</div><div>    }</div><div><br/></div><div>    public static String getString(Supplier&lt;String&gt; sup){</div><div>        return sup.get();</div><div>    }</div><div>}</div></div><ul><li><div><span style="font-weight: bold;">Consumer接口</span></div></li><ul><li><div>java.util.function.Consumer&lt;T&gt; 接口则正好与Supplier接口相反，它不是生产一个数据，而是消费一个数据， 其数据类型由泛型决定。（消费也可以理解为使用，需要自定义消费方式）</div></li><li><div>Consumer 接口中包含抽象方法 <span style="font-weight: bold; font-size: 11pt;">void accept(T t)</span> ，意为消费一个指定泛型的数据。</div></li><li><div>面试题</div></li><ul><li><div>ArrayList和Vector</div></li><li><div>HashMap和Hashtable</div></li><li><div>StringBuilder和StringBuffer:StringBuilder是线程不同步的单线程，没有同步锁效率高，StringBuffer是线程安全的，线程同步的，加了同步锁，效率低</div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Example9 {</div><div>    public static void main(String[] args) {</div><div>        method(s -&gt; System.out.println(s));</div><div>    }</div><div><br/></div><div>    public static void method(Consumer&lt;String&gt; s){</div><div>        s.accept(&quot;没你根本不重要&quot;);</div><div>    }</div><div>}</div></div><ul><ul><li><div><span style="font-size: 11pt;">消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合。而这个方法就是 Consumer 接口中的default方法</span> <span style="font-size: 11pt; font-weight: bold;">andThen，</span><span style="font-size: 11pt;">该方法参数是一个Consumer接口，返回</span><span style="font-size: 11pt; font-weight: bold;">调用该方法的接口</span><span style="font-size: 11pt;">和</span><span style="font-size: 11pt; font-weight: bold;">参数接口</span><span style="font-size: 11pt;">两个Consumer接口的组合</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 11pt;">public class Example11 {</font></div><div><font style="font-size: 11pt;">    public static void main(String[] args) {</font></div><div><font style="font-size: 11pt;">        method(&quot;时针一直倒数着&quot;,</font></div><div><font style="font-size: 11pt;">                (t) -&gt; {</font></div><div><font style="font-size: 11pt;">                    System.out.println(t);</font></div><div><font style="font-size: 11pt;">                },</font></div><div><font style="font-size: 11pt;">                (t) -&gt; {</font></div><div><font style="font-size: 11pt;">                    String res = new StringBuilder(t).reverse().toString();</font></div><div><font style="font-size: 11pt;">                    System.out.println(res);</font></div><div><font style="font-size: 11pt;">                }</font></div><div><font style="font-size: 11pt;">                );</font></div><div><font style="font-size: 11pt;">    }</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">    public static void method(String s, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2){</font></div><div><font style="font-size: 11pt;">        con1.andThen(con2).accept(s);//con1在前边，所以先执行cong1的方法后执行con2的方法</font></div><div><font style="font-size: 11pt;">    }</font></div><div><font style="font-size: 11pt;">}</font></div></div><div><br/></div><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">Predicate接口</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><font style="color: rgb(255, 0, 0);">有时候我们需要对某种类型的数据进行判断，从而得到一个boolean值结果</font>。</span></div></li><li><div><span style="font-size: 11pt;">Predicate 接口中包含一个抽象方法： boolean test(T t) 。用于条件判断的场景</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Example13 {</div><div>    public static void main(String[] args) {</div><div>        boolean flag = method(&quot;HelloWorld&quot;,(str) -&gt; {</div><div>            return str.length() &gt; 5 ? true : false;</div><div>        });</div><div>        System.out.println(&quot;字符串很长吗？&quot; + flag);</div><div>    }</div><div><br/></div><div>    public static boolean method(String str, Predicate&lt;String&gt; predicate){</div><div>        boolean varyLong = predicate.test(str);</div><div>        return varyLong;</div><div>    }</div><div>}</div></div><ul><ul><li><div><span style="font-size: 11pt;">默认方法：and,</span><span style="font-size: 11pt;">既然是条件判断，就会存在与、或、非三种常见的逻辑关系。其中将两个 Predicate 条件使用“与”逻辑连接起来实 现“并且”的效果时，可以使用default方法 and</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 11pt;">public class Example14 {</span></div><div><span style="font-size: 11pt;">    public static void main(String[] args) {</span></div><div><span style="font-size: 11pt;">        method((str) -&gt; {return str.contains(&quot;s&quot;);},(str) -&gt; {return str.contains(&quot;b&quot;);},&quot;sfdiuhgjjgldsjab&quot;);</span></div><div><span style="font-size: 11pt;">    }</span></div><div><br/></div><div><span style="font-size: 11pt;">    public static void method(Predicate&lt;String&gt; p1, Predicate&lt;String&gt; p2, String str){</span></div><div><span style="font-size: 11pt;">        boolean what = p1.and(p2).test(str);</span></div><div><span style="font-size: 11pt;">        System.out.println(&quot;什么话都别说&quot; + what);</span></div><div><span style="font-size: 11pt;">    }</span></div><div><span style="font-size: 11pt;">}</span></div></div><div><br/></div><ul><ul><li><div><span style="font-size: 11pt;">默认方法：or，</span><span style="font-size: 11pt;">与 and 的“与”类似，默认方法 or 实现逻辑关系中的“或”。</span></div></li><li><div><span style="font-size: 14.6667px;">默认方法：negate</span><span style="font-size: 11pt;">“与”、“或”已经了解了，剩下的“非”（取反）也会简单。</span></div></li></ul></ul><div><span style="font-size: 18.6667px;"><span style="font-size: 18.6667px; font-weight: bold;">四、Function接口</span></span></div><ul><li><div><span style="font-size: 11pt;">概述：</span><span style="font-size: 11pt;">java.util.function.Function&lt;<font style="color: rgb(255, 0, 0);">T,R</font>&gt; 接口用来</span><span style="font-size: 11pt; font-weight: bold;">根据一个类型的数据得到另一个类型的数据</span><span style="font-size: 11pt;">，前者称为前置条件， 后者称为后置条件。(Function的前置条件泛型和后置条件泛型可以相同）</span></div></li><li><div><span style="font-size: 14.6667px;">抽象方法：apply，   </span><span style="font-size: 11pt;">Function 接口中主要的抽象方法为： R apply(T t) ，根据类型<font style="color: rgb(255, 0, 0);">T的参数获取类型R的结果。</font></span></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class Example15 {</div><div>    public static void main(String[] args) {</div><div>        change(&quot;12421&quot;,(String s) -&gt; {</div><div>            return Integer.parseInt(s);</div><div>        });</div><div>    }</div><div><br/></div><div>    public static void change(String str, Function&lt;String,Integer&gt; fun){</div><div>        Integer temp = fun.apply(str);</div><div>        System.out.println(temp);</div><div>    }</div><div>}</div></div><ul><li><div><span style="font-size: 11pt;">默认方法：andThen,</span><span style="font-size: 11pt;">Function 接口中有一个默认的 andThen 方法，用来进行组合操作</span></div></li><li><div><br/></div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 9pt;">public class Example16 {</font></div><div><font style="font-size: 9pt;">    public static void main(String[] args) {</font></div><div><font style="font-size: 9pt;">        change((str) -&gt; {</font></div><div><font style="font-size: 9pt;">            ArrayList&lt;Character&gt; chList = new ArrayList&lt;&gt;();</font></div><div><font style="font-size: 9pt;">                    for (char en : str.toCharArray()) {</font></div><div><font style="font-size: 9pt;">                        chList.add(en);</font></div><div><font style="font-size: 9pt;">                    }</font></div><div><font style="font-size: 9pt;">                    return chList;</font></div><div><font style="font-size: 9pt;">        },</font></div><div><font style="font-size: 9pt;">                (ArrayList&lt;Character&gt; list) -&gt; {</font></div><div><font style="font-size: 9pt;">            int sum = 0;</font></div><div><font style="font-size: 9pt;">                    for (Character ch : list) {</font></div><div><font style="font-size: 9pt;">                        sum += (int)ch;</font></div><div><font style="font-size: 9pt;">                    }</font></div><div><font style="font-size: 9pt;">                    return sum;</font></div><div><font style="font-size: 9pt;">                });</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;"><br/></font></div><div><font style="font-size: 9pt;">    public static void change(Function&lt;String,ArrayList&lt;Character&gt;&gt; one, Function&lt;ArrayList&lt;Character&gt;,Integer&gt; two){</font></div><div><font style="font-size: 9pt;">        int res = one.andThen(two).apply(&quot;what\'s up&quot;);</font></div><div><font style="font-size: 9pt;">        System.out.println(res);</font></div><div><font style="font-size: 9pt;">    }</font></div><div><font style="font-size: 9pt;">}</font></div><div><font color="#FF0000" style="font-size: 14pt;"><b><br/></b></font></div><div><font color="#FF0000"><b>fun1.andThen(fun2).andThen(fun3).apply(s);-----&gt;将s先传给fun1，然后将fun1的结果交给fun2，fun2处理后交给fun3处理</b></font></div></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 