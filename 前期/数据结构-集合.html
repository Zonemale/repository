<html>
<head>
  <title>数据结构-集合</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="529"/>
<h1>数据结构-集合</h1>

<div>
<span><div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"> 一、数据结构（</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数据存储的常用结构有：栈、队列、数组、链表和红黑树。</span></span><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">）</span></font></div><ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">栈（Stack）——先进后出</span></span></div></li><ol><li><div><span style="font-size: 11pt;">又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作，不允许在其 他任何位置进行添加、查找、删除等操作。</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">队列（queue）——先进先出</span></span></div></li><ol><li><div><span style="font-size: 11pt;">简称队，它同堆栈一样，也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入， 而在表的另一端进行删除。</span></div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">数组数据结构（查询快，增删慢） </span></span></div></li><ol><li><div><span style="font-size: 14.6667px;">概念：</span><span style="font-size: 11pt;">数组:Array,是有序的元素序列，数组是在内存中开辟一段连续的空间，并在此空间存放元素。就像是一排出 租屋，有100个房间，从001到100每个房间都有固定编号，通过编号就可以快速找到租房子的人。</span></div></li></ol></ol><div><span style="font-size: 11pt;"><img src="数据结构-集合_files/02_数据结构_数组.bmp" type="image/bmp" data-filename="02_数据结构_数组.bmp"/></span></div><div><span style="font-size: 11pt;">            4. 例如ArrayList类和Vector类</span></div><div><span style="font-size: 11pt;">      <span style="font-size: 11pt; font-weight: bold;">4.  链表（查询慢，增删快</span></span><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">）</span></span></div><ol><ol><li><div><span style="font-size: 14.6667px;">概念：</span><span style="font-size: 11pt;">由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时i动态生成。每 个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。我们常说的 链表结构有单向链表与双向链表，那么这里给大家介绍的是单向链表。</span></div></li><li><div><span style="font-size: 11pt; font-weight: bold;">查询慢，增删快</span></div></li><ul><li><div><span style="font-size: 14.6667px;">查询慢：链表中的地址不是连续的，每次查询元素，都必须从头开始</span></div></li><li><div><span style="font-size: 14.6667px;">链表结构，增加/删除一个元素，对链表的整体结构没有影响，所以增删快</span></div></li></ul></ol></ol><div><span style="font-size: 11pt;"><img src="数据结构-集合_files/03_数据结构_链表.bmp" type="image/bmp" data-filename="03_数据结构_链表.bmp"/></span></div><div><span style="font-size: 11pt;">                3.例如：LinkedList类和HashSet类</span></div><div><span style="font-size: 11pt;">      <span style="font-size: 11pt; font-weight: bold;">5. 红黑树结构</span></span></div><ol><ol><li><div><span style="font-size: 11pt;">二叉树：binary tree ,是每个结点不超过2的有序树（tree）</span></div></li><ul><li><div><span style="font-size: 14.6667px;">概念：</span><span style="font-size: 11pt;">简单的理解，就是一种类似于我们生活中树的结构，只不过每个结点上都多</span><span style="font-size: 11pt; font-weight: bold;">只能有两个子结点</span><span style="font-size: 11pt;">。</span><span style="font-size: 11pt;">二叉树是每个节点多有两个子树的树结构。顶上的叫根结点，两边被称作“左子树”和“右子树”。</span></div></li></ul><li><div><span style="font-size: 14.6667px;">排序树：</span><span style="font-size: 14.6667px;">在二叉树的基础上，元素是有大小顺序的，左子树小，右子树大</span></div></li></ol><ol><li><div><span style="font-size: 14.6667px;">平衡树：左子树数量等于右子树数量，与之对应的是不平衡树</span></div></li><li><div><span style="font-size: 14.6667px;">红黑树</span></div></li><ol><li><div><span style="font-size: 11pt;">红黑树本身就是一颗二叉查找树，将节点插入后，该树仍然 是一颗二叉查找树。也就意味着，树的键值仍然是有序的。</span></div></li><li><div><span style="font-size: 14.6667px;">红黑树的约束：</span></div></li><ul><li><div><span style="font-size: 14.6667px;">节点可以是红色的或者是黑色的</span></div></li><li><div><span style="font-size: 14.6667px;">根节点是黑色的</span></div></li><li><div><span style="font-size: 14.6667px;">叶子节点（特指空节点）是黑色的</span></div></li><li><div><span style="font-size: 14.6667px;">每个红色节点的子节点都是黑色的</span></div></li><li><div><span style="font-size: 14.6667px;">任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</span></div></li></ul><li><div><span style="font-size: 14.6667px;">特点：速度特别快，趋紧平衡树，查找叶子元素最少和最多次数不多于二倍</span></div></li></ol></ol></ol><div><span style="font-size: 11pt;"><img src="数据结构-集合_files/04_数据结构_红黑树.bmp" type="image/bmp" data-filename="04_数据结构_红黑树.bmp"/></span></div><div><span style="font-size: 12pt; font-weight: bold;">十五、Collection集合</span></div><ol><li><div><span style="font-size: 11pt;">概念：集合是Java中提供的一种容器，可以用来存储多个数据</span></div></li><li><div><span style="font-size: 11pt;">与数组的区别</span></div></li><ul><li><div><span style="font-size: 11pt;">数组的长度是固定的，集合的长度是可变的</span></div></li><li><div><span style="font-size: 11pt;">数组中存储的是同一类型的元素，可以存储基本数据类型值，集合存储的都是对象，而且对象的类型可以不一致，在开发中一般当对象多的时候，使用到集合进行存储</span></div></li></ul><li><div><span style="font-size: 11pt;">集合框架</span></div></li></ol><div><img src="数据结构-集合_files/01_集合框架介绍.bmp" type="image/bmp" data-filename="01_集合框架介绍.bmp" width="1252"/></div><ol><li><div><span style="font-size: 11pt;">Collection常用功能</span></div></li><ul><li><div><span style="font-size: 11pt;">public boolean add(E e)`：  把给定的对象添加到当前集合中 。</span></div></li><li><div><span style="font-size: 11pt;">public void clear()` :清空集合中所有的元素。</span></div></li><li><div><span style="font-size: 11pt;">public boolean remove(E e)`: 把给定的对象在当前集合中删除。</span></div></li><li><div><span style="font-size: 11pt;">public boolean contains(E e)`: 判断当前集合中是否包含给定的对象。</span></div></li><li><div><span style="font-size: 11pt;">public boolean isEmpty()`: 判断当前集合是否为空。</span></div></li><li><div><span style="font-size: 11pt;">public int size()`: 返回集合中元素的个数。</span></div></li><li><div><span style="font-size: 11pt;">public Object[] toArray()`: 把集合中的元素，存储到数组中。</span></div></li></ul></ol><div><span style="font-size: 12pt; font-weight: bold;">十六、Interator迭代器（java.util.Iterator）</span></div><ol><li><div><span style="font-size: 11pt;">迭代：</span><span style="font-size: 11pt; font-weight: bold;">即Collection集合元素的通用获取方式</span><span style="font-size: 11pt;">。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。</span></div></li><li><div><span style="font-size: 11pt;">常用方法</span></div></li></ol><div><span style="font-size: 11pt;">             boolean  </span><a href="mk:java/util/Iterator.html#hasNext()" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">hasNext</a><span style="font-size: 11pt;">() 如果仍有元素可以迭代，则返回 true。</span></div><div><span style="font-size: 11pt;">             </span><a href="mk:java/util/Iterator.html" style="font-size: 11pt; color: rgb(255, 0, 0);" title="Iterator 中的类型参数">E</a><span style="font-size: 11pt;">   </span><a href="mk:java/util/Iterator.html#next()" style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">next</a><span style="font-size: 11pt;">() 返回迭代的下一个元素。</span></div><div><span style="font-size: 11pt;">      3. Iterator迭代器，是一个接口，我们无法直接使用，需要使用Iterator接口的实现类对象</span></div><div><span style="font-size: 11pt;">            Collection接口中有一个方法，叫iterator()，这个方法返回的就是迭代器的实现类对象</span></div><div><span style="font-size: 11pt;">            Iterator&lt;E&gt; iterator() 返回在此collection的元素上进行迭代的迭代器</span></div><div><span style="font-size: 11pt;">      4.迭代器的使用步骤</span></div><ol><ol><li><div><span style="font-size: 11pt;">使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收（多态）</span></div></li><ul><li><div><span style="font-size: 11pt;">注意：Iterator&lt;E&gt;接口也是有泛型的，迭代器的泛型跟着集合走，集合是什么泛型，迭代器就是什么泛型</span></div></li></ul><li><div><span style="font-size: 11pt;">使用Iterator接口中的方法 hasNext判断还有没有下一个元素</span></div></li><li><div><span style="font-size: 11pt;">使用Iterator接口中的方法next取出集合中的下一个元素</span></div></li><ul><li><div><span style="font-size: 11pt;">没有元素，在取出元素抛出NoSuchElementException没有元素异常</span></div></li></ul></ol></ol><div><img src="数据结构-集合_files/02_迭代器的实现原理(1).bmp" type="image/bmp" data-filename="02_迭代器的实现原理(1).bmp"/></div><div>        5<span style="font-size: 11pt;">.增强for（</span><span style="font-size: 11pt; color: rgb(235, 0, 115); font-weight: bold;">只能遍历单列集合</span><span style="font-size: 11pt;">）</span></div><ol><ol><li><div><span style="font-size: 11pt;">增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</span></div></li><li><div><span style="font-size: 11pt;">格式：</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 10pt;">for(元素的数据类型  变量:</span><span style="font-size: 10pt; color: rgb(255, 70, 53); font-weight: bold;">collection集合or数组</span><span style="font-size: 10pt;">){</span></div><div><span style="font-size: 10pt;">    //写操作代码</span></div><div><span style="font-size: 10pt;">}</span></div></div><div>                 3.<span style="font-size: 11pt;"> 注意事项：</span></div><ul><ul><ul><li><div><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">底层使用的也是迭代器</span></div></li><li><div><span style="font-size: 11pt;">新for循环必须有被遍历的目标。</span></div></li><li><div><span style="font-size: 11pt;">目标只能是Collection或者数组（单列集合）</span></div></li><li><div><span style="font-size: 11pt;">新式for仅仅作为遍历使用</span></div></li><li><div><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">遍历时不能添加或删除</span></div></li></ul></ul></ul><div><span style="font-size: 12pt; font-weight: bold;">十七、泛型</span></div><ol><li><div>概念：</div></li></ol><div><img src="数据结构-集合_files/03_泛型的概念.bmp" type="image/bmp" data-filename="03_泛型的概念.bmp" width="951"/></div><ol><li><div><span style="font-size: 11pt;">创建集合对象，不使用泛型</span></div></li><ol><li><div><span style="font-size: 11pt;">好处：集合不使用泛型，默认的类型就是Object类型，可以存储任意类型的数据</span></div></li><li><div><span style="font-size: 11pt;">弊端：不安全，会引发异常</span></div></li></ol><li><div><span style="font-size: 11pt;">创建集合对象，使用泛型</span></div></li><ol><li><div><span style="font-size: 11pt;">好处：</span></div></li><ul><li><div><span style="font-size: 11pt;">避免了类型转换的麻烦，存储的是什么类型，取出的就是什么类型</span></div></li><li><div><span style="font-size: 11pt;">把运行期异常（代码运行之后会抛出异常），提升到了编译器</span></div></li></ul><li><div><span style="font-size: 11pt;">弊端</span></div></li><ul><li><div><span style="font-size: 11pt;">泛型是什么类型，就只能存储什么类型</span></div></li></ul></ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">含有泛型的类</span></span></div></li><ol><li><div><span style="font-size: 11pt;">格式：</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 10pt;">修饰符 class 类名&lt;代表泛型的变量&gt; {  }</span></div><div><br/></div><div><span style="font-size: 10pt;">示例：</span></div><div><span style="font-size: 10pt;">public class Person</span><span style="font-size: 10pt; color: rgb(255, 0, 0);">&lt;E&gt;</span> <span style="font-size: 10pt;">{</span></div><div><span style="font-size: 10pt;">    private</span> <span style="font-size: 10pt; color: rgb(255, 0, 0);">E</span> <span style="font-size: 10pt;">name;</span></div><div><br/></div><div><span style="font-size: 10pt;">    public</span> <span style="font-size: 10pt; color: rgb(255, 0, 0);">E</span> <span style="font-size: 10pt;">getName() {</span></div><div><span style="font-size: 10pt;">        return name;</span></div><div><span style="font-size: 10pt;">    }</span></div><div><br/></div><div><span style="font-size: 10pt;">    public void setName(</span><span style="font-size: 10pt; color: rgb(255, 0, 0);">E</span> <span style="font-size: 10pt;">name) {</span></div><div><span style="font-size: 10pt;">        this.name = name;</span></div><div><span style="font-size: 10pt;">    }</span></div><div><span style="font-size: 10pt;">}</span></div></div><div>       <span style="font-size: 11pt; font-weight: bold;">4. 含有泛型的方法</span></div><ol><ol><li><div><span style="font-size: 11pt;">格式：</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">泛型定义在方法的修饰符和返回值类型之间</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 10pt;">修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数（参数使用泛型）){  }</span></div><div><br/></div><div><span style="font-size: 10pt;">示例：</span></div><div><span style="font-size: 10pt;">public</span> <span style="font-size: 10pt; color: rgb(255, 0, 0);">&lt;E&gt;</span> <span style="font-size: 10pt;">void method1(E name){</span></div><div><span style="font-size: 10pt;">    System.out.println(name);</span></div><div><span style="font-size: 10pt;">}</span></div><div><br/></div><div><span style="font-size: 10pt;">public static</span> <span style="font-size: 10pt; color: rgb(255, 0, 0);">&lt;S&gt;</span> <span style="font-size: 10pt;">void method2(S str){</span></div><div><span style="font-size: 10pt;">    System.out.println(str);</span></div><div><span style="font-size: 10pt;">}</span></div></div><div>                <span style="font-size: 11pt;">  2. 含有泛型的方法，在调用方法的时候确定泛型的数据类型，传递什么类型的参数，泛型就是什么类型</span></div><ul><li><div><span style="font-size: 14.6667px;">个人心得：</span></div></li><ul><li><div><span style="font-size: 14.6667px;">在方法中使用泛型的时候，凡是能用到变量类型的地方都可以使用泛型，包括返回值类型，参数类型等</span></div></li><li><div><span style="font-size: 14.6667px;">但是泛型在使用该方法的时候就已经被定义好了，所以返回值必须和参数的泛型一致</span></div></li><li><div><span style="font-size: 14.6667px;">问题：</span></div></li><ul><li><div><span style="font-size: 14.6667px;">修饰符和返回值类型之间的泛型字母什么作用</span></div></li><li><div><span style="font-size: 14.6667px;">返回值类型为什么必须和参数类型一致（因为返回值类型无法确定？）</span></div></li></ul></ul></ul><div><span style="font-size: 11pt;">     </span> <span style="font-size: 11pt; font-weight: bold;"> 5. 含有泛型的接口</span></div><ol><ol><li><div><span style="font-size: 11pt;">格式：</span></div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 10pt;">修饰符 interface接口名&lt;代表泛型的变量&gt; {  }</span></div></div><div>                 <span style="font-size: 11pt;">2. 实现方式</span></div><ul><ul><ul><li><div><span style="font-size: 11pt;">方式一：定义接口的实现类，实现接口</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 10pt;">public interface Inter&lt;I&gt; {</span></div><div><span style="font-size: 10pt;">    public abstract void method(I i);</span></div><div><span style="font-size: 10pt;">}</span></div><div><br/></div><div><span style="font-size: 10pt;">GenericInterFAceImpl实现了Inter接口，并且指定泛型为String，所以重写next方法泛型默认就是String</span></div><div><span style="font-size: 10pt;">public class GenericInterfaceImpl implements Inter&lt;String&gt; {</span></div><div><br/></div><div><span style="font-size: 10pt;">    @Override</span></div><div><span style="font-size: 10pt;">    public void method(String str) {</span></div><div><br/></div><div><span style="font-size: 10pt;">    }</span></div><div><span style="font-size: 10pt;">}</span></div><div><br/></div></div><ul><ul><ul><li><div><span style="font-size: 11pt;">方式二：接口使用什么泛型，实现类就使用什么泛型，类跟着接口走</span></div></li></ul></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 10pt;">public interface Inter&lt;I&gt; {</span></div><div><span style="font-size: 10pt;">    public abstract void method(I i);</span></div><div><span style="font-size: 10pt;">}</span></div><div><br/></div><div><br/></div><div><span style="font-size: 10pt;">public class GenericInterfaceImpl2&lt;I&gt; implements Inter&lt;I&gt; {</span></div><div><span style="font-size: 10pt;">    @Override</span></div><div><span style="font-size: 10pt;">    public void method(I i) {</span></div><div><span style="font-size: 10pt;">        System.out.println(i);</span></div><div><span style="font-size: 10pt;">    }</span></div><div><span style="font-size: 10pt;">}</span></div></div><div>       <span style="font-size: 11pt; font-weight: bold;">6. 泛型通配符 </span></div><ol><ol><li><div><span style="font-size: 11pt;">不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。此时只能接受数据,不能往该集合中存储数据。</span></div></li><li><div><span style="font-size: 11pt;">注意：</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">泛型没有继承的概念</span><span style="font-size: 11pt;">。当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符&lt;?&gt;表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 </span></div></li><li><div><span style="font-size: 11pt;">使用方式：</span></div></li><ul><li><div><span style="font-size: 11pt;">不能创建对象使用，只能作为方法的参数使用 </span></div></li></ul><li><div><span style="font-size: 11pt;">通配符高级使用----</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">受限泛型</span></div></li><ol><li><div><span style="font-size: 11pt; color: rgb(255, 70, 53);">泛型的上限：</span></div></li><ul><li><div><span style="font-size: 11pt; color: rgb(255, 70, 53);">格式：类型名称 &lt;? extends 类 &gt; 对象名称</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 70, 53);">意义：只能接收该类型及其子类型</span></div></li></ul><li><div><span style="font-size: 11pt; color: rgb(255, 70, 53);">泛型的下限</span></div></li><ul><li><div><span style="font-size: 11pt; color: rgb(255, 70, 53);">格式：类型名称 &lt;? super 类 &gt; 对象名称</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 70, 53);">意义：只能接收该类型及其父类型</span></div></li></ul></ol></ol></ol><div><span style="font-size: 11pt;">            比如：TreeSet类</span></div><div><span style="font-size: 11pt;">      <span style="font-size: 11pt; font-weight: bold;">6.  List集合（java.util.list  extends  Collection）</span></span></div><ol><ol><li><div><span style="font-size: 14.6667px;">特点：</span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">它是一个元素存取有序的集合</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）</span></span></div></li><ul><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素</span></span></div></li></ul></ul><li><div><span style="font-size: 14.6667px;">常用方法</span></div></li><ul><li><div><span style="font-size: 11pt;">public void add(int index, E element) : 将指定的元素，添加到该集合中的指定位置上。</span></div></li><li><div><span style="font-size: 11pt;">public E get(int index) :返回集合中指定位置的元素</span></div></li><li><div><span style="font-size: 11pt;">public E remove(int index) : 移除列表中指定位置的元素, 返回的是被移除的元素。</span></div></li><li><div><span style="font-size: 11pt;">public E set(int index, E element) :用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span></div></li></ul></ol></ol><div><span style="font-size: 11pt;">    <span style="font-size: 11pt; font-weight: bold;">   7.  List的子类</span></span></div><ol><ol><li><div><font style="font-size: 10pt;"><span style="font-size: 10pt; font-weight: bold;">ArrayList集合（不是同步的，即多线程，查询快，增删慢）</span></font></div></li><ul><li><div><span style="font-size: 11pt;">java.util.ArrayList 集合数据存储的结构是</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">数组结构。</span><span style="font-size: 11pt;">元素增删慢，查找快，由于日常开发中使用多的功能为 查询数据、遍历数据，所以 ArrayList 是常用的集合。</span></div></li></ul><li><div><span style="font-weight: bold;">LinkedList集合（链表实现，不是同步的，查询慢，增删快）</span></div></li><ol><li><div>java.util.LinkedList 集合数据存储的结构是<span style="font-size: 11pt; color: rgb(255, 70, 53); font-weight: bold;">链表结构</span>。方便元素添加、删除的集合，</div></li><li><div>LinkedList提供的方法（<span style="color: rgb(255, 0, 0); font-weight: bold;">不能使用多态</span>）</div></li><ul><li><div>public void addFirst(E e) :将指定元素插入此列表的开头。</div></li><li><div>public void addLast(E e) :将指定元素添加到此列表的结尾。</div></li><li><div>public E getFirst() :返回此列表的第一个元素。</div></li><li><div>public E getLast() :返回此列表的后一个元素。</div></li><li><div>public E removeFirst() :移除并返回此列表的第一个元素。</div></li><li><div>public E removeLast() :移除并返回此列表的后一个元素。</div></li><li><div>public E pop() :从此列表所表示的堆栈处弹出一个元素。</div></li><li><div>public void push(E e) :将元素推入此列表所表示的堆栈。</div></li><li><div>public boolean isEmpty() ：如果列表不包含元素，则返回true。</div></li></ul><li><div>如果没有元素进行查询，则会报NoSuchElementException异常</div></li></ol><li><div><span style="font-weight: bold;">Vector（单例集合）</span></div></li><ul><li><div>可以实现可增长的对象数组，与新collection不同，vector是同步的，线程安全</div></li><li><div>底层是数组</div></li><li><div>面试题；</div></li><ul><li><div>ArrayList和Vector的区别</div></li><ul><li><div>相同点：都是数组实现，增删慢，查询快，JDK1.2之后都实现了List接口，有序，有索引，可以重复</div></li><li><div>不同点：</div></li><ul><li><div>ArrayList是线程不同步的，效率高。Vector是线程同步的</div></li><li><div>ArrayList从1.2开始出现的，Vector是jdk1.0出现</div></li><li><div>ArrayList方法命名更加规范</div></li></ul></ul><li><div>枚举Enumeration和迭代器的区别</div></li><ul><li><div>迭代器允许调用者移除元素，比枚举多了一个remove方法</div></li><li><div>方法名称得到了改进</div></li></ul></ul></ul></ol></ol><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">     8. Set接口（java.util.Set  extends Collection）</span></div><ol><ol><ol><li><div>特点</div></li><ul><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">不允许存储重复的元素</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">没有索引，没有带索引的方法，也不能使用普通的for循环遍历</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">存取元素没有顺序</span></div></li></ul><li><div>HashSet实现类（此实现不是同步的）</div></li><ol><li><div>特点：</div></li><ul><li><div>不允许存储重复的元素</div></li><li><div>没有索引，没有带索引的方法，也不能使用普通的for循环遍历</div></li><li><div>是一个无序集合，存储元素和取出元素的顺序有可能不一致</div></li><li><div>底层是一个哈希表结构（查询速度非常快）</div></li></ul><li><div><span style="font-size: 11pt; font-weight: bold;">哈希值</span>：是一个<span style="color: rgb(65, 173, 28); font-weight: bold;">十进制的整数</span>，由<span style="color: rgb(255, 0, 0); font-style: italic; font-weight: bold;">系统随机给出</span>（<span style="color: rgb(166, 0, 196);">就是对象的地址值，是一个</span><span style="color: rgb(227, 0, 0); font-weight: bold;">逻辑地址</span><span style="color: rgb(166, 0, 196);">，是模拟出来的地址，不是数据实际存储的物理地址</span>）</div></li><ul><li><div>Object类里有一个获取哈希值的方法：public  native  int  hashCode();</div></li><li><div>native:代表该方法调用的是本地操作系统的方法</div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">相同的对象哈希值一定是相同的，不同的对象哈希值不一定不同</span></div></li></ul><li><div><span style="font-size: 11pt; font-weight: bold;">哈希表：</span><span style="font-weight: bold; color: rgb(255, 0, 0);">数组 + 链表/红黑树</span></div></li><ul><li><div>在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。 但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。而JDK1.8中，哈 希表存储采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找 时间。</div></li></ul></ol></ol></ol></ol><div><img src="数据结构-集合_files/05_HashSet集合存储数据的结构（哈希表）.bmp" type="image/bmp" data-filename="05_HashSet集合存储数据的结构（哈希表）.bmp"/></div><div><br/></div><div><span style="font-size: 11pt;">              </span> <span style="font-size: 12pt; font-weight: bold;">         3.  Set集合不允许存储重复元素的原理</span></div><ul><ul><ul><ul><li><div><span style="font-size: 14.6667px;">会调用hashCode（）方法和equals方法进行比较两个对象</span></div></li><li><div><span style="font-size: 14.6667px;">如果不重写这两个方法，就会通过==进行比较两个对象，比较的是地址值</span></div></li></ul></ul></ul></ul><div><span style="font-size: 11pt;"><img src="数据结构-集合_files/06_Set集合存储元素不重复的原理.bmp" type="image/bmp" data-filename="06_Set集合存储元素不重复的原理.bmp" width="1290"/></span></div><div><span style="font-size: 11pt;"><img src="数据结构-集合_files/ScreenClip.png" type="image/png" data-filename="ScreenClip.png"/></span></div><div><span style="font-size: 11pt;">           </span> <span style="font-size: 11pt; font-weight: bold;">   </span><span style="font-size: 11pt; font-weight: bold;">5</span><span style="font-size: 11pt; font-weight: bold;">. LinkedHashSet集合（</span><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">java.util.LinkedHashSet</span></span> <span style="font-size: 11pt; font-weight: bold;">）</span></div><ol><ol><ol><li><div><span style="font-size: 11pt;">它是链表和哈希表组合的一个数据存储结构。底层是一个哈希表（数组 + 链表/红黑树）：多了一条链表（记录元素的存储顺序），<span style="font-size: 11pt; color: rgb(255, 0, 0); font-style: italic; font-weight: bold;">保证元素有序</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-style: italic; font-weight: bold;"> </span><span style="font-size: 11pt; font-style: italic;">除了有序之外，其它都和其父类（HashSet）一样</span></span></div></li></ol></ol></ol><div><span style="font-size: 11pt;">               <span style="font-size: 11pt; font-weight: bold;">6. 可变参数</span></span></div><ol><ol><ol><li><div><span style="font-size: 14.6667px;">当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数</span></div></li><li><div><span style="font-size: 14.6667px;">使用格式：修饰符  返回值类型  方法名（数据类型...变量名）{}</span></div></li><li><div><span style="font-size: 14.6667px;">可变参数原理：</span></div></li><ul><li><div><span style="font-size: 14.6667px;">底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数</span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">传递的参数个数，可以是0个或多个</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;">注意事项：</span></div></li><ul><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">一个方法的参数列表，只能有一个可变参数</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</span></span></div></li></ul><li><div><span style="font-size: 14.6667px;">特殊写法：</span></div></li></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static void method(Object...obj){}</div></div><div><br/></div><div>总结：如何选择集合</div><ol><li><div>Set</div></li><ul><li><div>存储元素不可以重复</div></li><li><div>LinkedHashSet</div></li><ul><li><div>元素有序</div></li></ul><li><div>HashSet</div></li><ul><li><div>元素无序</div></li></ul></ul><li><div>List</div></li><ul><li><div>存储元素可以重复</div></li><li><div>ArrayList</div></li><ul><li><div>查找多，增删少</div></li></ul><li><div>LinkedList</div></li><ul><li><div>增删多，查找少</div></li></ul></ul></ol><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">十八、Collections</span></div><ol><li><div><span style="font-size: 11pt;"> 常用功能</span></div></li><ul><li><div><span style="font-size: 11pt;">public static &lt;T&gt; boolean addAll(Collection&lt;T&gt; c, T... elements) :往集合中添加一些元素</span></div></li><li><div><span style="font-size: 11pt;">public static void shuffle(List&lt;?&gt; list) 打乱顺序 :打乱集合顺序。</span></div></li><li><div><span style="font-size: 11pt;">public static &lt;T&gt; void sort(List&lt;T&gt; list) :将集合中元素按照默认规则排序</span></div></li><li><div><span style="font-size: 11pt;">public static &lt;T&gt; void sort(List&lt;T&gt; list，Comparator&lt;? super T&gt; ) :将集合中元素按照指定规则排序</span></div></li><ul><li><div><span style="font-size: 11pt;">注意事项：</span></div></li><ul><li><div><span style="font-size: 11pt;">sort（List&lt;T&gt; list）使用前提：被排序的集合里边存储的元素，必须实现</span><span style="color: rgb(0, 0, 0); font-family: &quot;Droid Sans Mono&quot;; font-size: 12pt;">Comparable</span><span style="font-size: 11pt;">，重写接口中的CompareTo方法定义排序规则</span></div></li><li><div><span style="font-size: 14.6667px;">如果排序规则中两个值相等，则哪一个先添加就把哪一个放在前面</span></div></li></ul></ul></ul><li><div><span style="font-size: 11pt;">Comparator和Comparable的区别：</span></div></li><ol><li><div><span style="font-size: 11pt;">Comparable：自己（this）和别人（参数）比较，自己需要实现Comparable接口，重写比较的规则CompareTo方法</span></div></li><ol><li><div><span style="font-size: 14.6667px;">Comparable自然排序：</span></div></li><ol><li><div><span style="font-size: 11pt;">static void sort(List&lt;T&gt; list);是对JDK提供的类类型数据进行排序</span></div></li><li><div><span style="font-size: 14.6667px;">如果对自定义的类型数据进行排序，该类必需实现接口，重写方法</span></div></li><li><div><span style="font-size: 14.6667px;">步骤</span></div></li><ol><li><div><span style="font-size: 14.6667px;">自定义对象所在的类必须实现Comparable接口</span></div></li><li><div><span style="font-size: 14.6667px;">自定义对象所在的类必须重写（CompareTo）</span></div></li><ol><li><div><span style="font-size: 11pt;">public int compareTo(T o);comepareTo方法内部就编写了排序的规则</span></div></li><li><div><span style="font-size: 14.6667px;">CompareTo中this - o 是升序，o - this 降序</span></div></li><li><div><span style="font-size: 14.6667px;">compareTo返回值</span></div></li><ol><li><div><span style="font-size: 14.6667px;">负数：要参与排序的元素就会放到已排序元素的左边</span></div></li><li><div><span style="font-size: 11pt;">0：位置不变</span></div></li><li><div><span style="font-size: 14.6667px;">正数：位置不变，保持在右边</span></div></li></ol></ol><li><div>o是已经比较完成的元素，this是即将比较的元素</div></li></ol></ol></ol><li><div><span style="font-size: 11pt;">Comparator比较器排序：相当于找一个第三方的裁判进行比较，o1-o2升序，反之降序</span></div></li><ol><li><div><span style="font-size: 14.6667px;">步骤</span></div></li><ol><li><div><span style="font-size: 14.6667px;">创建一个比较器对象（实现类对象，匿名内部类对象）传递到sort方法中</span></div></li><li><div><span style="font-size: 14.6667px;">在事项类或者匿名内部类中重写compare方法：</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">public int compare(Student o1,Student o2);</span></div></li><li><div><span style="font-size: 11pt;">o1就相当于自然排序中的this，o2就相当于自然排序中的o</span></div></li><li><div><span style="font-size: 11pt;">o1-o2升序，反之降序</span></div></li></ol></ol><li><div><span style="font-size: 14.6667px;">如果对JDK提供的类类型数据进行排序，没有传递比较器，则默认排序是自然排序的升序方式，如果自然排序和比较器排序共存，则选择比较器排序</span></div></li></ol></ol><div><span style="font-size: 12pt; font-weight: bold;">十九、Map集合（java.util.Map&lt;k,v&gt;）</span></div><ol><li><div><span style="font-size: 14.6667px;">概念：将键映射到值的对象，一个映射</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">不能包含重复的键</span><span style="font-size: 14.6667px;">；</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">每个键最多只能映射到一个值</span></div></li><li><div><span style="font-size: 14.6667px;">特点：</span></div></li><ul><li><div><span style="font-size: 11pt;">Map&lt;K,V&gt;</span></div></li><li><div><span style="font-size: 11pt;">Map集合是一个</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">双列集合</span><span style="font-size: 11pt;">，</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">一个元素包含两个值（一个key，一个value）</span></div></li><li><div>Map集合中的元素，<span style="color: rgb(255, 0, 0);">key和value的数据类型可以相同，也可以不同</span></div></li><li><div>Map集合中的元素，<span style="color: rgb(255, 0, 0); font-weight: bold;">key是不允许重复的，value是可以重复的</span></div></li><li><div>Map集合中的元素，key和value是一一对应的</div></li></ul><li><div>Map集合常用子类</div></li><ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">HashMap&lt;K,V&gt;集合</span>：存储数据采用哈希表结构，元素的存取<span style="color: rgb(255, 0, 0);">顺序不能保证一致</span>，由于要保证键的唯一、不重复，<span style="color: rgb(255, 0, 0);">需要重写键的hashCode（）方法、equals（）方法</span></div></li><ol><li><div>特点：</div></li><ul><li><div><span style="color: rgb(255, 0, 0);">底层是哈希表，查询的速度特别快</span></div></li><ul><li><div>JDK1.8之前，数组 + 单向链表</div></li><li><div>JDK1.8之后：数组 + 单向链表/红黑树（链表的长度大于8时）</div></li></ul><li><div><span style="color: rgb(255, 0, 0);">是一个无序集合，存储元素和取出元素顺序可能不一致</span></div></li><li><div><span style="color: rgb(255, 0, 0);">无索引，不能操作和索引相关的方法，索引map集合也没有索引相关方法</span></div></li></ul></ol><li><div><span style="color: rgb(255, 70, 53); font-weight: bold;">LinkeddHashMap&lt;K,V&gt;集合</span>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构，通过链表结构可以<span style="color: rgb(255, 0, 0); font-weight: bold;">保证元素的存取顺序一致</span>，通过哈希表结构可以保证的键的唯一不重复，需要重写键的hashCode（）方法，equals（）方法</div></li><ol><li><div>特点：</div></li><ul><li><div><span style="color: rgb(255, 0, 0);">底层是哈希表 + 链表</span></div></li><li><div><span style="color: rgb(255, 0, 0);">集合是一个有序的集合，存储元素和取出元素顺序是一致的</span></div></li></ul></ol></ol><li><div>常用方法：</div></li><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V put(K key, V value)</span><span style="box-sizing: border-box;">: 把指定的键与指定的值添加到Map集合中。</span></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V remove(Object key)</span><span style="box-sizing: border-box;">: 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值。</span></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V get(Object key)</span> <span style="box-sizing: border-box;">根据指定的键，在Map集合中获取对应的值。</span></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">boolean containsKey(Object key)</span> <span style="box-sizing: border-box;">判断集合中是否包含指定的键。</span></div></li><li style="box-sizing: border-box; margin: 0px; position: relative;"><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public Set&lt;K&gt; keySet()</span><span style="box-sizing: border-box;">: 获取Map集合中所有的键，存储到Set集合中。</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><span style="box-sizing: border-box;">: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></div></li></ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box;">遍历Map集合</span></div></li><ol><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box;">方法一</span></div></li><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box;">使用Map结合中的</span><span style="box-sizing: border-box; color: rgb(255, 0, 0);">keySet（）</span><span style="box-sizing: border-box;">方法获取Map中所有的键，由于键是唯一的，所以</span><span style="box-sizing: border-box; color: rgb(255, 0, 0);">返回一个Set集合存储所有的键</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(255, 0, 0); font-weight: bold;">遍历键的Set集合，得到每一个键</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; color: rgb(255, 0, 0);">通过Map集合中的方法get(key),根据键，获取键所对应的值</span></div></li></ul></ol></ol><div style="box-sizing: border-box;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class MapDemo01 {</div><div>    public static void main(String[] args) {</div><div>        //创建Map集合对象</div><div>        HashMap&lt;String, String&gt; map = new HashMap&lt;String,String&gt;();</div><div>        //添加元素到集合</div><div>        map.put(&quot;胡歌&quot;, &quot;霍建华&quot;);</div><div>        map.put(&quot;郭德纲&quot;, &quot;于谦&quot;);</div><div>        map.put(&quot;薛之谦&quot;, &quot;大张伟&quot;);</div><div><br/></div><div>        //获取所有的键  获取键集</div><div>        Set&lt;String&gt; keys = map.keySet();</div><div>        // 遍历键集 得到 每一个键</div><div>        for (String key : keys) {</div><div>              //key  就是键</div><div>            //获取对应值</div><div>            String value = map.get(key);</div><div>            System.out.println(key+&quot;的CP是：&quot;+value);</div><div>        }  </div><div>    }</div><div>}</div></div><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 11pt;">               2. 方法二：Entry键值对对象</span></div><ol><ol><ol><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px;">Entry&lt;K,V&gt;：</span><span style="box-sizing: border-box; font-size: 14.6667px; color: rgb(255, 0, 0);">在Map接口中有一个内部接口Entry</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px;">作用：当Map集合一创建，那么久会在</span><span style="box-sizing: border-box; font-size: 14.6667px; color: rgb(255, 0, 0);">Map集合中创建多个Entry对象</span><span style="box-sizing: border-box; font-size: 14.6667px;">，用来</span><span style="box-sizing: border-box; font-size: 14.6667px; color: rgb(255, 0, 0);">记录键与值（键值对对象，键与值得映射关系）</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px; color: rgb(255, 0, 0);">集合中有多少键值对，就有多少个Entry对象</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px;">使用步骤：</span></div></li><ol><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px;">使用Map集合中的</span><span style="box-sizing: border-box; font-size: 14.6667px; color: rgb(255, 0, 0);">方法entrySet()</span><span style="box-sizing: border-box; font-size: 14.6667px;">,把Map集合中多个Entry对象取出来，存储到一个Set集合中</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px;">遍历Set集合，</span><span style="box-sizing: border-box; font-size: 14.6667px; color: rgb(255, 0, 0);">获取每一个Entry对象</span></div></li><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px;">使用Entry对象中的 方法</span><span style="box-sizing: border-box; font-size: 14.6667px; color: rgb(255, 0, 0);">getKey()和getValue()获取键与值</span></div></li></ol><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 14.6667px;">Entry对象方法：</span></div></li><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public K getKey()</span><span style="box-sizing: border-box;">：获取Entry对象中的键。</span></div></li></ul></ol></ol><ul><ul><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; border: 1px solid rgb(221, 221, 221); background-color: rgb(248, 248, 248); border-radius: 3px; font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace;">public V getValue()</span><span style="box-sizing: border-box;">：获取Entry对象中的值。</span></div></li></ul></ul></ul></ol><ul><ul><ul><ul><li><div style="box-sizing: border-box;"><span style="box-sizing: border-box; font-size: 0.9em; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(248, 248, 248); border: 1px solid rgb(221, 221, 221); border-radius: 3px; color: rgb(255, 0, 0); font-family: Consolas, &quot;Liberation Mono&quot;, Courier, monospace; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal;">public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</span><span style="box-sizing: border-box; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: &quot;Open Sans&quot;, &quot;Clear Sans&quot;, &quot;Helvetica Neue&quot;, Helvetica, Arial, sans-serif; font-style: italic; font-variant-caps: normal; font-variant-ligatures: normal;">: 获取到Map集合中所有的键值对对象的集合(Set集合)。</span></div></li></ul></ul></ul></ul><div>        6. HashMap存储自定义类型的键值</div><ol><ol><li><div>HashMap存储自定义类型键值，作为key的元素，<span style="color: rgb(255, 0, 0);">必须重写hashCode方法和equals方法</span>，以保证key唯一</div></li><li><div>LinkedHashMap类（java.util.LinkedHashMap&lt;K,V&gt; extends HashMap）</div></li><ol><li><div>Map接口的哈希表和链表列表实现，具有可预知的迭代顺序</div></li><li><div>底层原理：哈希表 + 链表（记录元素顺序）</div></li></ol></ol></ol><div>        7. HashTable集合</div><ol><ol><li><div>底层是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢</div></li><li><div>HashMap是线程不安全，不同步的，速度快</div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">不能存储null值，null键</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">HashMap可以存储null键null值，null作为键只能出现一次</span></div></li><li><div><span style="color: rgb(166, 0, 196);">JDK1.2之后被取代</span></div></li><li><div>Properties子类是一个唯一和IO流相结合的集合</div></li></ol></ol><div><span style="font-size: 12pt; font-weight: bold;">二十、JDK9对集合添加的优化</span></div><ol><li><div>List接口，Set接口，Map接口：里边增加了 一个静态的方法of，可以给集合一次性添加多个元素</div></li><li><div>注意：</div></li><ol><li><div>当集合中存储的元素的个数已经确定了。不在改变时使用</div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">of方法只使用与List接口，Set接口，Map接口，不适用于接口的实现类</span></div></li><li><div><span style="color: rgb(255, 0, 0);">of方法的返回值是一个不能改变的集合，集合不能再使用add，put方法添加元素，会抛出异常</span></div></li><li><div><span style="color: rgb(255, 0, 0);">Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常</span></div></li><li><div><span style="min-height: 12pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-family: &quot;Microsoft YaHei UI&quot;;">of方法添加元素是有长度限制的</span></span></div></li></ol><li><div>Debug追踪：</div></li><ol><li><div>添加断点在方法的第一行</div></li><li><div>调试快捷键</div></li><ul><li><div>f8：逐行执行程序</div></li><li><div>f7：进入到方法中</div></li><li><div>shift + f8：跳出方法</div></li><li><div>f9：跳到下一个断点</div></li><li><div>ctrl + f2：退出debug模式，停止程序</div></li><li><div>console：切换到控制台</div></li></ul></ol></ol><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 