<html>
<head>
  <title>面向对象</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="440"/>
<h1>面向对象</h1>

<div>
<span><div><div><div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="white-space: pre-wrap; font-size: 16px; font-weight: bold; line-height: 1.75;">一、类</span></div><ol><li><div style="white-space: pre-wrap; text-align: left;"><span style="white-space: pre-wrap;"><span style="font-size: 10pt; line-height: 1.75;">类：是一组相关属性和行为的集合</span><span style="font-size: 16px; font-weight: bold; line-height: 1.75;"> </span></span></div></li><ol><li><div style="white-space: pre-wrap; text-align: left;"><span style="white-space: pre-wrap;"><span style="font-size: 16px; line-height: 1.75;">属性</span><span style="font-size: 16px; line-height: 1.75;">：</span><span style="font-size: 16px; line-height: 1.75;"> 就是该事物的状态信息</span></span></div></li><li><div style="white-space: pre-wrap; text-align: left;"><span style="white-space: pre-wrap;"><span style="font-size: 16px; line-height: 1.75;">行为：就是该事物能够做什么 <span style="font-size: 16px; line-height: 1.75; font-weight: bold;"> </span></span></span></div></li></ol></ol><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="white-space: pre-wrap; font-size: 16px; font-weight: bold; line-height: 1.75;">一、面向对象</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">1.成员变量是直接定义在类当中的，在方法外边</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">        修饰符 数据类型 变量名；</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">2.成员方法不要写static关键字</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">        修饰符 返回值类型 方法名（参数列表）{}</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">3.创建对象的三个步骤</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">1）导包：也就是支出需要使用的类，在什么位置</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">import 包名称.类名称</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(250, 122, 0); line-height: 1.75;">import 包名称.*----------导入该包 的所有类</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">import cn.itcast.day06.demo01.Student;</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">对于和当前类属于同一个包的情况，可以省略导包语句不写</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">2）创建：格式：</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">类名称 对象名 = new 类名称();</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">Student stu = new Student();</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">3)使用，分为两种情况</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(227, 0, 0); line-height: 1.75;">使用成员变量：对象名.成员变量名</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(227, 0, 0); line-height: 1.75;">使用成员方法：对象名.成员方法名(参数)</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">注意事项：<span style="font-size: 14px; line-height: 1.75; color: rgb(255, 0, 0);">如果成员变量没有进行赋值，那么将会有一个默认值，规则和数组一样</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">4.<span style="font-size: 14px; line-height: 1.75; color: rgb(255, 0, 0);">对象作为参数传递时，传递到方法当中时，实际上传递的是对象的地址值</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">5.<span style="font-size: 14px; line-height: 1.75; color: rgb(255, 0, 0);">当使用一个对象类型作为方法的返回值时：返回值其实就是对象的地址值</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">对象在内存中存储</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="font-size: 14px;"><img src="面向对象_files/对象实例化过程.PNG" type="image/png" data-filename="对象实例化过程.PNG" width="1051"/></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="font-size: 14px;">两个变量指向同一个对象</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="font-size: 11pt;"><img src="面向对象_files/两个对象的存储方式.PNG" type="image/png" data-filename="两个对象的存储方式.PNG" width="1059"/></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="font-size: 11pt;">对象作为参数</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="font-size: 11pt;"><img src="面向对象_files/对象作为参数传递.PNG" type="image/png" data-filename="对象作为参数传递.PNG" width="1053"/></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="font-size: 11pt;">对象作为返回值</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="font-size: 11pt;"><img src="面向对象_files/对象作为返回值.PNG" type="image/png" data-filename="对象作为返回值.PNG" width="1046"/></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="white-space: pre-wrap; font-size: 16px; font-weight: bold; line-height: 1.75;">二、局部变量和成员变量的区别</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">1.定义的位置不一样</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">局部变量：在方法内部定义</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">成员变量：在方法外部定义，直接写在类当中</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">2.作用范围不一样</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">局部变量：只有方法当中才可以使用，出了方法就不能再用</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">成员变量：整个类全都可以通用</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">3.默认值不一样</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">局部变量：没有默认值，如果想要使用，必须手动进行赋值</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">成员变量：如果没有赋值，会有默认值，规则和数组一样</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">4.内存的位置不一样</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(255, 0, 0); line-height: 1.75;">局部变量：位于栈内存</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(255, 0, 0); line-height: 1.75;">成员变量：位于堆内存</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">5.生命周期不一样</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(255, 0, 0); line-height: 1.75;">局部变量：随着方法进栈诞生，随着方法出栈而消失</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(255, 0, 0); line-height: 1.75;">成员变量：随着对象创建而诞生，随着对象被垃圾回收消失</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">注意：<span style="font-size: 14px; line-height: 1.75; color: rgb(255, 0, 0);">方法的 参数就是局部变量，参数在方法调用的时候，必然会被赋值的</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="white-space: pre-wrap; font-size: 16px; font-weight: bold; line-height: 1.75;">三、封装性</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; font-weight: bold; line-height: 1.75;">1.方法就是一种封装</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="font-size: 14px; white-space: pre-wrap;"><span style="font-size: 14px; font-weight: bold; line-height: 1.75;">2.</span></span><span style="font-size: 14px; font-weight: bold; line-height: 1.75;">关键字private也是一种封装</span><span style="font-size: 14px; white-space: pre-wrap; line-height: 1.75;">：用private关键字将需要保护的成员变量进行保护</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">一旦使用了private进行修饰，那么本类当中仍然可以随意访问，但是，超出了本类范围之外就不能再直接访问</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">间接访问private修饰的变量的方式：设置Setter/Getter方法，即在类中定义方法访问private修饰的变量</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">必须命名为setXxx或者是getXxx命名规则</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">对于Getter来说，不能有参数，返回这类型和成员变量对应</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">对于Setter来说，不能有返回值，参数类型和成员变量对应</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">注意：对于基本类型当中的boolean值，Getter方法一定要写成isXxx的形式，而Setter方法不变</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; background-color: rgb(255, 250, 165); line-height: 1.75;-evernote-highlight:true;">如果局部变量和成员变量名字一样，则在setter和getter时要给变量加this关键字</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; font-weight: bold; line-height: 1.75;">3.this关键字</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(250, 122, 0); line-height: 1.75;">当方法的局部变量和类的成员变量重名的时候，根据就近原则，优先使用局部变量，如果需要访问本类当中的成员变量，需要使用格式：this.成员变量名</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; background-color: rgb(255, 250, 165); line-height: 1.75;-evernote-highlight:true;">“通过谁调用的方法，谁就是this”</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">作用：区分同名的成员变量和局部变量</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; font-weight: bold; line-height: 1.75;">4.构造方法</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">格式：</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">修饰符 类名称(参数类型 参数名称){</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">        方法体</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">}</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">注意事项：</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">1）构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">2）构造方法不用写返回值类型，连void也不写</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; color: rgb(255, 0, 0); font-weight: bold; line-height: 1.75;">3）</span><span style="font-size: 14px; color: rgb(255, 0, 0); font-weight: bold; line-height: 1.75;">构造方法不能return一个具体返回值</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="font-size: 14px; white-space: pre-wrap; line-height: 1.75;">4）如果</span><span style="font-size: 14px; color: rgb(255, 0, 0); line-height: 1.75;">没有编写任何构造方法</span><span style="font-size: 14px; white-space: pre-wrap; line-height: 1.75;">，那么</span><span style="font-size: 14px; color: rgb(255, 0, 0); line-height: 1.75;">编译器将会默认赠送一个构造方法</span><span style="font-size: 14px; white-space: pre-wrap; line-height: 1.75;">，没有参数，方法体什么也不做</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">5）<span style="font-size: 14px;"><span style="font-size: 14px; line-height: 1.75; color: rgb(255, 0, 0); font-weight: bold;">一旦编写了至少一个构造方法，那么编译器将不再赠送</span></span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 80px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">6）构造方法也是可以重载的</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="white-space: pre-wrap; font-size: 16px; font-weight: bold; line-height: 1.75;">四、一个标准的类(Java Bean)</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">1.<span style="background-color: rgb(255, 250, 165); font-size: 14px; line-height: 1.75;-evernote-highlight:true;">所有的成员变量都要使用private关键字修饰</span></span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">2.为每一个成员白能量编写一对Getter/Setter方法</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">3.编写一个无参的构造方法</span></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px; margin-left: 40px;"><span style="white-space: pre-wrap; font-size: 14px; line-height: 1.75;">4.编写一个全参的构造方法</span></div></div><div style="white-space: pre-wrap; text-align: left; font-size: 14px;"><span style="white-space: pre-wrap; font-size: 14px;"><span style="font-size: 14px; font-weight: bold; line-height: 1.75;">五、继承(extends)</span></span></div><ol><li><div><span style="font-size: 11pt; font-weight: bold;">概念：</span><span style="font-size: 11pt; color: rgb(235, 0, 115); font-weight: bold;">共性抽取</span></div></li><li><div><span style="font-size: 11pt; font-weight: bold;">继承关系当中的特点：</span></div></li><ol><li><div><span style="font-size: 11pt;">子类可以拥有父类的“内容”</span></div></li><li><div><span style="font-size: 11pt;">子类还可以拥有自己专有的内容</span></div></li><li><div><span style="font-size: 11pt;">在继承的关系中，“子类就是一个父类”，也就是说，子类可以被当做父类看待</span></div></li></ol><li><div><img src="面向对象_files/ScreenClip.png" type="image/png" data-filename="ScreenClip.png" width="994"/></div></li><li><div><span style="font-size: 11pt; font-weight: bold;">定义父类的格式：（一个普通的类定义）</span></div></li></ol><div>            </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class 父类名称{</div><div>    //..</div><div>}</div></div><div><span style="font-weight: bold;">      5</span><span style="font-size: 11pt; font-weight: bold;">.定义子类的格式：</span></div></div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class 子类名称 extends 父类名称{</div><div>    //...</div><div>}</div></div><div>   <font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"> </span><span style="font-size: 11pt; font-weight: bold;"> 6.继承中成员变量的访问方法</span></font></div><div>       <span style="font-size: 11pt;"> </span><span style="font-size: 11pt;">在父子类的继承关系当中，如果</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">成员变量重名</span><span style="font-size: 11pt;">，则创建子类对象时，有两种方式</span></div><ol><ol><li><div><span style="font-size: 11pt;">直接通过子类对象访问成员变量：<span style="font-size: 11pt; color: rgb(255, 0, 0);">等号左边是谁，就优先用谁，没有则向上找</span></span></div></li><li><div><span style="font-size: 11pt;">间接通过成员方法访问成员变量：<span style="font-size: 11pt; color: rgb(255, 0, 0);">该方法属于谁，就优先用谁，没有则向上找</span></span></div></li></ol></ol><div><span style="font-size: 11pt;">        在父子类的继承关系中，如果<span style="font-size: 11pt; font-weight: bold;">局部变量，本类的成员变量和父类的成员变量重名规则</span></span></div><ol><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">局部变量：直接写局部变量名</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">本类的成员变量：this.成员变量名</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">父类的成员变量：super.成员变量名</span></span></div></li></ol></ol><div><span style="font-size: 11pt;">        在父类的继承关系当中，创建子类对象，访问成员方法的规则</span></div><ol><ol><li><div><span style="font-size: 11pt;">创建对象是谁，就优先用谁，如果没有则向上找。</span></div></li><li><div><span style="font-size: 11pt;">注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类</span></div></li></ol></ol><div>  <font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">   7.方法的重写（override）</span></font></div><ol><ol><li><div><span style="background-color: rgb(255, 250, 165); font-size: 11pt; color: rgb(235, 0, 115);-evernote-highlight:true;"><b>在继承关系当中，方法的名称一样，参数列表也一样</b></span></div></li></ol></ol><div><span style="font-size: 11pt;">        注意事项：</span></div><ol><ol><li><div><span style="font-size: 11pt;">@Override:写在方法前面，用来检测是不是有效的正确覆盖重写（可选）</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">子类方法的返回值必须</span><span style="background-color: rgb(255, 250, 165); font-size: 11pt; font-weight: bold;-evernote-highlight:true;">小于等于</span><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">父类方法的返回值范围 </span> （这里的小于等于指的是继承的概念，子类的返回值是父类返回值的子类）<span style="font-size: 11pt;">  </span></div></li><div><span style="font-size: 11pt;">java.long.Object是所有类的顶级类</span></div></ol></ol><div><span style="font-size: 11pt;">               3.</span> <span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">子类方法的权限必须</span><span style="background-color: rgb(255, 250, 165); font-size: 11pt; font-weight: bold;-evernote-highlight:true;">大于等于</span><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">父类方法的权限修饰符  </span></div><div><span style="font-size: 11pt;">                    public &gt; protected &gt; (default) &gt; private          </span></div><div><span style="font-size: 11pt;">                    备注：(default)不是关键字default，而是什么都不写，留空</span></div><div><span style="font-size: 11pt;">                4.<span style="font-size: 11pt; color: rgb(255, 0, 0);"> 私有的方法不能被继承，也不能被覆盖重写</span></span></div><div><span style="font-size: 11pt;">   </span> <span style="font-size: 11pt; font-weight: bold;"> 8. 设计原则：</span></div><div><span style="font-size: 11pt;">        对于已经投入使用的类，尽量不要进行修改。推荐定义一个新的类，来重复利用其中共性内容，并且添加改动新内容</span></div><div><span style="font-size: 11pt;">     </span><span style="font-size: 11pt; font-weight: bold;">9. 父子类构造方法的访问特点</span></div><ol><ol><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">子类构造方法当中</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">有一个默认隐含的&quot;super()&quot;调用</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">父类无参构造方法</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">，所以一定</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">先执行的父类构造</span><span style="font-size: 11pt; color: rgb(255, 0, 0);">，后执行的子类构造</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">子类构造可以通过super关键字来调用父类重载构造：super(参数列表);</span></div></li><li><div><span style="font-size: 11pt; color: rgb(255, 0, 0);">super的父类构造调用，必须是子类构造方法的第一个语句，不能一个子类构造调用多次super构造</span></div></li></ol></ol><div><span style="font-size: 11pt;">    总结：</span><span style="font-size: 11pt; font-weight: bold;">子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个</span></div><div><span style="font-size: 11pt;">   </span> <span style="font-size: 11pt; font-weight: bold;">10. super关键字的用法有三种</span></div><ol start="11"><ol><li><div><span style="font-size: 11pt;">在子类的成员方法中，访问父类的成员变量</span></div></li><li><div><span style="font-size: 11pt;">在子类的成员方法中，访问父类的成员方法</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">在子类的构造方法中，访问父类的构造方法</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">在子类的普通方法中，不能通过super关键字调用父类构造方法</span></span></div></li></ol><li><div><span style="font-size: 11pt; font-weight: bold;">this关键字</span></div></li><ol><li><div><span style="font-size: 11pt;">在本类的成员方法中，访问本类的成员方法</span></div></li><li><div><span style="font-size: 11pt;">在本类的成员方法中，访问本类的另一个成员方法</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">在本类的构造方法中，访问本类的另一个构造方法</span></div></li></ol></ol><div><span style="font-size: 11pt;">        注意：</span></div><div><span style="font-size: 11pt;">                 </span> <span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">1. 在第三种用法中this(...)调用也必须是构造方法的第一个语句，也是唯一一个</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">                  2. super和this两种构造的调用不能同时使用，因为super和this都是唯一的</span></span></div><div><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">                  3. super和this关键字图解</span></div><div><img src="面向对象_files/ScreenClip [1].png" type="image/png" data-filename="ScreenClip.png" width="1007"/></div><div>   <span style="font-size: 11pt;">  </span> <span style="font-size: 11pt; font-weight: bold;">12. Java继承的特点</span></div><div>                1.<span style="font-size: 11pt;"> 一个类的直接父类只能有唯一一个</span><span style="font-size: 11pt;">  </span></div><div><span style="font-size: 11pt;">              2. Java语言可以多级继承，最顶级的类是java.lang.Object</span></div><div><span style="font-size: 11pt;">              3.  一个子类的直接父类是唯一的，但是一个父类可以有多个子类</span></div><div><img src="面向对象_files/ScreenClip [2].png" type="image/png" data-filename="ScreenClip.png" width="1001"/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">六、抽象（</span><span style="font-size: 12pt; font-weight: bold;">如果父类当中不确定{}方法体如何实现，那么这就是一个抽象方法</span><span style="font-size: 12pt; font-weight: bold;">）</span></font></div><ol><li><div><font style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(123, 0, 61);">抽象方法：就是加上abstract关键字，然后去掉大括号，直接用分号结束</span></font></div></li></ol><div><span style="font-size: 11pt;">     </span> <span style="font-size: 11pt; color: rgb(255, 0, 0);">2. 抽象类：抽象方法所在的类必须是抽象类才行，在class之前加上abstract就行，<span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">抽象类中可以有构造方法</span></span></div><div><span style="font-size: 11pt;">      3. 如何使用抽象类和抽象方法</span></div><ol><ol><li><div><span style="font-size: 11pt;">不能直接创建new抽象类对象</span></div></li><li><div><span style="font-size: 11pt;">必须有子类继承抽象父类</span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">子类必须覆盖重写抽象父类当中所有的抽象方法</span></span></div></li><ol><li><div><span style="font-size: 11pt;">覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号</span></div></li></ol><li><div><span style="font-size: 11pt;"> 创建子类对象进行使用</span></div></li></ol></ol><div><span style="font-size: 11pt;">注意事项：</span></div><ol><li><div><span style="font-size: 11pt;">抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象</span></div></li><li><div><span style="font-size: 11pt;">是供子类创建对象时，初始化父类成员使用的。</span></div></li><li><div><span style="font-size: 11pt;">抽象类中，不一定包含抽象方法，但是有抽象方法的类必须是抽象类。</span><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">没有抽象方法的抽象类，也是不能直接创建对象</span></div></li><li><div><span style="font-size: 11pt;">抽象类的子类，<font style="color: rgb(166, 0, 196);">必须重写抽象父类中所有的抽象方法</font>，否则编译报错。</span><span style="background-color: rgb(255, 250, 165);font-size: 11pt;-evernote-highlight:true;">除非该子类也是抽象类</span></div></li></ol><div><span style="font-size: 11pt; font-weight: bold;">七、接口</span></div><ol><li><div><span style="font-size: 11pt; font-weight: bold;">概念：接口就是多个类的公共规范。</span><span style="font-size: 11pt; font-weight: bold;">接口是一种引用数据类型，最重要的内容就是其中的抽象方法</span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">定义方法：</span></span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public interface 接口名称{</div><div>    //接口内容</div><div>}</div><div><br/></div><div>备注：换成了关键字interface之后，编译生成的字节码文件仍然是.java--&gt;.class</div></div><div>      3. <span style="font-size: 11pt; font-weight: bold;">接口内可以存放的内容</span></div><ol><ol><li><div><span style="font-weight: bold;">Java7，可以包含的内容有</span></div></li><ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">常量</span></div></li></ol></ol></ol><div>                            接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰，从效果上看，这其实就是接口的【常量】，一旦赋值不可修改</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static final 数据类型 常量名称 = 数据值</div><div>备注：一旦使用final关键字进行修饰，说明不可改变</div><div>注意： 1.接口当中的常量，可以省略public static final,注意，不写也照样是这样</div><div>      2. <font color="#FF0000"><b>接口当中的常量，必须进行赋值，不能不赋值</b></font></div><div>      3. 接口中常量的名称，使用时完全大写</div></div><div>                           2. <span style="color: rgb(255, 0, 0); font-weight: bold;">抽象方法</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public abstract  void 方法名称();</div><div>注意事项：</div><div>1. 接口中的抽象方法，修饰符必须是两个固定的关键字：public abstract</div><div>2. 这两个关键字修饰符，可以选择性的进行省略任意一个或两个都省略</div><div>3. 方法的三要素可以随意定义</div></div><div><span style="font-weight: bold;">                2. Java8，还可以包含</span></div><ol><ol><ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">默认方法</span></div></li></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public default 返回值类型 方法名称(参数列表){</div><div>    方法体</div><div>}</div><div>备注：接口当中的默认方法，可以<b><font color="#FF0000">解决接口升级的问题，默认方法就是用来被实现类继承的</font></b></div><div><font color="#000000">1.接口的默认方法，可以通过</font><b style="color: rgb(255, 0, 0);">接口实现类对象直接调用</b></div><div><font color="#000000">2.接口的默认方法，也可以被</font><b style="color: rgb(255, 0, 0);">接口实现类进行覆盖重写，重写的时候不要加default</b></div></div><div>                            2.<span style="color: rgb(255, 0, 0); font-weight: bold;"> 静态方法</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static 返回值类型 方法名称(参数列表){</div><div>    方法体</div><div>}</div><div>提示：就是将abstract或者default换成static即可，带上方法体</div><div>注意：<font color="#EB0073">不能通过接口实现类的对象来调用接口当中的静态方法</font></div><div><b><font color="#FF0000">可以通过接口名称.直接调用其中的静态方法</font></b></div><div><b>格式：接口名称.静态方法（参数）</b></div></div><ol><div>      <span style="font-weight: bold;">3. </span><span style="font-weight: bold;">Java9，还可以包含</span></div><ol><ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">私有方法</span></div></li></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1.普通私有方法，解决多个<font color="#EB0073"><b>默认</b></font>方法之<font color="#FF0000">间重复代码</font>问题</div><div>格式：</div><div>    private 返回值类型 方法名称(参数列表){</div><div>        方法体</div><div>    }</div><div><b><font color="#FF0000">私有方法只能在接口中默认方法内调用</font></b></div><div>2.静态私有方法，解决多个<font color="#EB0073"><b>静态</b></font>方法之间<font color="#FF0000">重复代码</font>问题</div><div>格式：</div><div>    private static 返回值类型 方法名称(参数列表){</div><div>        方法体</div><div>    }</div><div><b><font color="#FF0000">静态私有方法在接口中的静态方法内调用也可以在默认方法内调用</font></b></div></div><div>    <span style="font-size: 11pt; font-weight: bold;"> 4.注意事项：</span></div><ol><ol><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">接口中的抽象方法，修饰符必须是两个固定的关键字：public abstract</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">这两个关键字修饰符，可以选择性的进行省略任意一个或两个都省略</span></div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">方法的三要素可以随意定义</span></div></li></ol></ol><div>    <span style="font-size: 11pt; font-weight: bold;">5.接口使用步骤：</span></div><ol><ol><li><div>接口不能直接使用，必须有一个“实现类”来实现该接口，格式为：</div></li></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class 实现类名称 implements 接口名称{</div><div>    //...</div><div>}</div></div><div style="margin-left: 40px;">      2. <span style="color: rgb(255, 0, 0); font-weight: bold;">接口的实现类必须覆盖重写，加上方法体大括号</span></div><div>                    实现：去掉abstract关键字，加上方法体大括号</div><div style="margin-left: 40px;">      3.创建实现类的对象，进行使用</div><div style="margin-left: 40px;">      4.注意事项：</div><div>                <span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">如果实现类并没有覆盖重写接口中的所有的抽象方法，那么这个类就必须是一个抽象类</span></div><div>    <span style="font-size: 11pt; font-weight: bold;">6.总结</span></div><ol><ol><li><div>成员变量其实是常量</div></li></ol><div>            注意：常量必须进行赋值，而且一旦赋值不能改变。</div><div>                      常量名称完全大写，用下划线进行分割</div><div>       2. 抽象方法</div><div>            注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类</div><div>       3. 接口里允许默认方法</div><div>            注意：默认方法也可以被覆盖重写</div><div>       4. 静态方法</div><div>            注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法</div><div>       5. 允许私有方法</div><div>            注意：private的方法只有接口自己才能调用，不能被实现类或其它类使用</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">注意事项：</span></div><ol><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;-evernote-highlight:true;">接口是没有静态代码块或者构造方法的 </span></span></span></div></li><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">一个类的直接父类是唯一的，但是一个类可以实现多个接口</span></div></li><ol><li><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">格式：</span></div></li></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">public class MyInterfaceImpl implements MyInterfaceA,MyInterfaceB{</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">    //覆盖重写所有抽象方法</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">}</span></div></div><div><br/></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                3.如果实现类所实现的多个接口当中，<span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0);-evernote-highlight:true;">存在重复的抽象方法，那么只需要覆盖重写一次即可</span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                4. 如果实现类没有覆盖重写所有接口当中的抽象方法，那么实现类必须是一个抽象类</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                5.<span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0);-evernote-highlight:true;"> 如果实现类（无论是否是抽象类）所实现的多个接口当中，存在重复的默认方法，那么实现类一定要给重复的默认方法进行重写</span></span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">                6. <span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0);-evernote-highlight:true;">一个类如果直接父类当中的方法，和接口当中的默认方法发生冲突，</span><span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0); font-weight: bold;-evernote-highlight:true;">则优先使用父类中的方法</span><span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0);-evernote-highlight:true;">（</span><span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0); font-weight: bold;-evernote-highlight:true;">继承优先于接口实现</span><span style="background-color: rgb(255, 250, 165); color: rgb(255, 0, 0);-evernote-highlight:true;">）</span></span></div><div><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">    7.规律总结</span></font></div><ol><ol><li><div>类与类之间是单继承的，直接父类只有一个</div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">类与接口之间是多实现的，一个类可以实现多个接口(implements)</span></div></li><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">接口与接口之间是多继承(extends)</span></div></li></ol></ol><div>        注意：</div><div>                1. 多个父接口当中的抽象方法如果重复，没关系，</div><div>                2. 多个父接口当中的默认方法如果重复，<font style="color: rgb(255, 0, 0);">那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】</font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">八、多态</span></font></div><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">    1.概念：</span></span></div><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;">    </span><span style="font-size: 14.6667px; font-weight: bold;">  </span> extends继承或者implements实现，是多态性的前提，一个对象拥有多种形态，这就是对象的多态性</span></div><div><span style="font-size: 11pt;">  <span style="font-size: 11pt; font-weight: bold;">  2.代码当中体现多态性</span></span></div><ol><ol><li><div><span style="font-size: 11pt;">父类引用指向子类对象（左父右子）</span></div></li><li><div><span style="font-size: 11pt;">父类名称 对象名 = new 子类名称()</span></div></li><li><div><span style="font-size: 11pt;">接口名称 对象名 = new 实现类名称()</span></div></li></ol></ol><div><span style="font-size: 11pt;">    <span style="font-size: 11pt; font-weight: bold;">3.访问成员变量的两种方式</span></span></div><ol><ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">直接通过对象名称访问成员变量：看等号左边是谁，就优先用谁，没有则向上找</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">间接通过成员方法访问成员变量：看该方法属于谁，则优先用谁，没有则向上找，如果都有，则优先用子类方法</span></span></div></li></ol></ol><div><span style="font-size: 11pt;">    <span style="font-size: 11pt; font-weight: bold;">4.成员方法的访问规则</span></span></div><ol><ol><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);"> 看new的是谁，就优先用谁，没有则向上查找</span></span></div></li></ol></ol><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">   </span> <span style="font-size: 11pt; font-weight: bold;">5.对比成员变量和成员方法</span></span></div><ol><ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">成员变量：编译看左边，运行看左边</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; font-weight: bold;"><font style="color: rgb(158, 0, 243);">成员方法：编译看左边，运行看右边</font></span></span></div></li></ol></ol><div>    <font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">6.多态的好处</span></font></div><div><span style="font-size: 14.6667px;">                无论右边new的时候换成哪个子类对象，等号左边调用方法都不会改变</span></div><div><span style="font-size: 14.6667px;">    <span style="font-size: 14.6667px; font-weight: bold;">7.对象向上转型（其实就是多态写法）</span></span></div><ol><ol><li><div><span style="font-size: 14.6667px;">格式：<span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">父类名称 对象名 = new 子类名称()</span></span></div></li><li><div><span style="font-size: 14.6667px;">含义：右侧创建一个子类对象，把它当做父类来看待使用</span></div></li><li><div><span style="font-size: 14.6667px;">注意事项：向上转型一定是安全的，从小范围转向了大范围</span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">缺点：对象一旦向上转型为父类，那么久无法调用子类特有内容</span></span></div></li></ol></ol><div><span style="font-size: 11pt;">    <span style="font-size: 11pt; font-weight: bold;">8.对象向下转型（其实是一个还原的过程）</span></span></div><ol><ol><li><div><span style="font-size: 14.6667px;">格式：<span style="font-size: 14.6667px; color: rgb(255, 0, 0);">子类名称 对象名 = （子类名称）父类对象；</span></span></div></li><li><div><span style="font-size: 14.6667px;">含义：将父类对象，还原成为子类对象</span></div></li><li><div><span style="font-size: 14.6667px;">注意事项：</span></div></li><ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">必须保证对象本来创建的时候，就是A对象，才能向下转型为A</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">如果对象创建的时候本来不是A，向下转型的时候非要转型为A，则会报错</span></span></div></li><ol><li><div><span style="color: rgb(255, 0, 0); font-weight: bold;">java.lang.ClassCastExceptioin</span></div></li></ol><li><div><img src="面向对象_files/ScreenClip [3].png" type="image/png" data-filename="ScreenClip.png" width="998"/></div></li></ol></ol></ol><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">九、instanceof关键字</span></font></div><div><span style="font-size: 11pt; font-weight: bold;">            1. 格式：</span></div><ol><ol><li><div>对象 instanceof 类名称，这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例</div></li></ol></ol><div>           <span style="font-size: 11pt;">  </span> <span style="font-size: 11pt; font-weight: bold;">2.三种方式</span></div><ol><ol><li><div>可以先采用多态写法将对象向上转型，然后再作为参数使用</div></li><li><div><span style="color: rgb(255, 0, 0);">不进行向上转型，将对象作为参数使用，程序会自动向上转型</span></div></li><li><div>可以采用匿名函数方式传递参数</div></li></ol></ol><div><span style="font-size: 16px;"><span style="font-size: 16px; font-weight: bold;">十、final关键字</span></span></div><div><span style="font-size: 11pt; font-weight: bold;">        1. 概念</span><span style="font-size: 11pt; font-weight: bold;"> </span> <span style="font-size: 11pt; font-weight: bold;"> </span></div><div><span style="font-size: 11pt; font-weight: bold;">    </span><span style="font-size: 11pt; font-weight: bold;">    </span><span style="font-size: 11pt; font-weight: bold;">   </span> <span style="font-size: 11pt;">final</span><span style="font-size: 11pt; font-weight: bold;"> </span><span style="font-size: 11pt;">关键字代表最终、不可改变的</span><span style="font-size: 11pt; font-weight: bold;">  </span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">        2. 常见四种用法</span></span></div><div><span style="font-size: 11pt;">             1. <span style="font-size: 11pt; font-weight: bold;">可以用来修饰一个类</span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 11pt;">public final class 类名称{</span></div><div><span style="font-size: 11pt;">    //...</span></div><div><span style="font-size: 11pt;">}</span></div><div><span style="font-size: 11pt;"><b><font color="#FF0000">含义：当前这个类不能有任何的子类</font></b></span></div><div><span style="font-size: 11pt;">注意事项：</span></div><div><span style="font-size: 11pt;">   <b><font color="#FF0000"> 1. 一个类如果是final的，那么其中的方法不能被覆盖重写</font></b></span></div></div><div><span style="font-size: 11pt;">            2. <span style="font-size: 11pt; font-weight: bold;">可以用来修饰一个方法</span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">修饰符 final 返回值类型 方法名称(参数列表){</font></div><div><font face="Monaco">        //方法体</font></div><div><font face="Monaco">}</font></div><div><font face="Monaco">注意：</font></div><div><font face="Monaco">      <font color="#FF0000"><b>  1.当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写</b></font></font></div><div><font color="#FF0000" face="Monaco"><b>        2. 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾     </b></font></div></div><div><span style="font-size: 11pt;">            3. </span><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">可以修饰一个局部变量（一次赋值，终身不变）</span></span></div><ol><ol><li><div><span style="font-size: 11pt;">一旦使用final用来修饰局部变量，那么这个变量就不能进行更改</span></div></li><li><div><span style="font-size: 11pt;">对于基本类型来说，<span style="font-size: 11pt; color: rgb(255, 70, 53); font-weight: bold;">不可变说的是变量当中的数据不可变</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">对于引用类型来说，不可变说的是引用类型当中的地址不可变</span></span></div></li></ol></ol><div><span style="font-size: 11pt;">            4. </span><span style="font-size: 11pt; font-weight: bold;">可以修饰一个成员变量</span><span style="font-size: 11pt; font-weight: bold;"> </span></div><ol><ol><li><div><span style="font-size: 11pt;">对于成员变量来说，如果使用final关键字修饰，这个变量照样不可变；</span></div></li><li><div><span style="font-size: 11pt;">由于成员变量具有默认值，<span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">所以用了final之后必须手动赋值，不会再给默认值了</span></span></div></li><li><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0);">对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一</span></span></div></li><ol><li><div><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">构造方法赋值要在所有构造方法中对成员变量进行赋值</span></div></li></ol><li><div><span style="font-size: 11pt;">必须保证所有重载的方法，都最终会给final的成员变量进行赋值 </span></div></li></ol></ol><div><span style="font-size: 16px;"><span style="font-size: 16px; font-weight: bold;">十一、四种权限修饰符</span></span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">            1. public &gt; protected &gt; (default) &gt; private</span></span></div><div><div><br/></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 144px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col><col style="width: 130px;"></col></colgroup><tbody><tr><td style="border: 1px solid rgb(204, 204, 204); width: 144px; padding: 8px;"><div style="text-align: center;"></div></td><td style="text-align: center; border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><span style="font-size: 12pt; font-weight: bold;">public</span></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 12pt; font-weight: bold;">protected</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 12pt; font-weight: bold;">(default)</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 12pt; font-weight: bold;">private</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 144px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 12pt; font-weight: bold;">同一个类</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">YES</span></span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 144px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 12pt; font-weight: bold;">同一个包不同类</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">NO</span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 144px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 12pt; font-weight: bold;">不同包子类</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">YES</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">NO</span></span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">NO</span></span></div></td></tr><tr><td style="border: 1px solid rgb(204, 204, 204); width: 144px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 12pt; font-weight: bold;">不同包非子类</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">YES</span></span></div></td><td style="text-align: center; border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div><span style="font-size: 11pt; font-weight: bold;">NO</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt; font-weight: bold;">NO</span></div></td><td style="border: 1px solid rgb(204, 204, 204); width: 130px; padding: 8px;"><div style="text-align: center;"><span style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">NO</span></span></div></td></tr></tbody></table><div>注意事项：（default）并不是关键字“default”，而是根本不写</div></div><div>                    public只要不跨模块，就能访问</div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">十二、 内部类</span></font></div><div><span style="font-size: 12pt; font-weight: bold;">    </span><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;">1. 成员内部类</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font><font style="font-size: 11pt;">修饰符 class 外部类名称{</font></font></div><div><font><font style="font-size: 11pt;">    修饰符 class 内部类名称{</font></font></div><div><font><font style="font-size: 11pt;">        //...</font></font></div><div>    }</div><div>    //...</div><div>}</div><div>注意：</div><div>    <b><font color="#FF0000">内用外，随意访问，外用内，需要借助内部类对象</font></b></div><div><b><font color="#FF0000">    内部类编译后文件名为：外部类名$内部类名.class</font></b></div><div><font face="Monaco">使用方法：</font></div><div><font style="font-family: Monaco;">    1.间接方式：在外部类的方法当中，使用内部类，然后main只是调用外部类的方法</font></div><div><font face="Monaco">    2.直接方式：</font></div><div><font face="Monaco">            类名称    对象名    =    new    类名称()</font></div><div><font face="Monaco">            <font color="#FF0000"><b>外部类名称.内部类名称    对象名    =    new    外部类名称().new    内部类名称();    //创建了两次对象</b></font></font></div></div><ol><li><div><span style="font-size: 14.6667px;">内部类的同名变量访问</span></div></li><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 11pt;">如果出现了重名现象，那么格式是：</span><span style="font-size: 11pt; color: rgb(166, 0, 196); font-weight: bold;">外部类名称.this.外部类成员原变量</span> <span style="font-size: 11pt; color: rgb(166, 0, 196);"> </span><span style="font-size: 11pt; font-weight: bold;"><span style="font-size: 11pt; font-weight: bold; color: rgb(166, 0, 196);"> </span> </span></span><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">      </span></span> <span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"> </span></span><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 12pt; font-weight: bold;">    </span></div></li></ol></ol><div><span style="font-size: 12pt;"><span style="font-size: 11pt; font-weight: bold;">    2. 局部内部类 </span></span><font style="font-size: 11pt;"><span style="font-size: 11pt; font-weight: bold;"> </span></font><span style="font-size: 11pt;">   </span>     </div><ol><li><div><span style="font-size: 14.6667px;">概念：</span><span style="font-size: 14.6667px; color: rgb(255, 0, 0); font-weight: bold;">如果一个类是定义在一个方法内部的，那么这就是一个局部内部类</span><span style="font-size: 14.6667px;">。</span><span style="font-size: 14.6667px;">“局部”:只有当前所属的方法才能使用它，出了这个方法外面就不能用了。</span></div></li><li><div><span style="font-size: 14.6667px;">定义格式</span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>修饰符  class  外部类名称{</div><div>    修饰符  返回值类型  外部类方法名称(参数){</div><div>        class 局部内部类名称{</div><div>            //...</div><div>        }</div><div>    }</div><div>}</div></div><div>       <span style="font-size: 11pt;">3. 总结（定义一个类的时候，权限修饰符规则：）</span></div><ul><ol><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">外部类：public / (default)</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(255, 0, 0);">成员内部类：public / protected / (default) / private</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px;"><span style="font-size: 14.6667px; color: rgb(166, 0, 196); font-weight: bold;">局部内部类： 什么都不能写</span></span></span></div></li></ol><li><div><span style="font-size: 14.6667px;"><span style="color: rgb(166, 0, 196); font-size: 14.6667px; font-weight: bold;">局部内部类访问成员变量重名问题</span></span></div></li><ul><li><div><span style="font-size: 14.6667px;"><span style="color: rgb(166, 0, 196); font-size: 14.6667px; font-weight: bold;">访问外部类：super.变量名</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="color: rgb(166, 0, 196); font-size: 14.6667px; font-weight: bold;">访问方法内，内部类外：this.变量名</span></span></div></li><li><div><span style="font-size: 14.6667px;"><span style="color: rgb(166, 0, 196); font-size: 14.6667px; font-weight: bold;">访问本类直接用</span></span></div></li></ul></ul><div><span style="font-size: 11pt;">       4. 局部内部类的final问题</span></div><div><span style="font-size: 11pt;">                <span style="font-size: 11pt; color: rgb(166, 0, 196);">局部内部类，如果希望</span><span style="font-size: 11pt; color: rgb(166, 0, 196); font-weight: bold;">访问所在方法的局部变量</span><span style="font-size: 11pt; color: rgb(166, 0, 196);">，那么这个局部变量必须是</span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">有效final的</span></span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">    </span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">    </span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">    </span><span style="font-size: 11pt; color: rgb(255, 0, 0); font-weight: bold;">   </span> <span style="font-size: 11pt;">从Java8开始，只要局部变量事实不变，那么final关键字可以省略</span></span></div><div><span style="font-size: 11pt;"><span style="font-size: 11pt;">            原因备注：</span></span></div><ol start="3"><ol><li><div><span style="font-size: 14.6667px;background-color: rgb(255, 250, 165);-evernote-highlight:true;">new出来的对象在堆内存当中</span></div></li><li><div><span style="font-size: 14.6667px;background-color: rgb(255, 250, 165);-evernote-highlight:true;">局部变量是跟着方法走的，在栈内存当中</span></div></li><li><div><span style="font-size: 14.6667px;background-color: rgb(255, 250, 165);-evernote-highlight:true;">方法运行结束之后，立刻出栈，局部变量就立刻消失</span></div></li><li><div><span style="font-size: 14.6667px;background-color: rgb(255, 250, 165);-evernote-highlight:true;">但是new出来的对象会在堆当中持续存在，直到垃圾回收消失</span></div></li></ol></ol><div><span style="font-size: 11pt; background-color: rgb(255, 250, 165); font-weight: bold;-evernote-highlight:true;"> 3.匿名内部类</span></div><ol><li><div><span style="font-size: 14.6667px;">如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况就可以省略掉该类的定义，而改用匿名内部类。</span></div></li><li><div><span style="font-size: 14.6667px;">格式</span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco">接口名称  对象名  =  new  接口名称() {</font></div><div><font face="Monaco">        //覆盖所有抽象方法</font></div><div><font face="Monaco">};</font></div></div><div>      <span style="font-size: 11pt;">3. 注意事项</span><span style="font-size: 11pt;">  </span></div><ol><ol><li><div><span style="font-size: 14.6667px;">对格式进行解析“new 接口名称(){...}”</span></div></li><ol><li><div><span style="font-size: 11pt;">new代表创建对象的动作</span></div></li><li><div><span style="font-size: 14.6667px;">接口名称就是匿名内部类需要实现哪个接口</span></div></li><li><div><span style="font-size: 11pt;">{...}这才是匿名内部类的内容</span></div></li></ol><li><div><span style="font-size: 14.6667px;">注意几点：</span></div></li><ol><li><div><span style="font-size: 14.6667px;">匿名内部类在创建对象的时候只能使用唯一一次，</span><span style="font-size: 14.6667px;">如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了</span></div></li><li><div><span style="font-size: 14.6667px;">匿名对象，在调用方法的时候，只能调用一次，如果希望同一个对象调用多次方法，那么必须给对象起个名字</span></div></li><li><div>匿名内部类是省略了实现类/子类名称，但是匿名对象是省略了对象名称（匿名对象和匿名内部类不是一回事）</div></li></ol></ol></ol><div>                                                                    </div><div>拓展：</div><div>需要明白<span style="font-weight: bold;">类的加载顺序</span>。</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">(1) 父类静态对象和静态代码块</span></div><div>(2) 子类静态对象和静态代码块</div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">(3) 父类非静态对象和非静态代码块</span></div><div><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;">(4) 父类构造函数</span></div><div>(5) 子类 非静态对象和非静态代码块</div><div>(6) 子类构造函数</div><div><br/></div><div>第七天</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 