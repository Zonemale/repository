<html>
<head>
  <title>Spring1</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2030"/>
<h1>Spring1</h1>

<div>
<span><div><div><span style="font-size: 14pt; font-weight: bold;">一、spring的概述</span></div><ol><li><div><span style="font-size: 12pt;">Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，</span><span style="font-size: 12pt;">以 IoC（Inverse Of Control：</span><span style="font-size: 12pt;">反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring</span><span style="font-size: 12pt;">MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多</span><span style="font-size: 12pt;">著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架</span></div></li></ol><div><span style="font-size: 14pt; font-weight: bold;">二、spring体系结构</span></div><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="Spring1_files/spring-overview.png" type="image/png" data-filename="spring-overview.png"/></span></span></div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 11pt;"><b>1，Spring Core</b></font></div><div><font style="font-size: 11pt;"><b>Core模块是Spring的核心类库，Spring的所有功能都依赖于该类库，Core主要实现IOC功能，Spring的所有功能都是借助IOC实现的。</b></font></div><div><font style="font-size: 11pt;"><b>2，AOP</b></font></div><div><font style="font-size: 11pt;"><b>AOP模块是Spring的AOP库，提供了AOP（拦截器）机制，并提供常用的拦截器，供用户自定义和配置。</b></font></div><div><font style="font-size: 11pt;"><b>3，ORM</b></font></div><div><font style="font-size: 11pt;"><b>Spring 的ORM模块提供对常用的ORM框架的管理和辅助支持，Spring支持常用的Hibernate，ibtas，jdao等框架的支持，Spring本身并不对ORM进行实现，仅对常见的ORM框架进行封装，并对其进行管理</b></font></div><div><font style="font-size: 11pt;"><b>4，DAO模块</b></font></div><div><font style="font-size: 11pt;"><b>Spring 提供对JDBC的支持，对JDBC进行封装，允许JDBC使用Spring资源，并能统一管理JDBC事物，并不对JDBC进行实现。（执行sql语句）</b></font></div><div><font style="font-size: 11pt;"><b>5，WEB模块</b></font></div><div><font style="font-size: 11pt;"><b>WEB模块提供对常见框架如Struts1，WEBWORK（Struts 2），JSF的支持，Spring能够管理这些框架，将Spring的资源注入给框架，也能在这些框架的前后插入拦截器。</b></font></div><div><font style="font-size: 11pt;"><b>6，Context模块</b></font></div><div><font style="font-size: 11pt;"><b>Context模块提供框架式的Bean访问方式，其他程序可以通过Context访问Spring的Bean资源，相当于资源注入。</b></font></div><div><font style="font-size: 11pt;"><b>7，MVC模块</b></font></div><div><font style="font-size: 11pt;"><b>WEB MVC模块为Spring提供了一套轻量级的MVC实现，在Spring的开发中，我们既可以用Struts也可以用Spring自己的MVC框架，相对于Struts，Spring自己的MVC框架更加简洁和方便。</b></font></div></div><ol><li><div><span style="font-size: 16px;">程序的耦合</span></div></li><ol><li><div><span style="font-size: 16px;">耦合：程序间的依赖关系</span></div></li><ol><li><div><span style="font-size: 16px;">类之间的依赖</span></div></li><li><div><span style="font-size: 16px;">方法间的依赖</span></div></li></ol><li><div><span style="font-size: 16px;">解耦：降低程序间的依赖关系</span></div></li><li><div><span style="font-size: 16px;">实际开发中：应该做到编译期不依赖，运行时依赖</span></div></li><li><div><span style="font-size: 16px;">解耦思路：</span></div></li><ol><li><div><span style="font-size: 16px;">第一步：使用反射来创建对象，而避免使用new关键字</span></div></li><li><div><span style="font-size: 16px;">第二步：通过配置文件来获取要创建的对象全限定类名</span></div></li></ol><li><div><span style="font-size: 16px;">一个创建Bean对象的工厂</span></div></li><ol><li><div><span style="font-size: 16px;">第一个：需要一个配置文件来配置我们的service和dao</span></div></li><ol><li><div><span style="font-size: 16px;">配置的内容：唯一标识=全限定类名（key=value）</span></div></li></ol><li><div><span style="font-size: 16px;">通过读取配置文件中配置的内容，反射创建对象</span></div></li></ol></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">三、IOC的概念</span></div><ol><li><div><span style="font-size: 12pt;">控制反转：把创建对象的权利交给框架，是框架的重要特征，它包括依赖注入和依赖查找</span></div></li><li><div><span style="font-size: 12pt;">IOC的作用：削减计算机的耦合，（解除代码中的依赖关系）</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="Spring1_files/ioc.png" type="image/png" data-filename="ioc.png"/></span></span></div></li></ol><div><span style="font-size: 14pt; font-weight: bold;">四、使用spring中的IOC</span></div><ol><li><div>xml配置</div></li></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</div><div>&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</div><div>       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</div><div>       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</div><div>http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</div><div><br/></div><div>    &lt;bean id=&quot;accountDao&quot; class=&quot;com.vaught.dao.impl.AccountDaoImpl&quot;&gt;&lt;/bean&gt;</div><div>    &lt;bean id=&quot;accountService&quot; class=&quot;com.vaught.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</div><div><br/></div><div>&lt;/beans&gt;</div></div><ol><li><div><span style="font-size: 16px;">ApplicationContext的三个常用实现类</span></div></li><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(54, 101, 238);">ClassPathXmlApplicationContext</span>:它可以加载类路径下的配置文件，要求配置文件必须在类路径下</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(54, 101, 238);">FileSystemXmlApplicationContext</span>:它可以加载磁盘任意路径下的配置文件</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(54, 101, 238);">AnnotationConfigApplicationContext</span>:用于读取注解创建容器</span></div></li></ol><li><div><span style="font-size: 16px;">核心容器两个接口引发出的问题：</span></div></li><ol><li><div><span style="font-size: 12pt; color: rgb(255, 0, 0);">ApplicationContext</span><span style="font-size: 12pt;">:（单例对象适用）</span></div></li><ol><li><div><span style="font-size: 12pt;">它在构建核心容器时，创建对象采取的策略是采用立即加载的方式，也就是说，只要一读取玩配置文件马上就创建配置文件中配置的对象</span></div></li></ol><li><div><span style="font-size: 12pt;">BeanFactory:（多例对象适用）</span></div></li><ol><li><div><span style="font-size: 12pt;">它在构建核心容器时，创建对象采取的策略是采用延迟加载方式，也就是说，什么时候根据id获取对象了，什么时候才真正创建对象</span></div></li></ol></ol><li><div><span style="font-size: 16px;">创建bean的三种方式</span></div></li><ul><li><div><span style="font-size: 16px;">方式一：使用默认构造函数创建，在spring的配置文件中使用bean标签，配以id和class属性之后，且没有其他属性和标签时，采用的就是默认构造函数创建bean对象，如果类中没有构造函数，则无法创建对象</span></div></li></ul></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;accountService&quot; class=&quot;com.vaught.service.impl.AccountServiceImpl&quot;&gt;&lt;/bean&gt;</div></div><ul><ul><li><div><span style="font-size: 16px;">方式二：使用普通工厂中的方法创建对象（使用某个类中的方法创建对象，并存入spring容器）</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;instanceFactory&quot; class=&quot;com.vaught.factory.InstanceFactory&quot;&gt;&lt;/bean&gt;</div><div>&lt;bean id=&quot;accountService&quot; factory-bean=&quot;instanceFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</div></div><ul><ul><li><div><span style="font-size: 16px;">方式三：使用工厂中的静态方法创建对象（使用某个类中的静态方法创建对象，并存入spring容器）</span></div></li></ul></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;accountService&quot; class=&quot;com.vaught.factory.StaticFactory&quot; factory-method=&quot;getAccountService&quot;&gt;&lt;/bean&gt;</div></div><ol><li><div><span style="font-size: 16px;">bean对象的作用范围</span></div></li><ol><li><div><span style="font-size: 16px;">bean标签的scope属性：</span></div></li><ol><li><div><span style="font-size: 16px;">作用：用于指定bean的作用范围</span></div></li><li><div><span style="font-size: 16px;">取值：</span></div></li><ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(255, 0, 0);">singleton:单例的</span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">prototype:多例的</span></span></div></li><li><div><span style="font-size: 12pt;">request:作用于web应用的请求范围</span></div></li><li><div><span style="font-size: 12pt;">session:所用于web应用的会话范围</span></div></li><li><div><span style="font-size: 12pt;">global-session:作用于集群环境的会话范围（全局会话范围），当不是集群环境时，它就是session</span></div></li></ol></ol></ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">bean对象的生命周期</span></span></div></li><ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">单例对象：</span></span></div></li><ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">当容器创建时对象创建产生</span></span></div></li><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">只要容器还在，对象就存在</span></span></div></li><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">容器销毁，对象消亡</span></span></div></li><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">总结：单例对象的生命周期和容器相同</span></span></div></li></ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">多例对象：</span></span></div></li><ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">使用对象时，spring框架会创建</span></span></div></li><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">对象只要在使用过程中就会一直存在</span></span></div></li><li><div><span style="font-size: 16px;"><span style="font-size: 16px; color: rgb(54, 101, 238);">当对象长时间不用切没有别的对象引用时，由java的垃圾回收器回收</span></span></div></li></ol></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">五、spring中的依赖注入</span></div><ol><li><div><span style="font-size: 16px;">依赖注入：Dependency Injection</span></div></li><li><div><span style="font-size: 12pt;">IOC的作用：降低程序间的耦合（依赖关系）</span></div></li><li><div><span style="font-size: 16px;">依赖关系的管理：以后都交给spring来维护</span></div></li><li><div><span style="font-size: 16px;">在当前类需要用到其他类的对象，由spring为我们提供，我们只需要在配置文件中说明</span></div></li><li><div><span style="font-size: 16px;">依赖关系的维护：就称之为依赖注入</span></div></li><li><div><span style="font-size: 16px;">依赖注入：将类的对象的创建交给了spring容器，如果一个类的成员位置定义了成员变量，用到该变量需要给变量赋值，将赋值的工作交给spring</span></div></li><ol><li><div><span style="font-size: 16px;">能注入的数据有三类</span></div></li><ol><li><div><span style="font-size: 16px;">基本类型和String</span></div></li><li><div><span style="font-size: 16px;">其他bean类型（在配置文件中或者注解配置过的bean）</span></div></li><li><div><span style="font-size: 16px;">复杂类型、集合类型</span></div></li></ol><li><div><span style="font-size: 16px;">注入方式有三种：</span></div></li><ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; font-weight: bold;">构造函数</span></span></div></li><ol><li><div><span style="font-size: 16px;">使用标签：constructor-arg</span></div></li><li><div><span style="font-size: 16px;">标签在bean标签内部</span></div></li><li><div><span style="font-size: 16px;">标签中的属性：</span></div></li><ol><li><div><span style="font-size: 12pt;">type:用于指定要注入的数据的数据类型，该数据类型也是构造函数中某个或某些参数的类型</span></div></li><li><div><span style="font-size: 12pt;">index:用于指定要注入的数据给构造函数中指定索引位置的参数赋值，索引从0开始</span></div></li><li><div><span style="font-size: 12pt;">name:用于指定给构造函数中指定名称的参数赋值</span></div></li><li><div><span style="font-size: 12pt;">vaue:用于提供基本类型和String类型的数据</span></div></li><li><div><span style="font-size: 12pt;">ref:用于指定其他的bean类型数据，它指的就是在spring的IOC核心容器中出现过的bean对象</span></div></li></ol><li><div><span style="font-size: 16px;">优势：在获取bean对象时，注入数据是必须的操作，否则对象无法创建成功</span></div></li><li><div><span style="font-size: 16px;">弊端：改变了bean对象的实例化方式，使我们在创建对象时，如果用不到这些数据，也必须提供</span></div></li></ol></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;accountService&quot; class=&quot;com.vaught.service.impl.AccountServiceImpl&quot;&gt;</div><div>    &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/constructor-arg&gt;</div><div>    &lt;constructor-arg name=&quot;name&quot; value=&quot;还有&quot;&gt;&lt;/constructor-arg&gt;</div><div>    &lt;constructor-arg name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/constructor-arg&gt;</div><div>&lt;/bean&gt;</div><div><br/></div><div>&lt;bean id=&quot;now&quot; class=&quot;java.util.Date&quot;&gt;&lt;/bean&gt;</div></div><ol><ol><ol><li><div><span style="font-size: 16px;"><span style="font-size: 16px; font-weight: bold;">set方法</span></span></div></li><ol><li><div><span style="font-size: 16px;">涉及的标签：property</span></div></li><li><div><span style="font-size: 16px;">出现的位置：bean标签的内部</span></div></li><li><div><span style="font-size: 16px;">标签的属性：</span></div></li><ol><li><div><span style="font-size: 12pt;">name:用于指定注入时所电泳的set方法名称</span></div></li><li><div><span style="font-size: 12pt;">vaue:用于提供基本类型和String类型的数据</span></div></li><li><div><span style="font-size: 12pt;">ref:用于指定其他的bean类型数据，它指的就是在spring的IOC核心容器中出现过的bean对象</span></div></li></ol><li><div><span style="font-size: 16px;">优势：穿件对象时，没有明确的限制，可以直接使用默认构造函数</span></div></li><li><div><span style="font-size: 16px;">弊端：如果某个成员必须有值，则获取对象时可能set方法没有执行</span></div></li></ol></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;bean id=&quot;accountService2&quot; class=&quot;com.vaught.service.impl.AccountServiceImpl2&quot;&gt;</div><div>    &lt;property name=&quot;age&quot; value=&quot;18&quot;&gt;&lt;/property&gt;</div><div>    &lt;property name=&quot;name&quot; value=&quot;有一个&quot;&gt;&lt;/property&gt;</div><div>    &lt;property name=&quot;birthday&quot; ref=&quot;now&quot;&gt;&lt;/property&gt;</div><div>&lt;/bean&gt;</div><div><br/></div><div><b><font color="#FF0000" style="font-size: 12pt;">复杂类型：结构相同的集合，标签可以互换</font></b></div><div>&lt;bean id=&quot;accountService3&quot; class=&quot;com.vaught.service.impl.AccountServiceImpl3&quot;&gt;</div><div>    &lt;property name=&quot;myStrs&quot;&gt;</div><div>        &lt;array&gt;</div><div>            &lt;value&gt;aaa&lt;/value&gt;</div><div>            &lt;value&gt;bbb&lt;/value&gt;</div><div>            &lt;value&gt;ccc&lt;/value&gt;</div><div>        &lt;/array&gt;</div><div>    &lt;/property&gt;</div><div><br/></div><div>    &lt;property name=&quot;myList&quot;&gt;</div><div>        &lt;list&gt;</div><div>            &lt;value&gt;aaa&lt;/value&gt;</div><div>            &lt;value&gt;bbb&lt;/value&gt;</div><div>            &lt;value&gt;ccc&lt;/value&gt;</div><div>        &lt;/list&gt;</div><div>    &lt;/property&gt;</div><div><br/></div><div>    &lt;property name=&quot;mySet&quot;&gt;</div><div>        &lt;set&gt;</div><div>            &lt;value&gt;aaa&lt;/value&gt;</div><div>            &lt;value&gt;bbb&lt;/value&gt;</div><div>            &lt;value&gt;ccc&lt;/value&gt;</div><div>        &lt;/set&gt;</div><div>    &lt;/property&gt;</div><div><br/></div><div>    &lt;property name=&quot;myMap&quot;&gt;</div><div>        &lt;map&gt;</div><div>            &lt;entry key=&quot;testA&quot; value=&quot;aaa&quot;&gt;&lt;/entry&gt;</div><div>            &lt;entry key=&quot;testB&quot; value=&quot;bbb&quot;&gt;&lt;/entry&gt;</div><div>            &lt;entry key=&quot;testC&quot; value=&quot;ccc&quot;&gt;&lt;/entry&gt;</div><div>        &lt;/map&gt;</div><div>    &lt;/property&gt;</div><div><br/></div><div>    &lt;property name=&quot;myPro&quot;&gt;</div><div>        &lt;props&gt;</div><div>            &lt;prop key=&quot;testC&quot;&gt;5432&lt;/prop&gt;</div><div>        &lt;/props&gt;</div><div>    &lt;/property&gt;</div><div>&lt;/bean&gt;</div></div><ol><ol><li><div><span style="font-size: 14pt; font-weight: bold;">注解</span></div></li><ol><li><div><span style="font-size: 16px;">用于创建对象的：</span><span style="font-size: 12pt;">他们的作用就和在XML配置文件中编写一个&lt;bean&gt;标签实现的功能是一样的</span></div></li><ol><li><div><span style="font-size: 12pt;">Component</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：用于把当前类对象存入spring容器中</span></div></li><li><div><span style="font-size: 12pt;">属性：</span><span style="font-size: 12pt;">value：用于指定bean的id。当我们不写时，它的默认值是当前类名，且首字母改小写。</span></div></li></ol><li><div><span style="font-size: 12pt;">Controller：一般用在表现层</span></div></li><li><div><span style="font-size: 12pt;">Service：一般用在业务层</span></div></li><li><div><span style="font-size: 12pt;">Repository：一般用在持久层</span></div></li><li><div><span style="font-size: 12pt;">以上三个注解他们的作用和属性与Component是一模一样。</span><span style="font-size: 12pt;">他们三个是spring框架为我们提供明确的三层使用的注解，使我们的三层对象更加清晰</span></div></li></ol><li><div><span style="font-size: 16px;">用于注入数据的：</span><span style="font-size: 12pt;">他们的作用就和在xml配置文件中的bean标签中写一个&lt;property&gt;标签的作用是一样的</span></div></li><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(54, 101, 238);">Autowired:</span></span></div></li><ol><li><div><span style="font-size: 12pt;">作用：</span></div></li><ol><li><div><span style="font-size: 12pt; color: rgb(235, 0, 115);">自动按照类型注入</span><span style="font-size: 12pt;">。只要容器中有</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">唯一的一个bean对象类型</span><span style="font-size: 12pt;">和要注入的变量类型匹配，就可以注入成功</span></div></li><li><div><span style="font-size: 12pt;"> 如果ioc容器中没有任何bean的类型和要注入的变量类型匹配，则报错。</span></div></li><li><div><span style="font-size: 12pt;">如果Ioc容器中有多个类型匹配时：</span></div></li><ol><li><div><span style="font-size: 12pt;">出现位置：</span></div></li><ol><li><div><span style="font-size: 12pt;">可以是变量上，也可以是方法上</span></div></li></ol><li><div><span style="font-size: 12pt;">细节：</span></div></li><ol><li><div><span style="font-size: 12pt;">在使用注解注入时，set方法就不是必须的了。</span><span style="font-size: 12pt;"><img src="Spring1_files/自动按照类型注入.png" type="image/png" data-filename="自动按照类型注入.png"/></span></div></li></ol></ol></ol></ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(54, 101, 238);">Qualifier:</span></span></div></li><ol><li><div><span style="font-size: 12pt;">作用：</span><span style="font-size: 12pt; color: rgb(235, 0, 115);">在按照类中注入的基础之上再按照名称注入</span><span style="font-size: 12pt;">。</span><span style="font-size: 12pt; color: rgb(227, 0, 0);">它在给类成员注入时不能单独使用。但是在给方法参数注入时可以</span></div></li><li><div><span style="font-size: 12pt;">属性：</span></div></li><ol><li><div><span style="font-size: 12pt;">value：用于指定注入bean的id。</span></div></li></ol></ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(54, 101, 238); font-weight: bold;">Resource</span></span></div></li><ol><li><div><span style="font-size: 12pt;">作用：<span style="font-size: 12pt; color: rgb(235, 0, 115);">直接按照bean的id注入。它可以独立使用</span></span></div></li><li><div><span style="font-size: 12pt;">属性：</span></div></li><ol><li><div><span style="font-size: 12pt;"> <span style="font-size: 12pt; color: rgb(241, 79, 154);">name：用于指定bean的id。</span></span></div></li></ol></ol><li><div><span style="font-size: 12pt;">以上三个注入都只能注入其他bean类型的数据，而基本类型和String类型无法使用上述注解实现。</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(88, 152, 255); font-weight: bold;">另外，集合类型的注入只能通过XML来实现。</span></span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Value</span></span></div></li><ol><li><div><span style="font-size: 12pt;">作用：<span style="font-size: 12pt; color: rgb(235, 0, 115);">用于注入</span><span style="font-size: 12pt; color: rgb(235, 0, 115); font-weight: bold;">基本类型和String</span><span style="font-size: 12pt; color: rgb(235, 0, 115);">类型的数据</span></span></div></li><li><div><span style="font-size: 12pt;">属性：</span></div></li><li><div><span style="font-size: 12pt;"> value：用于指定</span><span style="font-size: 12pt; color: rgb(255, 0, 0);">数据的值</span><span style="font-size: 12pt;">。它可以使用spring中SpEL(也就是spring的el表达式）</span></div></li><li><div><span style="font-size: 12pt;">SpEL的写法：${表达式}</span></div></li></ol></ol><li><div><span style="font-size: 16px;">用于改变作用范围的：</span><span style="font-size: 12pt;">他们的作用就和在bean标签中使用scope属性实现的功能是一样的</span></div></li><ol><li><div><span style="font-size: 12pt;">Scope（默认情况下是singleton单例的）</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：用于指定bean的作用范围</span></div></li><li><div><span style="font-size: 12pt;">属性：</span></div></li><ol><li><div><span style="font-size: 12pt;">value：指定范围的取值。常用取值：singleton prototype</span></div></li></ol></ol></ol><li><div><span style="font-size: 16px;">和生命周期相关：</span><span style="font-size: 12pt;">他们的作用就和在bean标签中使用init-method和destroy-methode的作用是一样的</span></div></li><ol><li><div><span style="font-size: 12pt;">PreDestroy</span></div></li><ol><li><div><span style="font-size: 12pt;"> 作用：用于指定销毁方法</span></div></li></ol><li><div><span style="font-size: 12pt;">PostConstruct</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：用于指定初始化方法</span></div></li></ol></ol><li><div><span style="font-size: 16px;">配置文件相关</span></div></li><ol><li><div><span style="font-size: 12pt;">Configuration</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：指定当前类是一个配置类</span></div></li><li><div><span style="font-size: 12pt;">细节：当配置类作为AnnotationConfigApplicationContext对象创建的参数时，该注解可以不写。</span></div></li></ol><li><div><span style="font-size: 12pt;">ComponentScan</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：用于通过注解指定spring在创建容器时要扫描的包</span></div></li><li><div><span style="font-size: 12pt;">属性：</span></div></li><ol><li><div><span style="font-size: 12pt;">value：它和basePackages的作用是一样的，都是用于指定创建容器时要扫描的包。</span></div></li><li><div><span style="font-size: 12pt;">我们使用此注解就等同于在xml中配置了:</span></div></li><li><div><span style="font-size: 12pt;">&lt;context:component-scan base-package=&quot;com.itheima&quot;&gt;&lt;/context:component-scan&gt;</span></div></li></ol></ol><li><div><span style="font-size: 16px;">Bean</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：用于把当前方法的返回值作为bean对象存入spring的ioc容器中</span></div></li><li><div><span style="font-size: 12pt;">属性:</span></div></li><ol><li><div><span style="font-size: 12pt;">name:用于指定bean的id。当不写时，默认值是当前方法的名称</span></div></li></ol><li><div><span style="font-size: 12pt;">细节：</span></div></li><ol><li><div><span style="font-size: 12pt;">当我们使用注解配置方法时，如果方法有参数，spring框架会去容器中查找有没有可用的bean对象。</span><span style="font-size: 12pt;"> 查找的方式和Autowired注解的作用是一样的</span></div></li></ol></ol><li><div><span style="font-size: 16px;">Import</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：用于导入其他的配置类</span></div></li><li><div><span style="font-size: 12pt;">属性：</span></div></li><ol><li><div><span style="font-size: 12pt;">value：用于指定其他配置类的字节码。</span></div></li><li><div><span style="font-size: 12pt;">当我们使用Import的注解之后，有Import注解的类就父配置类，而导入的都是子配置类</span></div></li></ol></ol><li><div><span style="font-size: 12pt;">PropertySource</span></div></li><ol><li><div><span style="font-size: 12pt;">作用：用于指定properties文件的位置</span></div></li><li><div><span style="font-size: 12pt;">属性：</span></div></li><ol><li><div><span style="font-size: 12pt;">value：指定文件的名称和路径。</span></div></li><li><div><span style="font-size: 12pt;">关键字：classpath，表示类路径下</span></div></li></ol></ol></ol><li><div><span style="font-size: 12pt;"><img src="Spring1_files/无标题.png" type="image/png" data-filename="无标题.png"/></span></div></li></ol></ol></ol><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">六、spring整合Junit单元测试</span></font></div><ol><li><div><span style="font-size: 16px;">Junit单元测试中，没有main方法也能执行</span></div></li><ol><li><div><span style="font-size: 16px;">Junit继承了一个main方法，该方法就会判断当前测试类中哪些方法有@Test注解，Junit就会让Test注解的方法执行</span></div></li></ol><li><div><span style="font-size: 16px;">步骤配置：</span></div></li><ol><li><div><span style="font-size: 16px;">导入spring整合Junit的jar</span></div></li><li><div><span style="font-size: 16px;">使用Junit提供的一个注解把原有的main方法替换了，替换成spring提供的</span></div></li><ol><li><div><span style="font-size: 12pt;">@Runwith</span></div></li></ol><li><div><span style="font-size: 16px;">告知spring的运行器，spring和IOC创建 是基于xml还是配置，并说明位置</span></div></li><ol><li><div><span style="font-size: 12pt;">@ContextConfiguration</span></div></li><ol><li><div><span style="font-size: 12pt;">locations:指定xml文件的位置加上classpath关键字表示在类路径下</span></div></li><li><div><span style="font-size: 12pt;">classes:指定注解类所在的位置</span></div></li></ol></ol><li><div><span style="font-size: 16px;">注意：使用spring5.x版本的时候，要求Junit的jar必须是4.12及以上</span></div></li></ol></ol><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 