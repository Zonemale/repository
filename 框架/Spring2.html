<html>
<head>
  <title>Spring2</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600388 (zh-CN, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2044"/>
<h1>Spring2</h1>

<div>
<span><div><div><span style="font-size: 14pt; font-weight: bold;">一、事务控制</span></div><div><img src="Spring2_files/事务控制.png" type="image/png" data-filename="事务控制.png"/></div><ol><li><div><span style="font-size: 12pt;">动态代理：</span></div></li><ol><li><div><span style="font-size: 12pt;">特点：字节码随用随创建，随用随加载</span></div></li><li><div><span style="font-size: 12pt;">作用：不修改源码的基础上对方法增强</span></div></li><li><div><span style="font-size: 12pt;">分类：</span></div></li><ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(209, 0, 255);">基于接口的动态代理</span></span></div></li><ol><li><div><span style="font-size: 12pt;">涉及的类：Proxy</span></div></li><li><div><span style="font-size: 12pt;">提供者：JDK管方</span></div></li><li><div><span style="font-size: 12pt;">使用Proxy类中的newProxyInstance方法创建</span></div></li><ol><li><div><span style="font-size: 12pt;">newProxyInstance方法的参数</span></div></li><ol><li><div><span style="font-size: 12pt;">ClassLoader:类加载器，用于加载代理对象字节码，使用和被代理对象相同的类加载器</span></div></li><li><div><span style="font-size: 12pt;">Class[]：字节码数组，他是用于让代理对象和被代理对象有相同方法</span></div></li><li><div><span style="font-size: 12pt;">InvocationHandler：用于提供增强的代码，他是让我们写如何代理，我们一般都实现一个接口的实现类，通常情况下使用匿名内部类</span></div></li></ol></ol><li><div><span style="font-size: 12pt;">被代理类最少实现一个接口，如果没有则不能使用</span></div></li></ol><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(166, 0, 196);">基于子类的动态代理</span></span></div></li><ol><li><div><span style="font-size: 16px;">设计的类：Enhancer</span></div></li><li><div><span style="font-size: 16px;">提供者：第三方cglib库</span></div></li><li><div><span style="font-size: 16px;">使用Enhancer类中的create方法创建代理对象</span></div></li><ol><li><div><span style="font-size: 16px;">被代理类不能是最终类</span></div></li><li><div><span style="font-size: 16px;">create方法的参数</span></div></li><ol><li><div><span style="font-size: 12pt;">Class：字节码，他是用于指定被代理对象的字节码</span></div></li><li><div><span style="font-size: 16px;">Callback：用于提供增强的代码，一般写的都是该接口的子接口实现类：MethodInterceptor</span></div></li></ol></ol></ol></ol></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">二、AOP</span></div><ol><li><div><span style="font-size: 16px;">概念：</span><span style="font-size: 12pt;">全称是 Aspect Oriented Programming 即：面向切面编程。</span></div></li><ol><li><div><span style="font-size: 12pt;">简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码</span><span style="font-size: 12pt;">基础上，对我们的已有方法进行增强。</span></div></li></ol><li><div><span style="font-size: 12pt;">作用：</span></div></li><ol><li><div><span style="font-size: 12pt;">在程序运行期间，不修改源码对已有方法进行增强。</span></div></li></ol><li><div><span style="font-size: 12pt;">优势：</span></div></li><ol><li><div><span style="font-size: 12pt;">减少重复代码</span></div></li><li><div><span style="font-size: 12pt;">提高开发效率</span></div></li><li><div><span style="font-size: 12pt;">维护方便</span></div></li></ol><li><div><span style="font-size: 16px;">spring中的AOP</span></div></li><ol><li><div><span style="font-size: 12pt;">Joinpoint( 连接点)：</span></div></li><ol><li><div><span style="font-size: 12pt;">所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的</span><span style="font-size: 12pt;">连接点。</span></div></li></ol><li><div><span style="font-size: 16px;">Pointcut（切入点）：</span></div></li><ol><li><div><span style="font-size: 12pt;">所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义，也就是会增强的连接点</span></div></li></ol><li><div><span style="font-size: 12pt;">Advice( 通知/ 增强):</span></div></li><ol><li><div><span style="font-size: 12pt;">所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知</span></div></li><li><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0);">通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知</span>。</span><span style="font-size: 12pt;"><img src="Spring2_files/通知的类型.jpg" type="image/jpeg" data-filename="通知的类型.jpg"/></span></div></li></ol><li><div><span style="font-size: 16px;">Introduction（引介）</span></div></li><ol><li><div><span style="font-size: 12pt;">引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方</span><span style="font-size: 12pt;">法或 Field。</span></div></li></ol><li><div><span style="font-size: 12pt;">Target(目标对象）：</span><span style="font-size: 12pt;">代理的目标对象。</span></div></li><li><div><span style="font-size: 12pt;">Weaving( 织入):</span></div></li><ol><li><div><span style="font-size: 12pt;">是指把增强应用到目标对象来创建新的代理对象的过程</span></div></li><li><div><span style="font-size: 12pt;">spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入</span></div></li></ol><li><div><span style="font-size: 16px;">Proxy（代理）:</span></div></li><ol><li><div><span style="font-size: 12pt;">一个类被 AOP 织入增强后，就产生一个结果代理类。</span></div></li></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font face="Monaco" style="font-size: 12pt;"><b>学习spring中的aop要明确的事：</b></font></div><div><b><font style="font-size: 12pt;">a 、开发阶段（我们做的）</font></b></div><div><b><font style="font-size: 12pt;">编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。</font></b></div><div><b><font style="font-size: 12pt;">把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP 编程人员来做。</font></b></div><div><b><font style="font-size: 12pt;">在配置文件中，声明切入点与通知间的关系，即切面。：AOP 编程人员来做。</font></b></div><div><b><font style="font-size: 12pt;">b 、运行阶段（Spring  框架完成的）</font></b></div><div><b><font style="font-size: 12pt;">Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对</font></b></div><div><b><font style="font-size: 12pt;">象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行</font></b></div></div><ol><ol><li><div><span style="font-size: 12pt;">spring中基于xml的AOP配置</span></div></li><ol><li><div><span style="font-size: 12pt;">把通知Bean也交给spring来管理</span></div></li><li><div><span style="font-size: 12pt;">使用aop:config标签表名开始AOP的配置</span></div></li><li><div><span style="font-size: 12pt;">使用aop:aspect标签表名配置切面</span></div></li><ol><li><div><span style="font-size: 12pt;">id属性：是给切面提供一个唯一标识</span></div></li><li><div><span style="font-size: 12pt;">ref属性：是指定通知类bean的Id</span></div></li></ol><li><div><span style="font-size: 12pt;">在aop:aspect标签的内部使用对应标签来配置通知的类型</span></div></li><ol><li><div><span style="font-size: 12pt;">aop:before：标识配置前置通知</span></div></li><ol><li><div><span style="font-size: 12pt;">method属性：用于指定Logger类中哪个方法是前置通知</span></div></li><li><div><span style="font-size: 12pt;">printcut属性：用于指定切入点表达式，该表达式的含义是针对业务层中哪些方法增强</span></div></li></ol><li><div><span style="font-size: 12pt;">切入点表达式写法：</span></div></li><ol><li><div><span style="font-size: 12pt;">关键字：execution(表达式)</span></div></li><li><div><span style="font-size: 12pt;">表达式：</span></div></li><ol><li><div><span style="font-size: 12pt;">访问修饰符 返回值 包名.包名.....类名.方法名(参数列表)</span></div></li><li><div><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 0, 0); font-family: &quot;Droid Sans Mono&quot;;">&lt;</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(102, 14, 122); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">aop</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 0, 128); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">:before</span> <span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 0, 255); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">method</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 128, 0); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">=&quot;printLog&quot;</span> <span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 0, 255); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">pointcut</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 128, 0); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">=&quot;execution(public void com.vaught.utils.Logger.printLog())&quot;</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 0, 0); font-family: &quot;Droid Sans Mono&quot;;">&gt;&lt;/</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(102, 14, 122); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">aop</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 0, 128); font-family: &quot;Droid Sans Mono&quot;; font-weight: bold;">:before</span><span style="background-color: rgb(239, 239, 239); font-size: 12pt; color: rgb(0, 0, 0); font-family: &quot;Droid Sans Mono&quot;;">&gt;</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">访问修饰符可以省略</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">返回值可以使用通配符</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">包名可以使用通配符，表示任意包，有几集包就写几个*</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">包名可以使用..表示当前包和子级</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">类名和方法名都可以使用*号实现通配</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">参数列表：</span></div></li><ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">可以直接写数据类型</span></div></li><ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">基本类型直接写名称</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">引用类型写包名.类名的方式</span></div></li></ol></ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">全通配写法：* *..*.*(..)</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">切到业务层实现类下的所有方法* com.vaught.service.impl.*.*(..)</span></div></li></ol></ol></ol></ol></ol></ol><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>&lt;!--配置AOP--&gt;</div><div>&lt;aop:config&gt;</div><div>    &lt;!--配置切面 --&gt;</div><div>    &lt;aop:pointcut id=&quot;ptt&quot; expression=&quot;execution(* com.vaught.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</div><div>    &lt;aop:aspect id=&quot;logAdvice&quot; ref=&quot;logger&quot;&gt;</div><div>        &lt;!-- 配置通知的类型，并且建立通知方法和切入点方法的关联--&gt;</div><div>        &lt;aop:before method=&quot;printLogBefore&quot; pointcut-ref=&quot;ptt&quot;&gt;&lt;/aop:before&gt;</div><div>        &lt;aop:after-returning method=&quot;pringLogAfterReturn&quot; pointcut-ref=&quot;ptt&quot; &gt;&lt;/aop:after-returning&gt;</div><div>        &lt;aop:after-throwing method=&quot;printLogAfterThrow&quot; pointcut-ref=&quot;ptt&quot;&gt;&lt;/aop:after-throwing&gt;</div><div>        &lt;aop:after method=&quot;printLogAfter&quot; pointcut-ref=&quot;ptt&quot;&gt;&lt;/aop:after&gt;</div><div>    &lt;/aop:aspect&gt;</div><div>&lt;/aop:config&gt;</div><div><br/></div><div><br/></div><div><br/></div><div>&lt;!--配置事务通知--&gt;</div><div>&lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt;</div><div>    &lt;tx:attributes&gt;</div><div>        &lt;tx:method name=&quot;*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;</div><div>        &lt;tx:method name=&quot;find*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;&gt;&lt;/tx:method&gt;</div><div>    &lt;/tx:attributes&gt;</div><div>&lt;/tx:advice&gt;</div><div><br/></div><div>&lt;!--配置aop--&gt;</div><div>&lt;aop:config&gt;</div><div>    &lt;aop:pointcut id=&quot;pt1&quot; expression=&quot;execution(* com.itheima.service.impl.*.*(..))&quot;&gt;&lt;/aop:pointcut&gt;</div><div>    &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;pt1&quot;&gt;&lt;/aop:advisor&gt;</div><div>&lt;/aop:config&gt;</div></div><ol><ol><ol><ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">环绕通知</span></div></li><ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">问题：</span></div></li><ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">当我们配置了环绕通知之后，切入点方法没有执行，而通知方法执行了。</span></div></li></ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">分析：</span></div></li><ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">通过对比动态代理中的环绕通知代码，发现动态代理的环绕通知有明确的切入点方法调用，而我们的代码中没有。</span></div></li></ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">解决：</span></div></li><ol><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">Spring框架为我们提供了一个接口：ProceedingJoinPoint。该接口有一个方法proceed()，此方法就相当于明确调用切入点方法</span></div></li><li><div><span style="font-size: 12pt; font-family: &quot;Droid Sans Mono&quot;;">该接口可以作为环绕通知的方法参数，在程序执行时，spring框架会为我们提供该接口的实现类供我们使用</span></div></li></ol><li><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(188, 0, 88); font-family: &quot;Droid Sans Mono&quot;;">spring中的环绕通知：</span><span style="font-size: 12pt; color: rgb(188, 0, 88); font-family: &quot;Droid Sans Mono&quot;;">它是spring框架为我们提供的一种可以在代码中手动控制增强方法何时执行的方式。</span></font></div></li></ol></ol></ol></ol></ol><div><span style="font-size: 14pt; font-weight: bold;">三、spring中的JdbcTemplate</span></div><ol><li><div>它是 spring 框架中提供的一个对象，是对原始 Jdbc API 对象的简单封装。spring 框架为我们提供了很多的操作模板类</div></li><ol><li><div>操作关系型数据的：</div></li><ol><li><div>JdbcTemplate</div></li><li><div>HibernateTemplate</div></li></ol><li><div>操作 nosql 数据库的</div></li><ol><li><div>RedisTemplate</div></li></ol><li><div>操作消息队列的</div></li><ol><li><div>JmsTemplate</div></li></ol></ol></ol><div><span style="font-weight: bold; font-size: 14pt;">四、事务</span></div><div><img src="Spring2_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="Spring2_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">1.事务的传播行为</font></div><div><font color="#FF0000" style="font-size: 12pt;"><b>REQUIRED:如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选</b></font></div><div><font color="#FF0000" style="font-size: 12pt;"><b>择（默认值）</b></font></div><div><font color="#FF0000" style="font-size: 12pt;"><b>SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</b></font></div><div><font style="font-size: 12pt;">MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常</font></div><div><font style="font-size: 12pt;">REQUERS_NEW:新建事务，如果当前在事务中，把当前事务挂起。</font></div><div><font style="font-size: 12pt;">NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</font></div><div><font style="font-size: 12pt;">NEVER:以非事务方式运行，如果当前存在事务，抛出异常</font></div><div><font style="font-size: 12pt;">NESTED:如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作。</font></div><div><font style="font-size: 12pt;">2.配置事务属性：</font></div><div><font style="font-size: 12pt;">isolation:用于指定事务的隔离级别，默认值是DEFAULT，表示使用数据库的默认隔离级别</font></div><div><font style="font-size: 12pt;">no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其它异常时回滚，没有默认值，表示任何异常都回滚</font></div><div><font style="font-size: 12pt;">propagation:用于指定事务的传播行为，默认值是REQUIRED，表示一定会有事务，增删改的选择，查询 可以选择SUPPORTS</font></div><div><font style="font-size: 12pt;">read-only:用于指定事务是否只读，只有查询方法才能设置为true，默认值是false，表示读写</font></div><div><font style="font-size: 12pt;">rollback-for:用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚，默认回滚</font></div><div><font style="font-size: 12pt;">timeout:用于指定事务的超时时间，默认值是-1，表示永不超时，如果指定了数值，则以秒为单位</font></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 